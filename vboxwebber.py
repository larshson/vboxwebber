# Copyright (C) 2008-2016 Oracle Corporation
#
# This file is part of a free software library; you can redistribute
# it and/or modify it under the terms of the GNU Lesser General
# Public License version 2.1 as published by the Free Software
# Foundation and shipped in the "COPYING.LIB" file with this library.
# The library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY of any kind.
#
# Oracle LGPL Disclaimer: For the avoidance of doubt, except that if
# any license choice other than GPL or LGPL is available it will
# apply instead, Oracle elects to use only the Lesser General Public
# License version 2.1 (LGPLv2) at this time for any software where
# a choice of LGPL license versions is made available with the
# language indicating that LGPLv2 or any later version may be used,
# or where a choice of which version of the LGPL is applied is
# otherwise unspecified.
#
# This file is autogenerated from VirtualBox.xidl, DO NOT EDIT!
#
# It supports Python 3 by using a ZEEP client as manager for 
# the SOAP requests towards a VirtualBox web service.

import zeep

class ObjectRefManager:
  def __init__(self, sessionmgr):
     self.map = {}
     self.sessionmgr = sessionmgr

  def register(self, handle):
     if handle == None:
        return
     c = self.map.get(handle,0)
     c = c + 1
     self.map[handle]=c

  def unregister(self, handle):
     if handle == None:
        return
     c = self.map.get(handle,-1)
     if c == -1:
        raise Error('wrong refcount')
     c = c - 1
     if c == 0:
        try:
            self.sessionmgr.getService().IManagedObjectRef_release(handle)
        except:
            pass
        del self.map[handle]
     else:
        self.map[handle] = c

class String:
  def __init__(self, mgr, handle, isarray = False):
      self.handle = handle
      self.mgr = mgr
      self.isarray = isarray

  def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

  def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

  def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

  def __getitem__(self, index):
      if self.isarray:
          return String(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

  def __str__(self):
      return str(self.handle)

  def __eq__(self,other):
      if self.isarray:
         return isinstance(other,String) and self.handle == other.handle
      if isinstance(other,String):
         return self.handle == other.handle
      if isinstance(other,str):
         return self.handle == other
      return False

  def __ne__(self,other):
      if self.isarray:
         return not isinstance(other,String) or self.handle != other.handle
      if isinstance(other,String):
         return self.handle != other.handle
      if isinstance(other,str):
         return self.handle != other
      return True

  def __add__(self,other):
      return str(self.handle)+str(other)


class Boolean:
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       if self.handle == "false":
          self.handle = None
       self.mgr = mgr
       self.isarray = isarray

  def __str__(self):
       if self.handle:
         return "true"
       else:
         return "false"

  def __eq__(self,other):
      if isinstance(other,Bool):
         return self.handle == other.value
      if isinstance(other,bool):
         return self.handle == other
      return False

  def __ne__(self,other):
      if isinstance(other,Bool):
         return self.handle != other.handle
      if isinstance(other,bool):
         return self.handle != other
      return True

  def __int__(self):
      if self.handle:
        return 1
      else:
        return 0

  def __long__(self):
      if self.handle:
        return 1
      else:
        return 0

  def __nonzero__(self):
      if self.handle:
        return True
      else:
        return False

  def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

  def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

  def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

  def __getitem__(self, index):
      if self.isarray:
          return Boolean(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

class Number:
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

  def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

  def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

  def __str__(self):
       return str(self.handle)

  def __int__(self):
       return int(self.handle)

  def __long__(self):
       return long(self.handle)

  def __float__(self):
       return float(self.handle)

  def __lt__(self, other):
       if self.isarray:
            return NotImplemented
       else:
            return self.handle < other

  def __le__(self, other):
       if self.isarray:
            return NotImplemented
       else:
            return self.handle <= other

  def __eq__(self, other):
       return self.handle == other

  def __ne__(self, other):
       return self.handle != other

  def __gt__(self, other):
       if self.isarray:
            return NotImplemented
       else:
            return self.handle > other

  def __ge__(self, other):
       if self.isarray:
            return NotImplemented
       else:
            return self.handle >= other

class Octet:
  def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
           self.handle = mgr.decodebase64(handle)
       else:
           raise TypeError("only octet arrays")

  def __getitem__(self, index):
      return self.handle[index]

  def __str__(self):
       return str(self.handle)

  def __len__(self):
      return self.handle.__len__()

class UnsignedInt(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return UnsignedInt(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")


class Int(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return Int(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

class UnsignedShort(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return UnsignedShort(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

class Short(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return Short(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

class UnsignedLong(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return UnsignedLong(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

class Long(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return Long(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

class Double(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return Double(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

class Float(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return Float(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

class IUnknown:
  def __init__(self,  mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __nonzero__(self):
      if self.handle != "":
           return True
      else:
           return False

  def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

  def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

  def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

  def __getitem__(self, index):
      if self.isarray:
          return IUnknown(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

  def __str__(self):
       return str(self.handle)

  def __eq__(self, other):
       return self.handle == other

  def __ne__(self, other):
       return self.handle != other

  def __getattr__(self,attr):
       if self.__class__.__dict__.get(attr) != None:
           return self.__class__.__dict__.get(attr)
       if self.__dict__.get(attr) != None:
           return self.__dict__.get(attr)
       raise AttributeError



class IVirtualBoxErrorInfo(IUnknown):
   """
      The IVirtualBoxErrorInfo interface represents extended error information.

      Extended error information can be set by VirtualBox components after
      unsuccessful or partially successful method invocation. This information
      can be retrieved by the calling party as an IVirtualBoxErrorInfo object
      and then shown to the client in addition to the plain 32-bit result code.

      In MS COM, this interface extends the IErrorInfo interface,
      in XPCOM, it extends the nsIException interface. In both cases,
      it provides a set of common attributes to retrieve error
      information.

      Sometimes invocation of some component's method may involve methods of
      other components that may also fail (independently of this method's
      failure), or a series of non-fatal errors may precede a fatal error that
      causes method failure. In cases like that, it may be desirable to preserve
      information about all errors happened during method invocation and deliver
      it to the caller. The #next attribute is intended
      specifically for this purpose and allows to represent a chain of errors
      through a single IVirtualBoxErrorInfo object set after method invocation.

      
        .. note:: errors are stored to a chain in the reverse order, i.e. the
      initial error object you query right after method invocation is the last
      error set by the callee, the object it points to in the @a next attribute
      is the previous error and so on, up to the first error (which is the last
      in the chain).
      Interface ID:
        {C1BCC6D5-7966-481D-AB0B-D0ED73E28135}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IVirtualBoxErrorInfo(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVirtualBoxErrorInfo._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVirtualBoxErrorInfo._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getResultCode(self):
       """
        Result code of the error.
        Usually, it will be the same as the result code returned
        by the method that provided this error information, but not
        always. For example, on Win32, CoCreateInstance() will most
        likely return E_NOINTERFACE upon unsuccessful component
        instantiation attempt, but not the value the component factory
        returned. Value is typed 'long', not 'result',
        to make interface usable from scripting languages.
        
        .. note:: 
          In MS COM, there is no equivalent.
          In XPCOM, it is the same as nsIException::result.
         """
       val = self.mgr.getService().IVirtualBoxErrorInfo_getResultCode(self.handle)
       return Int(self.mgr, val)

   def getResultDetail(self):
       """
        Optional result data of this error. This will vary depending on the
        actual error usage. By default this attribute is not being used.
       """
       val = self.mgr.getService().IVirtualBoxErrorInfo_getResultDetail(self.handle)
       return Int(self.mgr, val)

   def getInterfaceID(self):
       """
        UUID of the interface that defined the error.
        
        .. note:: 
          In MS COM, it is the same as IErrorInfo::GetGUID, except for the
          data type.
          In XPCOM, there is no equivalent.
         """
       val = self.mgr.getService().IVirtualBoxErrorInfo_getInterfaceID(self.handle)
       return String(self.mgr, val)

   def getComponent(self):
       """
        Name of the component that generated the error.
        
        .. note:: 
          In MS COM, it is the same as IErrorInfo::GetSource.
          In XPCOM, there is no equivalent.
         """
       val = self.mgr.getService().IVirtualBoxErrorInfo_getComponent(self.handle)
       return String(self.mgr, val)

   def getText(self):
       """
        Text description of the error.
        
        .. note:: 
          In MS COM, it is the same as IErrorInfo::GetDescription.
          In XPCOM, it is the same as nsIException::message.
         """
       val = self.mgr.getService().IVirtualBoxErrorInfo_getText(self.handle)
       return String(self.mgr, val)

   def getNext(self):
       """
        Next error object if there is any, or @c null otherwise.
        
        .. note:: 
          In MS COM, there is no equivalent.
          In XPCOM, it is the same as nsIException::inner.
         """
       val = self.mgr.getService().IVirtualBoxErrorInfo_getNext(self.handle)
       return IVirtualBoxErrorInfo(self.mgr, val)



   _Attrs_ = {'resultCode':[getResultCode,None],
              'resultDetail':[getResultDetail,None],
              'interfaceID':[getInterfaceID,None],
              'component':[getComponent,None],
              'text':[getText,None],
              'next':[getNext,None]}

class INATNetwork(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INATNetwork(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATNetwork._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATNetwork._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def addLocalMapping(self, _arg_hostid, _arg_offset):
       """
        :param _arg_hostid: 
        :param _arg_offset: 

       """
   
       req = (self.handle,)
       req += (_arg_hostid,)
       req += (_arg_offset,)
       val = self.mgr.getService().INATNetwork_addLocalMapping(*req)
       
       return 

   def addPortForwardRule(self, _arg_isIpv6, _arg_ruleName, _arg_proto, _arg_hostIP, _arg_hostPort, _arg_guestIP, _arg_guestPort):
       """       """
   
       req = (self.handle,)
       req += (_arg_isIpv6,)
       req += (_arg_ruleName,)
       req += (_arg_proto,)
       req += (_arg_hostIP,)
       req += (_arg_hostPort,)
       req += (_arg_guestIP,)
       req += (_arg_guestPort,)
       val = self.mgr.getService().INATNetwork_addPortForwardRule(*req)
       
       return 

   def removePortForwardRule(self, _arg_iSipv6, _arg_ruleName):
       """       """
   
       req = (self.handle,)
       req += (_arg_iSipv6,)
       req += (_arg_ruleName,)
       val = self.mgr.getService().INATNetwork_removePortForwardRule(*req)
       
       return 

   def start(self):
       """       """
   
       req = (self.handle,)
       val = self.mgr.getService().INATNetwork_start(*req)
       
       return 

   def stop(self):
       """       """
   
       req = (self.handle,)
       val = self.mgr.getService().INATNetwork_stop(*req)
       
       return 

   def getNetworkName(self):
       """
        TBD: the idea, technically we can start any number of the NAT networks,
        but we should expect that at some point we will get collisions because of
        port-forwanding rules. so perhaps we should support only single instance of NAT
        network.
       """
       val = self.mgr.getService().INATNetwork_getNetworkName(self.handle)
       return String(self.mgr, val)

   def setNetworkName(self, value):
       """
        TBD: the idea, technically we can start any number of the NAT networks,
        but we should expect that at some point we will get collisions because of
        port-forwanding rules. so perhaps we should support only single instance of NAT
        network.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATNetwork_setNetworkName(_this, _val)

   def getEnabled(self):
       """ """
       val = self.mgr.getService().INATNetwork_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEnabled(self, value):
       """ """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATNetwork_setEnabled(_this, _val)

   def getNetwork(self):
       """
        This is CIDR IPv4 string. Specifying it user defines IPv4 addresses
        of gateway (low address + 1) and DHCP server (= low address + 2).
        Note: If there are defined IPv4 port-forward rules update of network
        will be ignored (because new assignment could break existing rules).
       """
       val = self.mgr.getService().INATNetwork_getNetwork(self.handle)
       return String(self.mgr, val)

   def setNetwork(self, value):
       """
        This is CIDR IPv4 string. Specifying it user defines IPv4 addresses
        of gateway (low address + 1) and DHCP server (= low address + 2).
        Note: If there are defined IPv4 port-forward rules update of network
        will be ignored (because new assignment could break existing rules).
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATNetwork_setNetwork(_this, _val)

   def getGateway(self):
       """
        This attribute is read-only. It's recalculated on changing
        network attribute (low address of network + 1).
       """
       val = self.mgr.getService().INATNetwork_getGateway(self.handle)
       return String(self.mgr, val)

   def getIPv6Enabled(self):
       """
        This attribute define whether gateway will support IPv6 or not.
       """
       val = self.mgr.getService().INATNetwork_getIPv6Enabled(self.handle)
       return Boolean(self.mgr, val)

   def setIPv6Enabled(self, value):
       """
        This attribute define whether gateway will support IPv6 or not.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATNetwork_setIPv6Enabled(_this, _val)

   def getIPv6Prefix(self):
       """
        This a CIDR IPv6 defining prefix for link-local addresses
        autoconfiguration within network. Note: ignored if attribute
        IPv6Enabled is false.
       """
       val = self.mgr.getService().INATNetwork_getIPv6Prefix(self.handle)
       return String(self.mgr, val)

   def setIPv6Prefix(self, value):
       """
        This a CIDR IPv6 defining prefix for link-local addresses
        autoconfiguration within network. Note: ignored if attribute
        IPv6Enabled is false.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATNetwork_setIPv6Prefix(_this, _val)

   def getAdvertiseDefaultIPv6RouteEnabled(self):
       """ """
       val = self.mgr.getService().INATNetwork_getAdvertiseDefaultIPv6RouteEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setAdvertiseDefaultIPv6RouteEnabled(self, value):
       """ """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATNetwork_setAdvertiseDefaultIPv6RouteEnabled(_this, _val)

   def getNeedDhcpServer(self):
       """ """
       val = self.mgr.getService().INATNetwork_getNeedDhcpServer(self.handle)
       return Boolean(self.mgr, val)

   def setNeedDhcpServer(self, value):
       """ """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATNetwork_setNeedDhcpServer(_this, _val)

   def getEventSource(self):
       """ """
       val = self.mgr.getService().INATNetwork_getEventSource(self.handle)
       return IEventSource(self.mgr, val)

   def getPortForwardRules4(self):
       """Array of NAT port-forwarding rules in string representation,
      in the following format:
      "name:protocolid:[host ip]:host port:[guest ip]:guest port".
       """
       val = self.mgr.getService().INATNetwork_getPortForwardRules4(self.handle)
       return String(self.mgr, val, True)

   def getLocalMappings(self):
       """Array of mappings (address,offset),e.g. ("127.0.1.1=4") maps 127.0.1.1 to networkid + 4.
       """
       val = self.mgr.getService().INATNetwork_getLocalMappings(self.handle)
       return String(self.mgr, val, True)

   def getLoopbackIp6(self):
       """Offset in ipv6 network from network id for address mapped into loopback6 interface of the host.
       """
       val = self.mgr.getService().INATNetwork_getLoopbackIp6(self.handle)
       return Int(self.mgr, val)

   def setLoopbackIp6(self, value):
       """Offset in ipv6 network from network id for address mapped into loopback6 interface of the host.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATNetwork_setLoopbackIp6(_this, _val)

   def getPortForwardRules6(self):
       """Array of NAT port-forwarding rules in string representation, in the
      following format: "name:protocolid:[host ip]:host port:[guest ip]:guest port".
       """
       val = self.mgr.getService().INATNetwork_getPortForwardRules6(self.handle)
       return String(self.mgr, val, True)



   _Attrs_ = {'networkName':[getNetworkName,setNetworkName,],
              'enabled':[getEnabled,setEnabled,],
              'network':[getNetwork,setNetwork,],
              'gateway':[getGateway,None],
              'IPv6Enabled':[getIPv6Enabled,setIPv6Enabled,],
              'IPv6Prefix':[getIPv6Prefix,setIPv6Prefix,],
              'advertiseDefaultIPv6RouteEnabled':[getAdvertiseDefaultIPv6RouteEnabled,setAdvertiseDefaultIPv6RouteEnabled,],
              'needDhcpServer':[getNeedDhcpServer,setNeedDhcpServer,],
              'eventSource':[getEventSource,None],
              'portForwardRules4':[getPortForwardRules4,None],
              'localMappings':[getLocalMappings,None],
              'loopbackIp6':[getLoopbackIp6,setLoopbackIp6,],
              'portForwardRules6':[getPortForwardRules6,None]}

class ICloudNetwork(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICloudNetwork(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICloudNetwork._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICloudNetwork._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getNetworkName(self):
       """
        TBD: User-friendly, descriptive name of cloud subnet. For example, domain
        names of subnet and vcn, separated by dot.
       """
       val = self.mgr.getService().ICloudNetwork_getNetworkName(self.handle)
       return String(self.mgr, val)

   def setNetworkName(self, value):
       """
        TBD: User-friendly, descriptive name of cloud subnet. For example, domain
        names of subnet and vcn, separated by dot.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ICloudNetwork_setNetworkName(_this, _val)

   def getEnabled(self):
       """ """
       val = self.mgr.getService().ICloudNetwork_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEnabled(self, value):
       """ """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ICloudNetwork_setEnabled(_this, _val)

   def getProvider(self):
       """
        Cloud provider short name.
       """
       val = self.mgr.getService().ICloudNetwork_getProvider(self.handle)
       return String(self.mgr, val)

   def setProvider(self, value):
       """
        Cloud provider short name.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ICloudNetwork_setProvider(_this, _val)

   def getProfile(self):
       """
        Cloud profile name.
       """
       val = self.mgr.getService().ICloudNetwork_getProfile(self.handle)
       return String(self.mgr, val)

   def setProfile(self, value):
       """
        Cloud profile name.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ICloudNetwork_setProfile(_this, _val)

   def getNetworkId(self):
       """
        Cloud network id.
       """
       val = self.mgr.getService().ICloudNetwork_getNetworkId(self.handle)
       return String(self.mgr, val)

   def setNetworkId(self, value):
       """
        Cloud network id.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ICloudNetwork_setNetworkId(_this, _val)



   _Attrs_ = {'networkName':[getNetworkName,setNetworkName,],
              'enabled':[getEnabled,setEnabled,],
              'provider':[getProvider,setProvider,],
              'profile':[getProfile,setProfile,],
              'networkId':[getNetworkId,setNetworkId,]}

class IDHCPServer(IUnknown):
   """
      The IDHCPServer interface represents the VirtualBox DHCP server configuration.

      To enumerate all the DHCP servers on the host, use the
      IVirtualBox::DHCPServers attribute.
    
      Interface ID:
        {CADEF0A2-A1A9-4AC2-8E80-C049AF69DAC8}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDHCPServer(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDHCPServer._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDHCPServer._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def setConfiguration(self, _arg_IPAddress, _arg_networkMask, _arg_FromIPAddress, _arg_ToIPAddress):
       """
        configures the server
        
        :param _arg_IPAddress: server IP address
        :param _arg_networkMask: server network mask
        :param _arg_FromIPAddress: server From IP address for address range
        :param _arg_ToIPAddress: server To IP address for address range

        Expected result codes:
        E_INVALIDARG
          invalid configuration supplied
        
       """
   
       req = (self.handle,)
       req += (_arg_IPAddress,)
       req += (_arg_networkMask,)
       req += (_arg_FromIPAddress,)
       req += (_arg_ToIPAddress,)
       val = self.mgr.getService().IDHCPServer_setConfiguration(*req)
       
       return 

   def start(self, _arg_trunkName, _arg_trunkType):
       """
        Starts DHCP server process.
        
        :param _arg_trunkName: Name of internal network trunk.
        :param _arg_trunkType: Type of internal network trunk.

        Expected result codes:
        E_FAIL
          Failed to start the process.
        
       """
   
       req = (self.handle,)
       req += (_arg_trunkName,)
       req += (_arg_trunkType,)
       val = self.mgr.getService().IDHCPServer_start(*req)
       
       return 

   def stop(self):
       """
        Stops DHCP server process.
        

        Expected result codes:
        E_FAIL
          Failed to stop the process.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDHCPServer_stop(*req)
       
       return 

   def restart(self):
       """
        Restart running DHCP server process.
        

        Expected result codes:
        E_FAIL
          Failed to restart the process.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDHCPServer_restart(*req)
       
       return 

   def findLeaseByMAC(self, _arg_mac, _arg_type):
       """
        Queries the persistent lease database by MAC address.

        This is handy if the host wants to connect to a server running inside
        a VM on a host only network.

        
        :param _arg_mac: The MAC address to look up.
        :param _arg_type: Reserved, MBZ.





        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUNDIf MAC address not in the database.VBOX_E_FILE_ERRORIf not able to read the lease database file.
       """
   
       req = (self.handle,)
       req += (_arg_mac,)
       req += (_arg_type,)
       val = self.mgr.getService().IDHCPServer_findLeaseByMAC(*req)
       
       return String(self.mgr,val["address"]), String(self.mgr,val["state"]), Long(self.mgr,val["issued"]), Long(self.mgr,val["expire"])

   def getConfig(self, _arg_scope, _arg_name, _arg_slot, _arg_mayAdd):
       """
        Gets or adds a configuration.
      
        :param _arg_scope: The kind of configuration being sought or added.
        :param _arg_name: Meaning depends on the @a scope: - Ignored when the @a scope is . - A VM name or UUID for . - A MAC address for . - A group name for .
        :param _arg_slot: The NIC slot when @a scope is set to , must be zero for all other scope values.
        :param _arg_mayAdd: Set to @c TRUE if the configuration should be added if not found. If set to @c FALSE the method will fail with VBOX_E_OBJECT_NOT_FOUND.
        :return: The requested configuration.
        :rtype: IDHCPConfig

       """
   
       req = (self.handle,)
       req += (_arg_scope,)
       req += (_arg_name,)
       req += (_arg_slot,)
       req += (_arg_mayAdd,)
       val = self.mgr.getService().IDHCPServer_getConfig(*req)
       
       return IDHCPConfig(self.mgr, val)

   def getEventSource(self):
       """ """
       val = self.mgr.getService().IDHCPServer_getEventSource(self.handle)
       return IEventSource(self.mgr, val)

   def getEnabled(self):
       """
        specifies if the DHCP server is enabled
       """
       val = self.mgr.getService().IDHCPServer_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEnabled(self, value):
       """
        specifies if the DHCP server is enabled
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPServer_setEnabled(_this, _val)

   def getIPAddress(self):
       """
        specifies server IP
       """
       val = self.mgr.getService().IDHCPServer_getIPAddress(self.handle)
       return String(self.mgr, val)

   def getNetworkMask(self):
       """
        specifies server network mask
       """
       val = self.mgr.getService().IDHCPServer_getNetworkMask(self.handle)
       return String(self.mgr, val)

   def getNetworkName(self):
       """
        specifies internal network name the server is used for
       """
       val = self.mgr.getService().IDHCPServer_getNetworkName(self.handle)
       return String(self.mgr, val)

   def getLowerIP(self):
       """
        specifies from IP address in server address range
       """
       val = self.mgr.getService().IDHCPServer_getLowerIP(self.handle)
       return String(self.mgr, val)

   def getUpperIP(self):
       """
        specifies to IP address in server address range
       """
       val = self.mgr.getService().IDHCPServer_getUpperIP(self.handle)
       return String(self.mgr, val)

   def getGlobalConfig(self):
       """Global configuration that applies to all clients. """
       val = self.mgr.getService().IDHCPServer_getGlobalConfig(self.handle)
       return IDHCPGlobalConfig(self.mgr, val)

   def getGroupConfigs(self):
       """Configuration groups that applies to selected clients, selection is flexible. """
       val = self.mgr.getService().IDHCPServer_getGroupConfigs(self.handle)
       return IDHCPGroupConfig(self.mgr, val, True)

   def getIndividualConfigs(self):
       """Individual NIC configurations either by MAC address or VM + NIC number. """
       val = self.mgr.getService().IDHCPServer_getIndividualConfigs(self.handle)
       return IDHCPIndividualConfig(self.mgr, val, True)



   _Attrs_ = {'eventSource':[getEventSource,None],
              'enabled':[getEnabled,setEnabled,],
              'IPAddress':[getIPAddress,None],
              'networkMask':[getNetworkMask,None],
              'networkName':[getNetworkName,None],
              'lowerIP':[getLowerIP,None],
              'upperIP':[getUpperIP,None],
              'globalConfig':[getGlobalConfig,None],
              'groupConfigs':[getGroupConfigs,None],
              'individualConfigs':[getIndividualConfigs,None]}

class IDHCPConfig(IUnknown):
   """
      The DHCP server has several configuration levels: global, group and
      individual MAC.  This interface implements the settings common to
      each level.
    
      Interface ID:
        {00F4A8DC-0002-4B81-0077-1DCB004571BA}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDHCPConfig(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDHCPConfig._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDHCPConfig._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def setOption(self, _arg_option, _arg_encoding, _arg_value):
       """
        Sets a DHCP option.
      
        :param _arg_option: The DHCP option.
        :param _arg_encoding: The value encoding.
        :param _arg_value: The DHCP option value. The exact format depends on the DHCP @a option value and @a encoding, see see for the format.

       """
   
       req = (self.handle,)
       req += (_arg_option,)
       req += (_arg_encoding,)
       req += (_arg_value,)
       val = self.mgr.getService().IDHCPConfig_setOption(*req)
       
       return 

   def removeOption(self, _arg_option):
       """Removes the given DHCP option.
        :param _arg_option: 

       """
   
       req = (self.handle,)
       req += (_arg_option,)
       val = self.mgr.getService().IDHCPConfig_removeOption(*req)
       
       return 

   def removeAllOptions(self):
       """
        Removes all the options.

        One exception here is the DhcpOpt_SubnetMask option in the global scope
        that is linked to the IDHCPServer::networkMask attribute
        and therefore cannot be removed.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDHCPConfig_removeAllOptions(*req)
       
       return 

   def getOption(self, _arg_option):
       """Gets the value of a single DHCP option.
        :param _arg_option: The DHCP option being sought.

        :return: The value of the requested DHCP option. The exact format depends on the DHCP @a option value and the @a encoding, see for the format.
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_option,)
       val = self.mgr.getService().IDHCPConfig_getOption(*req)
       
       return String(self.mgr,val["returnval"]), DHCPOptionEncoding(self.mgr,val["encoding"])

   def getAllOptions(self):
       """Gets all DHCP options and their values


        :return: Array of values that runs parallel to @a options and @a encodings. The format depends on both of those.
        :rtype: List[wstring]

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDHCPConfig_getAllOptions(*req)
       
       return String(self.mgr,val["returnval"], True), DHCPOption(self.mgr,val["options"], True), DHCPOptionEncoding(self.mgr,val["encodings"], True)

   def remove(self):
       """
        Remove this group or individual configuration.
        Will of course not work on global configurations.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDHCPConfig_remove(*req)
       
       return 

   def getScope(self):
       """
        Indicates the kind of config this is (mostly for IDHCPIndividualConfig).
       """
       val = self.mgr.getService().IDHCPConfig_getScope(self.handle)
       return DHCPConfigScope(self.mgr, val)

   def getMinLeaseTime(self):
       """The minimum lease time in seconds, ignored if zero. """
       val = self.mgr.getService().IDHCPConfig_getMinLeaseTime(self.handle)
       return UnsignedInt(self.mgr, val)

   def setMinLeaseTime(self, value):
       """The minimum lease time in seconds, ignored if zero. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPConfig_setMinLeaseTime(_this, _val)

   def getDefaultLeaseTime(self):
       """The default lease time in seconds, ignored if zero. """
       val = self.mgr.getService().IDHCPConfig_getDefaultLeaseTime(self.handle)
       return UnsignedInt(self.mgr, val)

   def setDefaultLeaseTime(self, value):
       """The default lease time in seconds, ignored if zero. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPConfig_setDefaultLeaseTime(_this, _val)

   def getMaxLeaseTime(self):
       """The maximum lease time in seconds, ignored if zero. """
       val = self.mgr.getService().IDHCPConfig_getMaxLeaseTime(self.handle)
       return UnsignedInt(self.mgr, val)

   def setMaxLeaseTime(self, value):
       """The maximum lease time in seconds, ignored if zero. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPConfig_setMaxLeaseTime(_this, _val)

   def getForcedOptions(self):
       """List of DHCP options which should be forced upon the clients in this
       config scope when they are available, whether the clients asks for them
       or not. """
       val = self.mgr.getService().IDHCPConfig_getForcedOptions(self.handle)
       return DHCPOption(self.mgr, val, True)

   def setForcedOptions(self, value):
       """List of DHCP options which should be forced upon the clients in this
       config scope when they are available, whether the clients asks for them
       or not. """
       _this=self.handle
       if type(value) in [int, bool, str, tuple, list]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPConfig_setForcedOptions(_this, _val)

   def getSuppressedOptions(self):
       """List of DHCP options which should not be sent to the clients in
        this config scope.  This is intended for cases where one client or a
        group of clients shouldn't see one or more (typically global) options. """
       val = self.mgr.getService().IDHCPConfig_getSuppressedOptions(self.handle)
       return DHCPOption(self.mgr, val, True)

   def setSuppressedOptions(self, value):
       """List of DHCP options which should not be sent to the clients in
        this config scope.  This is intended for cases where one client or a
        group of clients shouldn't see one or more (typically global) options. """
       _this=self.handle
       if type(value) in [int, bool, str, tuple, list]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPConfig_setSuppressedOptions(_this, _val)



   _Attrs_ = {'scope':[getScope,None],
              'minLeaseTime':[getMinLeaseTime,setMinLeaseTime,],
              'defaultLeaseTime':[getDefaultLeaseTime,setDefaultLeaseTime,],
              'maxLeaseTime':[getMaxLeaseTime,setMaxLeaseTime,],
              'forcedOptions':[getForcedOptions,setForcedOptions,],
              'suppressedOptions':[getSuppressedOptions,setSuppressedOptions,]}

class IDHCPGlobalConfig(IDHCPConfig):
   """
      The global DHCP server configuration, see IDHCPServer::globalConfig.
    
      Interface ID:
        {46735DE7-F4C4-4020-A185-0D2881BCFA8B}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDHCPGlobalConfig(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDHCPGlobalConfig._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IDHCPConfig.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDHCPGlobalConfig._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   


   _Attrs_ = {}

class IDHCPGroupCondition(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDHCPGroupCondition(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDHCPGroupCondition._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDHCPGroupCondition._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def remove(self):
       """Remove this condition from the group.

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDHCPGroupCondition_remove(*req)
       
       return 

   def getInclusive(self):
       """Whether this is an inclusive or exclusive group membership condition """
       val = self.mgr.getService().IDHCPGroupCondition_getInclusive(self.handle)
       return Boolean(self.mgr, val)

   def setInclusive(self, value):
       """Whether this is an inclusive or exclusive group membership condition """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPGroupCondition_setInclusive(_this, _val)

   def getType(self):
       """Defines how the IDHCPGroupCondition::value is interpreted. """
       val = self.mgr.getService().IDHCPGroupCondition_getType(self.handle)
       return DHCPGroupConditionType(self.mgr, val)

   def setType(self, value):
       """Defines how the IDHCPGroupCondition::value is interpreted. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPGroupCondition_setType(_this, _val)

   def getValue(self):
       """The condition value. """
       val = self.mgr.getService().IDHCPGroupCondition_getValue(self.handle)
       return String(self.mgr, val)

   def setValue(self, value):
       """The condition value. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPGroupCondition_setValue(_this, _val)



   _Attrs_ = {'inclusive':[getInclusive,setInclusive,],
              'type':[getType,setType,],
              'value':[getValue,setValue,]}

class IDHCPGroupConfig(IDHCPConfig):
   """
      A configuration that applies to a group of NICs.
    
      Interface ID:
        {537707F7-EBF9-4D5C-7AEA-877BFC4256BA}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDHCPGroupConfig(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDHCPGroupConfig._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IDHCPConfig.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDHCPGroupConfig._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def addCondition(self, _arg_inclusive, _arg_type, _arg_value):
       """Adds a new condition.
        :param _arg_inclusive: 
        :param _arg_type: 
        :param _arg_value: 
        :return: 
        :rtype: IDHCPGroupCondition

       """
   
       req = (self.handle,)
       req += (_arg_inclusive,)
       req += (_arg_type,)
       req += (_arg_value,)
       val = self.mgr.getService().IDHCPGroupConfig_addCondition(*req)
       
       return IDHCPGroupCondition(self.mgr, val)

   def removeAllConditions(self):
       """Removes all conditions.

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDHCPGroupConfig_removeAllConditions(*req)
       
       return 

   def getName(self):
       """The group name. """
       val = self.mgr.getService().IDHCPGroupConfig_getName(self.handle)
       return String(self.mgr, val)

   def setName(self, value):
       """The group name. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPGroupConfig_setName(_this, _val)

   def getConditions(self):
       """
        Group membership conditions.

        Add new conditions by calling IDHCPGroupConfig::addCondition
        and use IDHCPGroupCondition::remove to remove.
       """
       val = self.mgr.getService().IDHCPGroupConfig_getConditions(self.handle)
       return IDHCPGroupCondition(self.mgr, val, True)



   _Attrs_ = {'name':[getName,setName,],
              'conditions':[getConditions,None]}

class IDHCPIndividualConfig(IDHCPConfig):
   """
      Configuration for a single NIC, either given directly by MAC address or by
      VM + adaptor slot number.
    
      Interface ID:
        {C40C2B86-73A5-46CC-8227-93FE57D006A6}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDHCPIndividualConfig(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDHCPIndividualConfig._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IDHCPConfig.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDHCPIndividualConfig._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMACAddress(self):
       """
        The MAC address.  If a ::DHCPConfigScope_MachineNIC config, this
        will be queried via the VM ID.
       """
       val = self.mgr.getService().IDHCPIndividualConfig_getMACAddress(self.handle)
       return String(self.mgr, val)

   def getMachineId(self):
       """
        The virtual machine ID if a ::DHCPConfigScope_MachineNIC config,
        null UUID for ::DHCPConfigScope_MAC.
       """
       val = self.mgr.getService().IDHCPIndividualConfig_getMachineId(self.handle)
       return String(self.mgr, val)

   def getSlot(self):
       """The NIC slot number of the VM if a ::DHCPConfigScope_MachineNIC config. """
       val = self.mgr.getService().IDHCPIndividualConfig_getSlot(self.handle)
       return UnsignedInt(self.mgr, val)

   def getFixedAddress(self):
       """Fixed IPv4 address assignment, dynamic if empty. """
       val = self.mgr.getService().IDHCPIndividualConfig_getFixedAddress(self.handle)
       return String(self.mgr, val)

   def setFixedAddress(self, value):
       """Fixed IPv4 address assignment, dynamic if empty. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IDHCPIndividualConfig_setFixedAddress(_this, _val)



   _Attrs_ = {'MACAddress':[getMACAddress,None],
              'machineId':[getMachineId,None],
              'slot':[getSlot,None],
              'fixedAddress':[getFixedAddress,setFixedAddress,]}

class IVirtualBox(IUnknown):
   """
      The IVirtualBox interface represents the main interface exposed by the
      product that provides virtual machine management.

      An instance of IVirtualBox is required for the product to do anything
      useful. Even though the interface does not expose this, internally,
      IVirtualBox is implemented as a singleton and actually lives in the
      process of the VirtualBox server (VBoxSVC.exe). This makes sure that
      IVirtualBox can track the state of all virtual machines on a particular
      host, regardless of which frontend started them.

      To enumerate all the virtual machines on the host, use the
      IVirtualBox::machines attribute.

      Error information handling is a bit special with IVirtualBox: creating
      an instance will always succeed. The return of the actual error
      code/information is postponed to any attribute or method call. The
      reason for this is that COM likes to mutilate the error code and lose
      the detailed error information returned by instance creation.
    
      Interface ID:
        {D0A0163F-E254-4E5B-A1F2-011CF991C38D}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IVirtualBox(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVirtualBox._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVirtualBox._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def composeMachineFilename(self, _arg_name, _arg_group, _arg_createFlags, _arg_baseFolder):
       """
        Returns a recommended full path of the settings file name for a new virtual
        machine.

        This API serves two purposes:

          * It gets called by #createMachine if @c null or
            empty string (which is recommended) is specified for the
            @a settingsFile argument there, which means that API should use
            a recommended default file name.
          * It can be called manually by a client software before creating a machine,
            e.g. if that client wants to pre-create the machine directory to create
            virtual hard disks in that directory together with the new machine
            settings file. In that case, the file name should be stripped from the
            full settings file path returned by this function to obtain the
            machine directory.

        See IMachine::name and #createMachine for more
        details about the machine name.

        @a groupName defines which additional subdirectory levels should be
        included. It must be either a valid group name or @c null or empty
        string which designates that the machine will not be related to a
        machine group.

        If @a baseFolder is a @c null or empty string (which is recommended), the
        default machine settings folder
        (see ISystemProperties::defaultMachineFolder) will be used as
        a base folder for the created machine, resulting in a file name like
        "/home/user/VirtualBox VMs/name/name.vbox". Otherwise the given base folder
        will be used.

        This method does not access the host disks. In particular, it does not check
        for whether a machine with this name already exists.
      
        :param _arg_name: Suggested machine name.
        :param _arg_group: Machine group name for the new machine or machine group. It is used to determine the right subdirectory.
        :param _arg_createFlags: Machine creation flags, see (optional).
        :param _arg_baseFolder: Base machine folder (optional).
        :return: Fully qualified path where the machine would be created.
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_group,)
       req += (_arg_createFlags,)
       req += (_arg_baseFolder,)
       val = self.mgr.getService().IVirtualBox_composeMachineFilename(*req)
       
       return String(self.mgr, val)

   def createMachine(self, _arg_settingsFile, _arg_name, _arg_groups, _arg_osTypeId, _arg_flags):
       """
        Creates a new virtual machine by creating a machine settings file at
        the given location.

        VirtualBox machine settings files use a custom XML dialect. Starting
        with VirtualBox 4.0, a ".vbox" extension is recommended, but not enforced,
        and machine files can be created at arbitrary locations.

        However, it is recommended that machines are created in the default
        machine folder (e.g. "/home/user/VirtualBox VMs/name/name.vbox"; see
        ISystemProperties::defaultMachineFolder). If you specify
        @c null or empty string (which is recommended) for the @a settingsFile
        argument, #composeMachineFilename is called automatically
        to have such a recommended name composed based on the machine name
        given in the @a name argument and the primary group.

        If the resulting settings file already exists, this method will fail,
        unless the forceOverwrite flag is set.

        The new machine is created unregistered, with the initial configuration
        set according to the specified guest OS type. A typical sequence of
        actions to create a new virtual machine is as follows:

          * 
            Call this method to have a new machine created. The returned machine
            object will be "mutable" allowing to change any machine property.
          
          * 
            Configure the machine using the appropriate attributes and methods.
          
          * 
            Call IMachine::saveSettings to write the settings
            to the machine's XML settings file. The configuration of the newly
            created machine will not be saved to disk until this method is
            called.
          
          * 
            Call #registerMachine to add the machine to the list
            of machines known to VirtualBox.
          

        

        The specified guest OS type identifier must match an ID of one of known
        guest OS types listed in the IVirtualBox::guestOSTypes
        array.

        
        :param _arg_settingsFile: Fully qualified path where the settings file should be created, empty string or @c null for a default folder and file based on the @a name argument and the primary group. (see ).
        :param _arg_name: Machine name.
        :param _arg_groups: Array of group names. @c null or an empty array have the same meaning as an array with just the empty string or "/", i.e. create a machine without group association.
        :param _arg_osTypeId: Guest OS Type ID.
        :param _arg_flags: Additional property parameters, passed as a comma-separated list of "name=value" type entries. The following ones are recognized: forceOverwrite=1 to overwrite an existing machine settings file, UUID=<uuid> to specify a machine UUID and directoryIncludesUUID=1 to switch to a special VM directory naming scheme which should not be used unless necessary.
        :return: Created machine object.
        :rtype: IMachine

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          @a osTypeId is invalid.
        VBOX_E_FILE_ERROR
          Resulting settings file name is invalid or the settings file already
          exists or could not be created due to an I/O error.
        E_INVALIDARG
          @a name is empty or @c null.
        
        .. note:: IMachine::settingsModified will return
          @c false for the created machine, until any of machine settings
          are changed.
        
        .. note:: 
          There is no way to change the name of the settings file or
          subfolder of the created machine directly.
        
       """
   
       req = (self.handle,)
       req += (_arg_settingsFile,)
       req += (_arg_name,)
       req += (_arg_groups,)
       req += (_arg_osTypeId,)
       req += (_arg_flags,)
       val = self.mgr.getService().IVirtualBox_createMachine(*req)
       
       return IMachine(self.mgr, val)

   def openMachine(self, _arg_settingsFile):
       """
        Opens a virtual machine from the existing settings file.
        The opened machine remains unregistered until you call
        #registerMachine.

        The specified settings file name must be fully qualified.
        The file must exist and be a valid machine XML settings file
        whose contents will be used to construct the machine object.

        
        :param _arg_settingsFile: Name of the machine settings file.
        :return: Opened machine object.
        :rtype: IMachine

        Expected result codes:
        VBOX_E_FILE_ERROR
          Settings file name invalid, not found or sharing violation.
        
        .. note:: IMachine::settingsModified will return
          @c false for the opened machine, until any of machine settings
          are changed.
        
       """
   
       req = (self.handle,)
       req += (_arg_settingsFile,)
       val = self.mgr.getService().IVirtualBox_openMachine(*req)
       
       return IMachine(self.mgr, val)

   def registerMachine(self, _arg_machine):
       """

        Registers the machine previously created using
        #createMachine or opened using
        #openMachine within this VirtualBox installation. After
        successful method invocation, the
        ::IMachineRegisteredEvent event is fired.

        
        :param _arg_machine: 

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          No matching virtual machine found.
        VBOX_E_INVALID_OBJECT_STATE
          Virtual machine was not created within this VirtualBox instance.
        
        .. note:: 
          This method implicitly calls IMachine::saveSettings
          to save all current machine settings before registering it.
        
       """
   
       req = (self.handle,)
       req += (_arg_machine,)
       val = self.mgr.getService().IVirtualBox_registerMachine(*req)
       
       return 

   def findMachine(self, _arg_nameOrId):
       """
        Attempts to find a virtual machine given its name or UUID.

        
        :param _arg_nameOrId: What to search for. This can either be the UUID or the name of a virtual machine.
        :return: Machine object, if found.
        :rtype: IMachine

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Could not find registered machine matching @a nameOrId.
        
        .. note:: Inaccessible machines cannot be found by name, only by UUID, because their name
          cannot safely be determined.
       """
   
       req = (self.handle,)
       req += (_arg_nameOrId,)
       val = self.mgr.getService().IVirtualBox_findMachine(*req)
       
       return IMachine(self.mgr, val)

   def getMachinesByGroups(self, _arg_groups):
       """
        Gets all machine references which are in one of the specified groups.
      
        :param _arg_groups: What groups to match. The usual group list rules apply, i.e. passing an empty list will match VMs in the toplevel group, likewise the empty string.
        :return: All machines which matched.
        :rtype: List[IMachine]

       """
   
       req = (self.handle,)
       req += (_arg_groups,)
       val = self.mgr.getService().IVirtualBox_getMachinesByGroups(*req)
       
       return IMachine(self.mgr, val, True)

   def getMachineStates(self, _arg_machines):
       """
        Gets the state of several machines in a single operation.
      
        :param _arg_machines: Array with the machine references.
        :return: Machine states, corresponding to the machines.
        :rtype: List[MachineState]

       """
   
       req = (self.handle,)
       req += (_arg_machines,)
       val = self.mgr.getService().IVirtualBox_getMachineStates(*req)
       
       return MachineState(self.mgr, val, True)

   def createAppliance(self):
       """
        Creates a new appliance object, which represents an appliance in the Open Virtual Machine
        Format (OVF). This can then be used to import an OVF appliance into VirtualBox or to export
        machines as an OVF appliance; see the documentation for ::IAppliance for details.
      
        :return: New appliance.
        :rtype: IAppliance

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVirtualBox_createAppliance(*req)
       
       return IAppliance(self.mgr, val)

   def createUnattendedInstaller(self):
       """
        Creates a new ::IUnattended guest installation object.  This can be used to
        analyze an installation ISO to create and configure a new machine for it to be installed
        on.  It can also be used to (re)install an existing machine.
      
        :return: New unattended object.
        :rtype: IUnattended

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVirtualBox_createUnattendedInstaller(*req)
       
       return IUnattended(self.mgr, val)

   def createMedium(self, _arg_format, _arg_location, _arg_accessMode, _arg_aDeviceTypeType):
       """
        Creates a new base medium object that will use the given storage
        format and location for medium data.

        The actual storage unit is not created by this method. In order to
        do it, and before you are able to attach the created medium to
        virtual machines, you must call one of the following methods to
        allocate a format-specific storage unit at the specified location:
          * IMedium::createBaseStorage
          * IMedium::createDiffStorage

        Some medium attributes, such as IMedium::id, may
        remain uninitialized until the medium storage unit is successfully
        created by one of the above methods.

        Depending on the given device type, the file at the storage location
        must be in one of the media formats understood by VirtualBox:

          * With a "HardDisk" device type, the file must be a hard disk image
            in one of the formats supported by VirtualBox (see
            ISystemProperties::mediumFormats).
            After the storage unit is successfully created and this method succeeds,
            if the medium is a base medium, it
            will be added to the #hardDisks array attribute. 
          * With a "DVD" device type, the file must be an ISO 9960 CD/DVD image.
            After this method succeeds, the medium will be added to the
            #DVDImages array attribute.
          * With a "Floppy" device type, the file must be an RAW floppy image.
            After this method succeeds, the medium will be added to the
            #floppyImages array attribute.

        The list of all storage formats supported by this VirtualBox
        installation can be obtained using
        ISystemProperties::mediumFormats. If the @a format
        attribute is empty or @c null then the default storage format
        specified by ISystemProperties::defaultHardDiskFormat will
        be used for disks r creating a storage unit of the medium.

        Note that the format of the location string is storage format specific.
        See IMedium::location and IMedium for more details.

        
        :param _arg_format: Identifier of the storage format to use for the new medium.
        :param _arg_location: Location of the storage unit for the new medium.
        :param _arg_accessMode: Whether to open the image in read/write or read-only mode. For a "DVD" device type, this is ignored and read-only mode is always assumed.
        :param _arg_aDeviceTypeType: Must be one of "HardDisk", "DVD" or "Floppy".
        :return: Created medium object.
        :rtype: IMedium

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          @a format identifier is invalid. See
          ISystemProperties::mediumFormats.
        VBOX_E_FILE_ERROR
          @a location is a not valid file name (for file-based formats only).
        
       """
   
       req = (self.handle,)
       req += (_arg_format,)
       req += (_arg_location,)
       req += (_arg_accessMode,)
       req += (_arg_aDeviceTypeType,)
       val = self.mgr.getService().IVirtualBox_createMedium(*req)
       
       return IMedium(self.mgr, val)

   def openMedium(self, _arg_location, _arg_deviceType, _arg_accessMode, _arg_forceNewUuid):
       """
        Finds existing media or opens a medium from an existing storage location.

        Once a medium has been opened, it can be passed to other VirtualBox
        methods, in particular to IMachine::attachDevice.

        Depending on the given device type, the file at the storage location
        must be in one of the media formats understood by VirtualBox:

          * With a "HardDisk" device type, the file must be a hard disk image
            in one of the formats supported by VirtualBox (see
            ISystemProperties::mediumFormats).
            After this method succeeds, if the medium is a base medium, it
            will be added to the #hardDisks array attribute. 
          * With a "DVD" device type, the file must be an ISO 9960 CD/DVD image.
            After this method succeeds, the medium will be added to the
            #DVDImages array attribute.
          * With a "Floppy" device type, the file must be an RAW floppy image.
            After this method succeeds, the medium will be added to the
            #floppyImages array attribute.

        After having been opened, the medium can be re-found by this method
        and can be attached to virtual machines. See ::IMedium for
        more details.

        The UUID of the newly opened medium will either be retrieved from the
        storage location, if the format supports it (e.g. for hard disk images),
        or a new UUID will be randomly generated (e.g. for ISO and RAW files).
        If for some reason you need to change the medium's UUID, use
        IMedium::setIds.

        If a differencing hard disk medium is to be opened by this method, the
        operation will succeed only if its parent medium and all ancestors,
        if any, are already known to this VirtualBox installation (for example,
        were opened by this method before).

        This method attempts to guess the storage format of the specified medium
        by reading medium data at the specified location.

        If @a accessMode is ReadWrite (which it should be for hard disks and floppies),
        the image is opened for read/write access and must have according permissions,
        as VirtualBox may actually write status information into the disk's metadata
        sections.

        Note that write access is required for all typical hard disk usage in VirtualBox,
        since VirtualBox may need to write metadata such as a UUID into the image.
        The only exception is opening a source image temporarily for copying and
        cloning (see IMedium::cloneTo when the image will be closed
        again soon.

        The format of the location string is storage format specific. See
        IMedium::location and IMedium for more details.

        
        :param _arg_location: Location of the storage unit that contains medium data in one of the supported storage formats.
        :param _arg_deviceType: Must be one of "HardDisk", "DVD" or "Floppy".
        :param _arg_accessMode: Whether to open the image in read/write or read-only mode. For a "DVD" device type, this is ignored and read-only mode is always assumed.
        :param _arg_forceNewUuid: Allows the caller to request a completely new medium UUID for the image which is to be opened. Useful if one intends to open an exact copy of a previously opened image, as this would normally fail due to the duplicate UUID.
        :return: Opened medium object.
        :rtype: IMedium

        Expected result codes:
        VBOX_E_FILE_ERROR
          Invalid medium storage file location or could not find the medium
          at the specified location.
        VBOX_E_IPRT_ERROR
          Could not get medium storage format.
        E_INVALIDARG
          Invalid medium storage format.
        VBOX_E_INVALID_OBJECT_STATE
          Medium has already been added to a media registry.
        
       """
   
       req = (self.handle,)
       req += (_arg_location,)
       req += (_arg_deviceType,)
       req += (_arg_accessMode,)
       req += (_arg_forceNewUuid,)
       val = self.mgr.getService().IVirtualBox_openMedium(*req)
       
       return IMedium(self.mgr, val)

   def getGuestOSType(self, _arg_id):
       """
        Returns an object describing the specified guest OS type.

        The requested guest OS type is specified using a string which is a
        mnemonic identifier of the guest operating system, such as
        "win31" or "ubuntu". The guest OS type ID of a
        particular virtual machine can be read or set using the
        IMachine::OSTypeId attribute.

        The IVirtualBox::guestOSTypes collection contains all
        available guest OS type objects. Each object has an
        IGuestOSType::id attribute which contains an identifier of
        the guest OS this object describes.

        While this function returns an error for unknown guest OS types, they
        can be still used without serious problems (if one accepts the fact
        that there is no default VM config information).

        
        :param _arg_id: Guest OS type ID string.
        :return: Guest OS type object.
        :rtype: IGuestOSType

        Expected result codes:
        E_INVALIDARG
          @a id is not a valid Guest OS type.
        
       """
   
       req = (self.handle,)
       req += (_arg_id,)
       val = self.mgr.getService().IVirtualBox_getGuestOSType(*req)
       
       return IGuestOSType(self.mgr, val)

   def createSharedFolder(self, _arg_name, _arg_hostPath, _arg_writable, _arg_automount, _arg_autoMountPoint):
       """
        Creates a new global shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        ::ISharedFolder to read more about logical names.
        
        :param _arg_name: Unique logical name of the shared folder.
        :param _arg_hostPath: Full path to the shared folder in the host file system.
        :param _arg_writable: Whether the share is writable or readonly
        :param _arg_automount: Whether the share gets automatically mounted by the guest or not.
        :param _arg_autoMountPoint: Where the guest should automatically mount the folder, if possible. For Windows and OS/2 guests this should be a drive letter, while other guests it should be a absolute directory.

        .. note:: 
          In the current implementation, this operation is not
          implemented.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_hostPath,)
       req += (_arg_writable,)
       req += (_arg_automount,)
       req += (_arg_autoMountPoint,)
       val = self.mgr.getService().IVirtualBox_createSharedFolder(*req)
       
       return 

   def removeSharedFolder(self, _arg_name):
       """
        Removes the global shared folder with the given name previously
        created by #createSharedFolder from the collection of
        shared folders and stops sharing it.
        
        :param _arg_name: Logical name of the shared folder to remove.

        .. note:: 
          In the current implementation, this operation is not
          implemented.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IVirtualBox_removeSharedFolder(*req)
       
       return 

   def getExtraDataKeys(self):
       """
        Returns an array representing the global extra data keys which currently
        have values defined.
      
        :return: Array of extra data keys.
        :rtype: List[wstring]

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVirtualBox_getExtraDataKeys(*req)
       
       return String(self.mgr, val, True)

   def getExtraData(self, _arg_key):
       """
        Returns associated global extra data.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

        
        :param _arg_key: Name of the data key to get.
        :return: Value of the requested data key.
        :rtype: wstring

        Expected result codes:
        VBOX_E_FILE_ERROR
          Settings file not accessible.
        VBOX_E_XML_ERROR
          Could not parse the settings file.
        
       """
   
       req = (self.handle,)
       req += (_arg_key,)
       val = self.mgr.getService().IVirtualBox_getExtraData(*req)
       
       return String(self.mgr, val)

   def setExtraData(self, _arg_key, _arg_value):
       """
        Sets associated global extra data.

        If you pass @c null or an empty string as a key @a value, the given
        @a key will be deleted.

        
        :param _arg_key: Name of the data key to set.
        :param _arg_value: Value to assign to the key.

        Expected result codes:
        VBOX_E_FILE_ERROR
          Settings file not accessible.
        VBOX_E_XML_ERROR
          Could not parse the settings file.
        E_ACCESSDENIED
          Modification request refused.
        E_INVALIDARG
          Key contains invalid characters.
        
        .. note:: 
          Key must contain printable (non-control) UTF-8 characters only.
        
        .. note:: 
          Before performing the actual data change, this method will ask all
          registered event listeners using the
          ::IExtraDataCanChangeEvent
          notification for a permission. If one of the listeners refuses the
          new value, the change will not be performed.
        
        .. note:: 
          On success, the
          ::IExtraDataChangedEvent notification
          is called to inform all registered listeners about a successful data
          change.
        
       """
   
       req = (self.handle,)
       req += (_arg_key,)
       req += (_arg_value,)
       val = self.mgr.getService().IVirtualBox_setExtraData(*req)
       
       return 

   def setSettingsSecret(self, _arg_password):
       """
        Unlocks the secret data by passing the unlock password to the
        server. The server will cache the password for that machine.

        
        :param _arg_password: The cipher key.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine is not mutable.
        
       """
   
       req = (self.handle,)
       req += (_arg_password,)
       val = self.mgr.getService().IVirtualBox_setSettingsSecret(*req)
       
       return 

   def createDHCPServer(self, _arg_name):
       """
        Creates a DHCP server settings to be used for the given internal network name
        
        :param _arg_name: server name
        :return: DHCP server settings
        :rtype: IDHCPServer

        Expected result codes:
        E_INVALIDARG
          Host network interface @a name already exists.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IVirtualBox_createDHCPServer(*req)
       
       return IDHCPServer(self.mgr, val)

   def findDHCPServerByNetworkName(self, _arg_name):
       """
        Searches a DHCP server settings to be used for the given internal network name
        
        :param _arg_name: server name
        :return: DHCP server settings
        :rtype: IDHCPServer

        Expected result codes:
        E_INVALIDARG
          Host network interface @a name already exists.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IVirtualBox_findDHCPServerByNetworkName(*req)
       
       return IDHCPServer(self.mgr, val)

   def removeDHCPServer(self, _arg_server):
       """
        Removes the DHCP server settings
        
        :param _arg_server: DHCP server settings to be removed

        Expected result codes:
        E_INVALIDARG
          Host network interface @a name already exists.
        
       """
   
       req = (self.handle,)
       req += (_arg_server,)
       val = self.mgr.getService().IVirtualBox_removeDHCPServer(*req)
       
       return 

   def createNATNetwork(self, _arg_networkName):
       """       """
   
       req = (self.handle,)
       req += (_arg_networkName,)
       val = self.mgr.getService().IVirtualBox_createNATNetwork(*req)
       
       return INATNetwork(self.mgr, val)

   def findNATNetworkByName(self, _arg_networkName):
       """       """
   
       req = (self.handle,)
       req += (_arg_networkName,)
       val = self.mgr.getService().IVirtualBox_findNATNetworkByName(*req)
       
       return INATNetwork(self.mgr, val)

   def removeNATNetwork(self, _arg_network):
       """       """
   
       req = (self.handle,)
       req += (_arg_network,)
       val = self.mgr.getService().IVirtualBox_removeNATNetwork(*req)
       
       return 

   def createCloudNetwork(self, _arg_networkName):
       """       """
   
       req = (self.handle,)
       req += (_arg_networkName,)
       val = self.mgr.getService().IVirtualBox_createCloudNetwork(*req)
       
       return ICloudNetwork(self.mgr, val)

   def findCloudNetworkByName(self, _arg_networkName):
       """       """
   
       req = (self.handle,)
       req += (_arg_networkName,)
       val = self.mgr.getService().IVirtualBox_findCloudNetworkByName(*req)
       
       return ICloudNetwork(self.mgr, val)

   def removeCloudNetwork(self, _arg_network):
       """       """
   
       req = (self.handle,)
       req += (_arg_network,)
       val = self.mgr.getService().IVirtualBox_removeCloudNetwork(*req)
       
       return 

   def checkFirmwarePresent(self, _arg_firmwareType, _arg_version):
       """
        Check if this VirtualBox installation has a firmware
        of the given type available, either system-wide or per-user.
        Optionally, this may return a hint where this firmware can be
        downloaded from.
      
        :param _arg_firmwareType: Type of firmware to check.
        :param _arg_version: Expected version number, usually empty string (presently ignored).


        :return: If firmware of this type and version is available.
        :rtype: boolean

       """
   
       req = (self.handle,)
       req += (_arg_firmwareType,)
       req += (_arg_version,)
       val = self.mgr.getService().IVirtualBox_checkFirmwarePresent(*req)
       
       return Boolean(self.mgr,val["returnval"]), String(self.mgr,val["url"]), String(self.mgr,val["file"])

   def getVersion(self):
       """
        A string representing the version number of the product. The
        format is 3 integer numbers divided by dots (e.g. 1.0.1). The
        last number represents the build number and will frequently change.

        This may be followed by a _ALPHA[0-9]*, _BETA[0-9]* or _RC[0-9]* tag
        in prerelease builds. Non-Oracle builds may (/shall) also have a
        publisher tag, at the end. The publisher tag starts with an underscore
        just like the prerelease build type tag.
       """
       val = self.mgr.getService().IVirtualBox_getVersion(self.handle)
       return String(self.mgr, val)

   def getVersionNormalized(self):
       """
        A string representing the version number of the product,
        without the publisher information (but still with other tags).
        See #version.
       """
       val = self.mgr.getService().IVirtualBox_getVersionNormalized(self.handle)
       return String(self.mgr, val)

   def getRevision(self):
       """
        The internal build revision number of the product.
       """
       val = self.mgr.getService().IVirtualBox_getRevision(self.handle)
       return UnsignedInt(self.mgr, val)

   def getPackageType(self):
       """
        A string representing the package type of this product. The
        format is OS_ARCH_DIST where OS is either WINDOWS, LINUX,
        SOLARIS, DARWIN. ARCH is either 32BITS or 64BITS. DIST
        is either GENERIC, UBUNTU_606, UBUNTU_710, or something like
        this.
       """
       val = self.mgr.getService().IVirtualBox_getPackageType(self.handle)
       return String(self.mgr, val)

   def getAPIVersion(self):
       """
        A string representing the VirtualBox API version number. The format is
        2 integer numbers divided by an underscore (e.g. 1_0). After the
        first public release of packages with a particular API version the
        API will not be changed in an incompatible way. Note that this
        guarantee does not apply to development builds, and also there is no
        guarantee that this version is identical to the first two integer
        numbers of the package version.
       """
       val = self.mgr.getService().IVirtualBox_getAPIVersion(self.handle)
       return String(self.mgr, val)

   def getAPIRevision(self):
       """
        This is mainly intended for the VBox Validation Kit so it can fluently
        deal with incompatible API changes and new functionality during
        development (i.e. on trunk).

        The high 7 bits (62:56) is the major version number, the next 8 bits
        (55:48) are the minor version number, the next 8 bits (47:40) are the
        build number, and the rest (39:0) is the API revision number.

        The API revision number is manually increased on trunk when making
        incompatible changes that the validation kit or others needs to be able
        to detect and cope with dynamically.  It can also be used to indicate
        the presence of new features on both trunk and branches.
       """
       val = self.mgr.getService().IVirtualBox_getAPIRevision(self.handle)
       return Long(self.mgr, val)

   def getHomeFolder(self):
       """
        Full path to the directory where the global settings file,
        VirtualBox.xml, is stored.

        In this version of VirtualBox, the value of this property is
        always <user_dir>/.VirtualBox (where
        <user_dir> is the path to the user directory,
        as determined by the host OS), and cannot be changed.

        This path is also used as the base to resolve relative paths in
        places where relative paths are allowed (unless otherwise
        expressly indicated).
       """
       val = self.mgr.getService().IVirtualBox_getHomeFolder(self.handle)
       return String(self.mgr, val)

   def getSettingsFilePath(self):
       """
        Full name of the global settings file.
        The value of this property corresponds to the value of
        #homeFolder plus /VirtualBox.xml.
       """
       val = self.mgr.getService().IVirtualBox_getSettingsFilePath(self.handle)
       return String(self.mgr, val)

   def getHost(self):
       """Associated host object. """
       val = self.mgr.getService().IVirtualBox_getHost(self.handle)
       return IHost(self.mgr, val)

   def getSystemProperties(self):
       """Associated system information object. """
       val = self.mgr.getService().IVirtualBox_getSystemProperties(self.handle)
       return ISystemProperties(self.mgr, val)

   def getMachines(self):
       """
        Array of machine objects registered within this VirtualBox instance.
       """
       val = self.mgr.getService().IVirtualBox_getMachines(self.handle)
       return IMachine(self.mgr, val, True)

   def getMachineGroups(self):
       """
        Array of all machine group names which are used by the machines which
        are accessible. Each group is only listed once, however they are listed
        in no particular order and there is no guarantee that there are no gaps
        in the group hierarchy (i.e. "/", "/group/subgroup"
        is a valid result).
       """
       val = self.mgr.getService().IVirtualBox_getMachineGroups(self.handle)
       return String(self.mgr, val, True)

   def getHardDisks(self):
       """
        Array of medium objects known to this VirtualBox installation.

        This array contains only base media. All differencing
        media of the given base medium can be enumerated using
        IMedium::children.
       """
       val = self.mgr.getService().IVirtualBox_getHardDisks(self.handle)
       return IMedium(self.mgr, val, True)

   def getDVDImages(self):
       """
        Array of CD/DVD image objects currently in use by this VirtualBox instance.
       """
       val = self.mgr.getService().IVirtualBox_getDVDImages(self.handle)
       return IMedium(self.mgr, val, True)

   def getFloppyImages(self):
       """
        Array of floppy image objects currently in use by this VirtualBox instance.
       """
       val = self.mgr.getService().IVirtualBox_getFloppyImages(self.handle)
       return IMedium(self.mgr, val, True)

   def getProgressOperations(self):
       """ """
       val = self.mgr.getService().IVirtualBox_getProgressOperations(self.handle)
       return IProgress(self.mgr, val, True)

   def getGuestOSTypes(self):
       """ """
       val = self.mgr.getService().IVirtualBox_getGuestOSTypes(self.handle)
       return IGuestOSType(self.mgr, val, True)

   def getSharedFolders(self):
       """
        Collection of global shared folders. Global shared folders are
        available to all virtual machines.

        New shared folders are added to the collection using
        #createSharedFolder. Existing shared folders can be
        removed using #removeSharedFolder.

        
        .. note:: 
          In the current version of the product, global shared folders are not
          implemented and therefore this collection is always empty.
         """
       val = self.mgr.getService().IVirtualBox_getSharedFolders(self.handle)
       return ISharedFolder(self.mgr, val, True)

   def getPerformanceCollector(self):
       """
        Associated performance collector object.
       """
       val = self.mgr.getService().IVirtualBox_getPerformanceCollector(self.handle)
       return IPerformanceCollector(self.mgr, val)

   def getDHCPServers(self):
       """
        DHCP servers.
       """
       val = self.mgr.getService().IVirtualBox_getDHCPServers(self.handle)
       return IDHCPServer(self.mgr, val, True)

   def getNATNetworks(self):
       """ """
       val = self.mgr.getService().IVirtualBox_getNATNetworks(self.handle)
       return INATNetwork(self.mgr, val, True)

   def getEventSource(self):
       """
        Event source for VirtualBox events.
       """
       val = self.mgr.getService().IVirtualBox_getEventSource(self.handle)
       return IEventSource(self.mgr, val)

   def getInternalNetworks(self):
       """
        Names of all internal networks.
       """
       val = self.mgr.getService().IVirtualBox_getInternalNetworks(self.handle)
       return String(self.mgr, val, True)

   def getGenericNetworkDrivers(self):
       """
        Names of all generic network drivers.
       """
       val = self.mgr.getService().IVirtualBox_getGenericNetworkDrivers(self.handle)
       return String(self.mgr, val, True)

   def getCloudNetworks(self):
       """
        Names of all configured cloud networks.
       """
       val = self.mgr.getService().IVirtualBox_getCloudNetworks(self.handle)
       return ICloudNetwork(self.mgr, val, True)

   def getCloudProviderManager(self):
       """
        The cloud provider manager (singleton).
       """
       val = self.mgr.getService().IVirtualBox_getCloudProviderManager(self.handle)
       return ICloudProviderManager(self.mgr, val)



   _Attrs_ = {'version':[getVersion,None],
              'versionNormalized':[getVersionNormalized,None],
              'revision':[getRevision,None],
              'packageType':[getPackageType,None],
              'APIVersion':[getAPIVersion,None],
              'APIRevision':[getAPIRevision,None],
              'homeFolder':[getHomeFolder,None],
              'settingsFilePath':[getSettingsFilePath,None],
              'host':[getHost,None],
              'systemProperties':[getSystemProperties,None],
              'machines':[getMachines,None],
              'machineGroups':[getMachineGroups,None],
              'hardDisks':[getHardDisks,None],
              'DVDImages':[getDVDImages,None],
              'floppyImages':[getFloppyImages,None],
              'progressOperations':[getProgressOperations,None],
              'guestOSTypes':[getGuestOSTypes,None],
              'sharedFolders':[getSharedFolders,None],
              'performanceCollector':[getPerformanceCollector,None],
              'DHCPServers':[getDHCPServers,None],
              'NATNetworks':[getNATNetworks,None],
              'eventSource':[getEventSource,None],
              'internalNetworks':[getInternalNetworks,None],
              'genericNetworkDrivers':[getGenericNetworkDrivers,None],
              'cloudNetworks':[getCloudNetworks,None],
              'cloudProviderManager':[getCloudProviderManager,None]}

class IVFSExplorer(IUnknown):
   """
      The VFSExplorer interface unifies access to different file system
      types. This includes local file systems as well remote file systems like
      S3. For a list of supported types see ::VFSType.
      An instance of this is returned by IAppliance::createVFSExplorer.
    
      Interface ID:
        {FB220201-2FD3-47E2-A5DC-2C2431D833CC}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IVFSExplorer(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVFSExplorer._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVFSExplorer._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def update(self):
       """Updates the internal list of files/directories from the
      current directory level. Use #entryList to get the full list
      after a call to this method.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVFSExplorer_update(*req)
       
       return IProgress(self.mgr, val)

   def cd(self, _arg_dir):
       """Change the current directory level.
        :param _arg_dir: The name of the directory to go in.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_dir,)
       val = self.mgr.getService().IVFSExplorer_cd(*req)
       
       return IProgress(self.mgr, val)

   def cdUp(self):
       """Go one directory upwards from the current directory level.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVFSExplorer_cdUp(*req)
       
       return IProgress(self.mgr, val)

   def entryList(self):
       """Returns a list of files/directories after a call to #update. The user is responsible for keeping this internal
      list up do date.





       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVFSExplorer_entryList(*req)
       
       return String(self.mgr,val["names"], True), UnsignedInt(self.mgr,val["types"], True), Long(self.mgr,val["sizes"], True), UnsignedInt(self.mgr,val["modes"], True)

   def exists(self, _arg_names):
       """Checks if the given file list exists in the current directory
      level.
        :param _arg_names: The names to check.
        :return: The names which exist.
        :rtype: List[wstring]

       """
   
       req = (self.handle,)
       req += (_arg_names,)
       val = self.mgr.getService().IVFSExplorer_exists(*req)
       
       return String(self.mgr, val, True)

   def remove(self, _arg_names):
       """Deletes the given files in the current directory level.
        :param _arg_names: The names to remove.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_names,)
       val = self.mgr.getService().IVFSExplorer_remove(*req)
       
       return IProgress(self.mgr, val)

   def getPath(self):
       """Returns the current path in the virtual file system. """
       val = self.mgr.getService().IVFSExplorer_getPath(self.handle)
       return String(self.mgr, val)

   def getType(self):
       """Returns the file system type which is currently in use. """
       val = self.mgr.getService().IVFSExplorer_getType(self.handle)
       return VFSType(self.mgr, val)



   _Attrs_ = {'path':[getPath,None],
              'type':[getType,None]}

class ICertificate(IUnknown):
   """
        X.509 certificate details.
    
      Interface ID:
        {392F1DE4-80E1-4A8A-93A1-67C5F92A838A}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICertificate(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICertificate._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICertificate._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def isCurrentlyExpired(self):
       """
        Tests if the certificate has expired at the present time according to
        the X.509 validity of the certificate.
        :return: 
        :rtype: boolean

       """
   
       req = (self.handle,)
       val = self.mgr.getService().ICertificate_isCurrentlyExpired(*req)
       
       return Boolean(self.mgr, val)

   def queryInfo(self, _arg_what):
       """Way to extend the interface.
        :param _arg_what: 
        :return: 
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_what,)
       val = self.mgr.getService().ICertificate_queryInfo(*req)
       
       return String(self.mgr, val)

   def getVersionNumber(self):
       """Certificate version number. """
       val = self.mgr.getService().ICertificate_getVersionNumber(self.handle)
       return CertificateVersion(self.mgr, val)

   def getSerialNumber(self):
       """Certificate serial number. """
       val = self.mgr.getService().ICertificate_getSerialNumber(self.handle)
       return String(self.mgr, val)

   def getSignatureAlgorithmOID(self):
       """The dotted OID of the signature algorithm. """
       val = self.mgr.getService().ICertificate_getSignatureAlgorithmOID(self.handle)
       return String(self.mgr, val)

   def getSignatureAlgorithmName(self):
       """The signature algorithm name if known (if known). """
       val = self.mgr.getService().ICertificate_getSignatureAlgorithmName(self.handle)
       return String(self.mgr, val)

   def getIssuerName(self):
       """Issuer name.  Each member of the array is on the format
      COMPONENT=NAME, e.g. "C=DE", "ST=Example", "L=For Instance", "O=Beispiel GmbH",
      "CN=beispiel.example.org".
       """
       val = self.mgr.getService().ICertificate_getIssuerName(self.handle)
       return String(self.mgr, val, True)

   def getSubjectName(self):
       """Subject name.  Same format as issuerName. """
       val = self.mgr.getService().ICertificate_getSubjectName(self.handle)
       return String(self.mgr, val, True)

   def getFriendlyName(self):
       """Friendly subject name or similar. """
       val = self.mgr.getService().ICertificate_getFriendlyName(self.handle)
       return String(self.mgr, val)

   def getValidityPeriodNotBefore(self):
       """Certificate not valid before ISO timestamp. """
       val = self.mgr.getService().ICertificate_getValidityPeriodNotBefore(self.handle)
       return String(self.mgr, val)

   def getValidityPeriodNotAfter(self):
       """Certificate not valid after ISO timestamp. """
       val = self.mgr.getService().ICertificate_getValidityPeriodNotAfter(self.handle)
       return String(self.mgr, val)

   def getPublicKeyAlgorithmOID(self):
       """The dotted OID of the public key algorithm. """
       val = self.mgr.getService().ICertificate_getPublicKeyAlgorithmOID(self.handle)
       return String(self.mgr, val)

   def getPublicKeyAlgorithm(self):
       """The public key algorithm name (if known). """
       val = self.mgr.getService().ICertificate_getPublicKeyAlgorithm(self.handle)
       return String(self.mgr, val)

   def getSubjectPublicKey(self):
       """The raw public key bytes. """
       val = self.mgr.getService().ICertificate_getSubjectPublicKey(self.handle)
       return self.mgr.decodebase64( val)

   def getIssuerUniqueIdentifier(self):
       """Unique identifier of the issuer (empty string if not present). """
       val = self.mgr.getService().ICertificate_getIssuerUniqueIdentifier(self.handle)
       return String(self.mgr, val)

   def getSubjectUniqueIdentifier(self):
       """Unique identifier of this certificate (empty string if not present). """
       val = self.mgr.getService().ICertificate_getSubjectUniqueIdentifier(self.handle)
       return String(self.mgr, val)

   def getCertificateAuthority(self):
       """Whether this certificate is a certificate authority.  Will return E_FAIL
      if this attribute is not present.
       """
       val = self.mgr.getService().ICertificate_getCertificateAuthority(self.handle)
       return Boolean(self.mgr, val)

   def getKeyUsage(self):
       """Key usage mask.  Will return 0 if not present. """
       val = self.mgr.getService().ICertificate_getKeyUsage(self.handle)
       return UnsignedInt(self.mgr, val)

   def getExtendedKeyUsage(self):
       """Array of dotted extended key usage OIDs.  Empty array if not present. """
       val = self.mgr.getService().ICertificate_getExtendedKeyUsage(self.handle)
       return String(self.mgr, val, True)

   def getRawCertData(self):
       """The raw certificate bytes. """
       val = self.mgr.getService().ICertificate_getRawCertData(self.handle)
       return self.mgr.decodebase64( val)

   def getSelfSigned(self):
       """Set if self signed certificate. """
       val = self.mgr.getService().ICertificate_getSelfSigned(self.handle)
       return Boolean(self.mgr, val)

   def getTrusted(self):
       """Set if the certificate is trusted (by the parent object). """
       val = self.mgr.getService().ICertificate_getTrusted(self.handle)
       return Boolean(self.mgr, val)

   def getExpired(self):
       """Set if the certificate has expired (relevant to the parent object)/ """
       val = self.mgr.getService().ICertificate_getExpired(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'versionNumber':[getVersionNumber,None],
              'serialNumber':[getSerialNumber,None],
              'signatureAlgorithmOID':[getSignatureAlgorithmOID,None],
              'signatureAlgorithmName':[getSignatureAlgorithmName,None],
              'issuerName':[getIssuerName,None],
              'subjectName':[getSubjectName,None],
              'friendlyName':[getFriendlyName,None],
              'validityPeriodNotBefore':[getValidityPeriodNotBefore,None],
              'validityPeriodNotAfter':[getValidityPeriodNotAfter,None],
              'publicKeyAlgorithmOID':[getPublicKeyAlgorithmOID,None],
              'publicKeyAlgorithm':[getPublicKeyAlgorithm,None],
              'subjectPublicKey':[getSubjectPublicKey,None],
              'issuerUniqueIdentifier':[getIssuerUniqueIdentifier,None],
              'subjectUniqueIdentifier':[getSubjectUniqueIdentifier,None],
              'certificateAuthority':[getCertificateAuthority,None],
              'keyUsage':[getKeyUsage,None],
              'extendedKeyUsage':[getExtendedKeyUsage,None],
              'rawCertData':[getRawCertData,None],
              'selfSigned':[getSelfSigned,None],
              'trusted':[getTrusted,None],
              'expired':[getExpired,None]}

class IAppliance(IUnknown):
   """
        Represents a platform-independent appliance in OVF format. An instance of this is returned
        by IVirtualBox::createAppliance, which can then be used to import and export
        virtual machines within an appliance with VirtualBox.

        The OVF standard suggests two different physical file formats:

          * If the appliance is distributed as a set of files, there must be at least one XML descriptor
                file that conforms to the OVF standard and carries an .ovf file extension. If
                this descriptor file references other files such as disk images, as OVF appliances typically
                do, those additional files must be in the same directory as the descriptor file.
          * If the appliance is distributed as a single file, it must be in TAR format and have the
                .ova file extension. This TAR file must then contain at least the OVF descriptor
                files and optionally other files.

                At this time, VirtualBox does not not yet support the packed (TAR) variant; support will
                be added with a later version.

        Importing an OVF appliance into VirtualBox as instances of
        ::IMachine involves the following sequence of API calls:

          * Call IVirtualBox::createAppliance. This will create an empty IAppliance object.
          
          * On the new object, call #read with the full path of the OVF file you
              would like to import. So long as this file is syntactically valid, this will succeed
              and fill the appliance object with the parsed data from the OVF file.
          
          * Next, call #interpret, which analyzes the OVF data and sets up the
              contents of the IAppliance attributes accordingly. These can be inspected by a
              VirtualBox front-end such as the GUI, and the suggestions can be displayed to the
              user. In particular, the #virtualSystemDescriptions array contains
              instances of ::IVirtualSystemDescription which represent the virtual
              systems (machines) in the OVF, which in turn describe the virtual hardware prescribed
              by the OVF (network and hardware adapters, virtual disk images, memory size and so on).
              The GUI can then give the user the option to confirm and/or change these suggestions.
          
          * If desired, call IVirtualSystemDescription::setFinalValues for each
              virtual system (machine) to override the suggestions made by the #interpret routine.
          
          * Finally, call #importMachines to create virtual machines in
              VirtualBox as instances of ::IMachine that match the information in the
              virtual system descriptions. After this call succeeded, the UUIDs of the machines created
              can be found in the #machines array attribute.
          

        Exporting VirtualBox machines into an OVF appliance involves the following steps:

          * As with importing, first call IVirtualBox::createAppliance to create
                an empty IAppliance object.
            
          * For each machine you would like to export, call IMachine::exportTo
                with the IAppliance object you just created. Each such call creates one instance of
                ::IVirtualSystemDescription inside the appliance.
            
          * If desired, call IVirtualSystemDescription::setFinalValues for each
                virtual system (machine) to override the suggestions made by the IMachine::exportTo routine.
            
          * Finally, call #write with a path specification to have the OVF
                file written.

        
      Interface ID:
        {86A98347-7619-41AA-AECE-B21AC5C1A7E6}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IAppliance(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IAppliance._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IAppliance._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def read(self, _arg_file):
       """
        Reads an OVF file into the appliance object.

        This method succeeds if the OVF is syntactically valid and, by itself, without errors. The
        mere fact that this method returns successfully does not mean that VirtualBox supports all
        features requested by the appliance; this can only be examined after a call to #interpret.
      
        :param _arg_file: Name of appliance file to open (either with an .ovf or .ova extension, depending on whether the appliance is distributed as a set of files or as a single file, respectively).
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_file,)
       val = self.mgr.getService().IAppliance_read(*req)
       
       return IProgress(self.mgr, val)

   def interpret(self):
       """
        Interprets the OVF data that was read when the appliance was constructed. After
        calling this method, one can inspect the
        #virtualSystemDescriptions array attribute, which will then contain
        one ::IVirtualSystemDescription for each virtual machine found in
        the appliance.

        Calling this method is the second step of importing an appliance into VirtualBox;
        see ::IAppliance for an overview.

        After calling this method, one should call #getWarnings to find out
        if problems were encountered during the processing which might later lead to
        errors.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IAppliance_interpret(*req)
       
       return 

   def importMachines(self, _arg_options):
       """
        Imports the appliance into VirtualBox by creating instances of ::IMachine
        and other interfaces that match the information contained in the appliance as
        closely as possible, as represented by the import instructions in the
        #virtualSystemDescriptions array.

        Calling this method is the final step of importing an appliance into VirtualBox;
        see ::IAppliance for an overview.

        Since importing the appliance will most probably involve copying and converting
        disk images, which can take a long time, this method operates asynchronously and
        returns an IProgress object to allow the caller to monitor the progress.

        After the import succeeded, the UUIDs of the IMachine instances created can be
        retrieved from the #machines array attribute.
      
        :param _arg_options: Options for the importing operation.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_options,)
       val = self.mgr.getService().IAppliance_importMachines(*req)
       
       return IProgress(self.mgr, val)

   def createVFSExplorer(self, _arg_URI):
       """Returns a ::IVFSExplorer object for the given URI.
        :param _arg_URI: The URI describing the file system to use.
        :return: 
        :rtype: IVFSExplorer

       """
   
       req = (self.handle,)
       req += (_arg_URI,)
       val = self.mgr.getService().IAppliance_createVFSExplorer(*req)
       
       return IVFSExplorer(self.mgr, val)

   def write(self, _arg_format, _arg_options, _arg_path):
       """
          Writes the contents of the appliance exports into a new OVF file.

          Calling this method is the final step of exporting an appliance from VirtualBox;
          see ::IAppliance for an overview.

          Since exporting the appliance will most probably involve copying and converting
          disk images, which can take a long time, this method operates asynchronously and
          returns an IProgress object to allow the caller to monitor the progress.
      
        :param _arg_format: Output format, as a string. Currently supported formats are "ovf-0.9", "ovf-1.0", "ovf-2.0" and "opc-1.0"; future versions of VirtualBox may support additional formats. The "opc-1.0" format is for creating tarballs for the Oracle Public Cloud.
        :param _arg_options: Options for the exporting operation.
        :param _arg_path: Name of appliance file to create. There are certain restrictions with regard to the file name suffix. If the format parameter is "opc-1.0" a .tar.gz suffix is required. Otherwise the suffix must either be .ovf or .ova, depending on whether the appliance is distributed as a set of files or as a single file, respectively.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_format,)
       req += (_arg_options,)
       req += (_arg_path,)
       val = self.mgr.getService().IAppliance_write(*req)
       
       return IProgress(self.mgr, val)

   def getWarnings(self):
       """Returns textual warnings which occurred during execution of #interpret.
        :return: 
        :rtype: List[wstring]

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IAppliance_getWarnings(*req)
       
       return String(self.mgr, val, True)

   def getPasswordIds(self):
       """
        Returns a list of password identifiers which must be supplied to import or export
        encrypted virtual machines.
      
        :return: The list of password identifiers required for export on success.
        :rtype: List[wstring]

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IAppliance_getPasswordIds(*req)
       
       return String(self.mgr, val, True)

   def getMediumIdsForPasswordId(self, _arg_passwordId):
       """
        Returns a list of medium identifiers which use the given password identifier.
      
        :param _arg_passwordId: The password identifier to get the medium identifiers for.
        :return: The list of medium identifiers returned on success.
        :rtype: List[uuid]

       """
   
       req = (self.handle,)
       req += (_arg_passwordId,)
       val = self.mgr.getService().IAppliance_getMediumIdsForPasswordId(*req)
       
       return String(self.mgr, val, True)

   def addPasswords(self, _arg_identifiers, _arg_passwords):
       """
        Adds a list of passwords required to import or export encrypted virtual
        machines.
      
        :param _arg_identifiers: List of identifiers.
        :param _arg_passwords: List of matching passwords.

       """
   
       req = (self.handle,)
       req += (_arg_identifiers,)
       req += (_arg_passwords,)
       val = self.mgr.getService().IAppliance_addPasswords(*req)
       
       return 

   def createVirtualSystemDescriptions(self, _arg_requested):
       """Creates a number of ::IVirtualSystemDescription objects and store them
      in the #virtualSystemDescriptions array.
      
        :param _arg_requested: Requested number of new virtual system description objects
        :return: Actually created number of virtual system description objects
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_requested,)
       val = self.mgr.getService().IAppliance_createVirtualSystemDescriptions(*req)
       
       return UnsignedInt(self.mgr, val)

   def getPath(self):
       """Path to the main file of the OVF appliance, which is either the .ovf or
          the .ova file passed to #read (for import) or
          #write (for export).
          This attribute is empty until one of these methods has been called.
       """
       val = self.mgr.getService().IAppliance_getPath(self.handle)
       return String(self.mgr, val)

   def getDisks(self):
       """
        Array of virtual disk definitions. One such description exists for each
        disk definition in the OVF; each string array item represents one such piece of
        disk information, with the information fields separated by tab (\\t) characters.

        The caller should be prepared for additional fields being appended to
        this string in future versions of VirtualBox and therefore check for
        the number of tabs in the strings returned.

        In the current version, the following eight fields are returned per string
        in the array:

          * Disk ID (unique string identifier given to disk)
          * Capacity (unsigned integer indicating the maximum capacity of the disk)
          * Populated size (optional unsigned integer indicating the current size of the
            disk; can be approximate; -1 if unspecified)
          * Format (string identifying the disk format, typically
            "http://www.vmware.com/specifications/vmdk.html#sparse")
          * Reference (where to find the disk image, typically a file name; if empty,
            then the disk should be created on import)
          * Image size (optional unsigned integer indicating the size of the image,
            which need not necessarily be the same as the values specified above, since
            the image may be compressed or sparse; -1 if not specified)
          * Chunk size (optional unsigned integer if the image is split into chunks;
            presently unsupported and always -1)
          * Compression (optional string equaling "gzip" if the image is gzip-compressed)

         """
       val = self.mgr.getService().IAppliance_getDisks(self.handle)
       return String(self.mgr, val, True)

   def getVirtualSystemDescriptions(self):
       """ Array of virtual system descriptions. One such description is created
      for each virtual system (machine) found in the OVF.
      This array is empty until either #interpret (for import) or IMachine::exportTo
      (for export) has been called.
       """
       val = self.mgr.getService().IAppliance_getVirtualSystemDescriptions(self.handle)
       return IVirtualSystemDescription(self.mgr, val, True)

   def getMachines(self):
       """
        Contains the UUIDs of the machines created from the information in this appliances. This is only
        relevant for the import case, and will only contain data after a call to #importMachines
        succeeded.
       """
       val = self.mgr.getService().IAppliance_getMachines(self.handle)
       return String(self.mgr, val, True)

   def getCertificate(self):
       """
        The X.509 signing certificate, if the imported OVF was signed, @c null
        if not signed.  This is available after calling #read.
       """
       val = self.mgr.getService().IAppliance_getCertificate(self.handle)
       return ICertificate(self.mgr, val)



   _Attrs_ = {'path':[getPath,None],
              'disks':[getDisks,None],
              'virtualSystemDescriptions':[getVirtualSystemDescriptions,None],
              'machines':[getMachines,None],
              'certificate':[getCertificate,None]}

class IVirtualSystemDescription(IUnknown):
   """Represents one virtual system (machine) in an appliance. This interface is used in
      the IAppliance::virtualSystemDescriptions array. After
      IAppliance::interpret has been called, that array contains information
      about how the virtual systems described in the OVF should best be imported into
      VirtualBox virtual machines. See ::IAppliance for the steps required to
      import an OVF into VirtualBox.
    
      Interface ID:
        {01510F40-C196-4D26-B8DB-4C8C389F1F82}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IVirtualSystemDescription(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVirtualSystemDescription._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVirtualSystemDescription._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getDescription(self):
       """Returns information about the virtual system as arrays of instruction items. In each array, the
      items with the same indices correspond and jointly represent an import instruction for VirtualBox.

      The list below identifies the value sets that are possible depending on the
      ::VirtualSystemDescriptionType enum value in the array item in @a aTypes[]. In each case,
      the array item with the same index in @a OVFValues[] will contain the original value as contained
      in the OVF file (just for informational purposes), and the corresponding item in @a aVBoxValues[]
      will contain a suggested value to be used for VirtualBox. Depending on the description type,
      the @a aExtraConfigValues[] array item may also be used.

        * 
        "OS": the guest operating system type. There must be exactly one such array item on import. The
        corresponding item in @a aVBoxValues[] contains the suggested guest operating system for VirtualBox.
        This will be one of the values listed in IVirtualBox::guestOSTypes. The corresponding
        item in @a OVFValues[] will contain a numerical value that described the operating system in the OVF.
      
          * 
        "Name": the name to give to the new virtual machine. There can be at most one such array item;
        if none is present on import, then an automatic name will be created from the operating system
        type. The corresponding item im @a OVFValues[] will contain the suggested virtual machine name
        from the OVF file, and @a aVBoxValues[] will contain a suggestion for a unique VirtualBox
        ::IMachine name that does not exist yet.
      
          * 
          "Description": an arbitrary description.
      
          * 
          "License": the EULA section from the OVF, if present. It is the responsibility of the calling
          code to display such a license for agreement; the Main API does not enforce any such policy.
      
          * 
          Miscellaneous: reserved for future use.
      
          * 
        "CPU": the number of CPUs. There can be at most one such item, which will presently be ignored.
      
          * 
        "Memory": the amount of guest RAM, in bytes. There can be at most one such array item; if none
        is present on import, then VirtualBox will set a meaningful default based on the operating system
        type.
      
          * 
        "HardDiskControllerIDE": an IDE hard disk controller. There can be at most two such items.
        An optional value in @a OVFValues[] and @a aVBoxValues[] can be "PIIX3" or "PIIX4" to specify
        the type of IDE controller; this corresponds to the ResourceSubType element which VirtualBox
        writes into the OVF.
        The matching item in the @a aRefs[] array will contain an integer that items of the "Harddisk"
        type can use to specify which hard disk controller a virtual disk should be connected to.
        Note that in OVF, an IDE controller has two channels, corresponding to "master" and "slave"
        in traditional terminology, whereas the IDE storage controller that VirtualBox supports in
        its virtual machines supports four channels (primary master, primary slave, secondary master,
        secondary slave) and thus maps to two IDE controllers in the OVF sense.
      
          * 
        "HardDiskControllerSATA": an SATA hard disk controller. There can be at most one such item. This
        has no value in @a OVFValues[] or @a aVBoxValues[].
        The matching item in the @a aRefs[] array will be used as with IDE controllers (see above).
      
          * 
        "HardDiskControllerSCSI": a SCSI hard disk controller. There can be at most one such item.
        The items in @a OVFValues[] and @a aVBoxValues[] will either be "LsiLogic", "BusLogic" or
        "LsiLogicSas". (Note that in OVF, the LsiLogicSas controller is treated as a SCSI controller
        whereas VirtualBox considers it a class of storage controllers of its own; see
        ::StorageControllerType).
        The matching item in the @a aRefs[] array will be used as with IDE controllers (see above).
      
          * 
        "HardDiskImage": a virtual hard disk, most probably as a reference to an image file. There can be an
        arbitrary number of these items, one for each virtual disk image that accompanies the OVF.

        The array item in @a OVFValues[] will contain the file specification from the OVF file (without
        a path since the image file should be in the same location as the OVF file itself), whereas the
        item in @a aVBoxValues[] will contain a qualified path specification to where VirtualBox uses the
        hard disk image. This means that on import the image will be copied and converted from the
        "ovf" location to the "vbox" location; on export, this will be handled the other way round.

        The matching item in the @a aExtraConfigValues[] array must contain a string of the following
        format: "controller=<index>;channel=<c>"
        In this string, <index> must be an integer specifying the hard disk controller to connect
        the image to. That number must be the index of an array item with one of the hard disk controller
        types (HardDiskControllerSCSI, HardDiskControllerSATA, HardDiskControllerIDE).
        In addition, <c> must specify the channel to use on that controller. For IDE controllers,
        this can be 0 or 1 for master or slave, respectively. For compatibility with VirtualBox versions
        before 3.2, the values 2 and 3 (for secondary master and secondary slave) are also supported, but
        no longer exported. For SATA and SCSI controllers, the channel can range from 0-29.
      
          * 
        "CDROM": a virtual CD-ROM drive. The matching item in @a aExtraConfigValue[] contains the same
        attachment information as with "HardDiskImage" items.
      
          * 
        "CDROM": a virtual floppy drive. The matching item in @a aExtraConfigValue[] contains the same
        attachment information as with "HardDiskImage" items.
      
          * 
        "NetworkAdapter": a network adapter. The array item in @a aVBoxValues[] will specify the hardware
        for the network adapter, whereas the array item in @a aExtraConfigValues[] will have a string
        of the "type=<X>" format, where <X> must be either "NAT" or "Bridged".
      
          * 
          "USBController": a USB controller. There can be at most one such item. If, and only if, such an
          item is present, USB support will be enabled for the new virtual machine.
      
          * 
          "SoundCard": a sound card. There can be at most one such item. If and only if such an item is
          present, sound support will be enabled for the new virtual machine. Note that the virtual
          machine in VirtualBox will always be presented with the standard VirtualBox soundcard, which
          may be different from the virtual soundcard expected by the appliance.
      






       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVirtualSystemDescription_getDescription(*req)
       
       return VirtualSystemDescriptionType(self.mgr,val["types"], True), String(self.mgr,val["refs"], True), String(self.mgr,val["OVFValues"], True), String(self.mgr,val["VBoxValues"], True), String(self.mgr,val["extraConfigValues"], True)

   def getDescriptionByType(self, _arg_type):
       """This is the same as #getDescription except that you can specify which types
      should be returned.
        :param _arg_type: 






       """
   
       req = (self.handle,)
       req += (_arg_type,)
       val = self.mgr.getService().IVirtualSystemDescription_getDescriptionByType(*req)
       
       return VirtualSystemDescriptionType(self.mgr,val["types"], True), String(self.mgr,val["refs"], True), String(self.mgr,val["OVFValues"], True), String(self.mgr,val["VBoxValues"], True), String(self.mgr,val["extraConfigValues"], True)

   def removeDescriptionByType(self, _arg_type):
       """Delete all records which are equal to the passed type from the list
        :param _arg_type: 

       """
   
       req = (self.handle,)
       req += (_arg_type,)
       val = self.mgr.getService().IVirtualSystemDescription_removeDescriptionByType(*req)
       
       return 

   def getValuesByType(self, _arg_type, _arg_which):
       """This is the same as #getDescriptionByType except that you can specify which
      value types should be returned. See ::VirtualSystemDescriptionValueType for possible
      values.
        :param _arg_type: 
        :param _arg_which: 
        :return: 
        :rtype: List[wstring]

       """
   
       req = (self.handle,)
       req += (_arg_type,)
       req += (_arg_which,)
       val = self.mgr.getService().IVirtualSystemDescription_getValuesByType(*req)
       
       return String(self.mgr, val, True)

   def setFinalValues(self, _arg_enabled, _arg_VBoxValues, _arg_extraConfigValues):
       """
        This method allows the appliance's user to change the configuration for the virtual
        system descriptions. For each array item returned from #getDescription,
        you must pass in one boolean value and one configuration value.

        Each item in the boolean array determines whether the particular configuration item
        should be enabled.
        You can only disable items of the types HardDiskControllerIDE, HardDiskControllerSATA,
        HardDiskControllerSCSI, HardDiskImage, CDROM, Floppy, NetworkAdapter, USBController
        and SoundCard.

        For the "vbox" and "extra configuration" values, if you pass in the same arrays
        as returned in the aVBoxValues and aExtraConfigValues arrays from #getDescription,
        the configuration remains unchanged. Please see the documentation for #getDescription
        for valid configuration values for the individual array item types. If the
        corresponding item in the aEnabled array is @c false, the configuration value is ignored.
      
        :param _arg_enabled: 
        :param _arg_VBoxValues: 
        :param _arg_extraConfigValues: 

       """
   
       req = (self.handle,)
       req += (_arg_enabled,)
       req += (_arg_VBoxValues,)
       req += (_arg_extraConfigValues,)
       val = self.mgr.getService().IVirtualSystemDescription_setFinalValues(*req)
       
       return 

   def addDescription(self, _arg_type, _arg_VBoxValue, _arg_extraConfigValue):
       """
      This method adds an additional description entry to the stack of already
      available descriptions for this virtual system. This is handy for writing
      values which aren't directly supported by VirtualBox. One example would
      be the License type of ::VirtualSystemDescriptionType.
      
        :param _arg_type: 
        :param _arg_VBoxValue: 
        :param _arg_extraConfigValue: 

       """
   
       req = (self.handle,)
       req += (_arg_type,)
       req += (_arg_VBoxValue,)
       req += (_arg_extraConfigValue,)
       val = self.mgr.getService().IVirtualSystemDescription_addDescription(*req)
       
       return 

   def getCount(self):
       """Return the number of virtual system description entries. """
       val = self.mgr.getService().IVirtualSystemDescription_getCount(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'count':[getCount,None]}

class IUnattended(IUnknown):
   """
      The IUnattended interface represents the pipeline for preparing
      the Guest OS for fully automated install.

      The typical workflow is:
        * Call IVirtualBox::createUnattendedInstaller to create the object
          * Set IUnattended::isoPath and call IUnattended::detectIsoOS
          * Create, configure and register a machine according to IUnattended::detectedOSTypeId
            and the other detectedOS* attributes.
          * Set IUnattended::machine to the new IMachine instance.
          * Set the other IUnattended attributes as desired.
          * Call IUnattended::prepare for the object to check the
            attribute values and create an internal installer instance.
          * Call IUnattended::constructMedia to create additional
            media files (ISO/floppy) needed.
          * Call IUnattended::reconfigureVM to reconfigure the VM
            with the installation ISO, additional media files and whatnot 
          * Optionally call IUnattended::done to destroy the internal
            installer and allow restarting from the second step.

        

      Note! Steps one is currently not implemented.
    
      Interface ID:
        {6F89464F-7193-426C-A41F-522E8F537FA0}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IUnattended(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUnattended._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUnattended._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def detectIsoOS(self):
       """
        Detects the OS on the ISO given by IUnattended::isoPath and sets
        IUnattended::detectedOSTypeId, IUnattended::detectedOSVersionIUnattended::detectedOSFlavor, IUnattended::detectedOSLanguages,
        and IUnattended::detectedOSHints.

        Not really yet implemented.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IUnattended_detectIsoOS(*req)
       
       return 

   def prepare(self):
       """
        Prepare for running the unattended process of installation.

        This will instantiate the installer based on the guest type associated
        with the machine (see IMachine::OSTypeId).  It will also
        perform IUnattended::detectIsoOS if not yet called on the
        current IUnattended::isoPath value.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IUnattended_prepare(*req)
       
       return 

   def constructMedia(self):
       """
        Constructors the necessary ISO/VISO/Floppy images, with unattended scripts
        and all necessary bits on them.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IUnattended_constructMedia(*req)
       
       return 

   def reconfigureVM(self):
       """
        Reconfigures the machine to start the installation.

        This involves mounting the ISOs and floppy images created by
        IUnattended::constructMedia, attaching new DVD and floppy
        drives as necessary, and possibly modifying the boot order.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IUnattended_reconfigureVM(*req)
       
       return 

   def done(self):
       """
        Done - time to start the VM.

        This deletes the internal installer instance that IUnattended::prepare
        created.  Before done() is called, it is not possible to start over again
        from IUnattended::prepare.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IUnattended_done(*req)
       
       return 

   def getIsoPath(self):
       """
        Guest operating system ISO image
       """
       val = self.mgr.getService().IUnattended_getIsoPath(self.handle)
       return String(self.mgr, val)

   def setIsoPath(self, value):
       """
        Guest operating system ISO image
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setIsoPath(_this, _val)

   def getMachine(self):
       """
        The associated machine object.

        This must be set before IUnattended::prepare is called.
        The VM must be registered.
       """
       val = self.mgr.getService().IUnattended_getMachine(self.handle)
       return IMachine(self.mgr, val)

   def setMachine(self, value):
       """
        The associated machine object.

        This must be set before IUnattended::prepare is called.
        The VM must be registered.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setMachine(_this, _val)

   def getUser(self):
       """
        Assign an user login name.
       """
       val = self.mgr.getService().IUnattended_getUser(self.handle)
       return String(self.mgr, val)

   def setUser(self, value):
       """
        Assign an user login name.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setUser(_this, _val)

   def getPassword(self):
       """
        Assign a password to the user. The password is the same for both
        normal user and for Administrator / 'root' accounts.
       """
       val = self.mgr.getService().IUnattended_getPassword(self.handle)
       return String(self.mgr, val)

   def setPassword(self, value):
       """
        Assign a password to the user. The password is the same for both
        normal user and for Administrator / 'root' accounts.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setPassword(_this, _val)

   def getFullUserName(self):
       """
        The full name of the user.  This is optional and defaults to
        IUnattended::user.  Please note that not all guests picks
        up this attribute.
       """
       val = self.mgr.getService().IUnattended_getFullUserName(self.handle)
       return String(self.mgr, val)

   def setFullUserName(self, value):
       """
        The full name of the user.  This is optional and defaults to
        IUnattended::user.  Please note that not all guests picks
        up this attribute.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setFullUserName(_this, _val)

   def getProductKey(self):
       """
        Any key which is used as authorization of access to install genuine OS
       """
       val = self.mgr.getService().IUnattended_getProductKey(self.handle)
       return String(self.mgr, val)

   def setProductKey(self, value):
       """
        Any key which is used as authorization of access to install genuine OS
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setProductKey(_this, _val)

   def getAdditionsIsoPath(self):
       """
        Guest Additions ISO image path.  This defaults to
        ISystemProperties::defaultAdditionsISO when the Unattended
        object is instantiated.

        This property is ignored when IUnattended::installGuestAdditions is false.
       """
       val = self.mgr.getService().IUnattended_getAdditionsIsoPath(self.handle)
       return String(self.mgr, val)

   def setAdditionsIsoPath(self, value):
       """
        Guest Additions ISO image path.  This defaults to
        ISystemProperties::defaultAdditionsISO when the Unattended
        object is instantiated.

        This property is ignored when IUnattended::installGuestAdditions is false.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setAdditionsIsoPath(_this, _val)

   def getInstallGuestAdditions(self):
       """
        Indicates whether the guest additions should be installed or not.

        Setting this to false does not affect additions shipped with the linux
        distribution, only the installation of additions pointed to by
        IUnattended::additionsIsoPath.
       """
       val = self.mgr.getService().IUnattended_getInstallGuestAdditions(self.handle)
       return Boolean(self.mgr, val)

   def setInstallGuestAdditions(self, value):
       """
        Indicates whether the guest additions should be installed or not.

        Setting this to false does not affect additions shipped with the linux
        distribution, only the installation of additions pointed to by
        IUnattended::additionsIsoPath.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setInstallGuestAdditions(_this, _val)

   def getValidationKitIsoPath(self):
       """
        VirtualBox ValidationKit ISO image path.  This is used when
        IUnattended::installTestExecService is set to true.
       """
       val = self.mgr.getService().IUnattended_getValidationKitIsoPath(self.handle)
       return String(self.mgr, val)

   def setValidationKitIsoPath(self, value):
       """
        VirtualBox ValidationKit ISO image path.  This is used when
        IUnattended::installTestExecService is set to true.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setValidationKitIsoPath(_this, _val)

   def getInstallTestExecService(self):
       """
        Indicates whether the test execution service (TXS) from the VBox
        ValidationKit should be installed.

        The TXS binary will be taken from the ISO indicated by
        IUnattended::validationKitIsoPath.
       """
       val = self.mgr.getService().IUnattended_getInstallTestExecService(self.handle)
       return Boolean(self.mgr, val)

   def setInstallTestExecService(self, value):
       """
        Indicates whether the test execution service (TXS) from the VBox
        ValidationKit should be installed.

        The TXS binary will be taken from the ISO indicated by
        IUnattended::validationKitIsoPath.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setInstallTestExecService(_this, _val)

   def getTimeZone(self):
       """
        The guest time zone specifier.

        This is unfortunately guest OS specific.

        Windows XP and earlier takes the index number from this table:
        https://support.microsoft.com/en-gb/help/973627/microsoft-time-zone-index-values

        Windows Vista and later takes the time zone string from this table:
        https://technet.microsoft.com/en-us/library/cc749073(v=ws.10).aspx

        Linux usually takes the TZ string from this table:
        https://en.wikipedia.org/wiki/List_of_tz_database_time_zones

        The default is currently UTC/GMT, but this may change to be same as
        the host later.

        TODO: Investigate automatic mapping between linux and the two windows
              time zone formats.
        TODO: Take default from host (this requires mapping).
       """
       val = self.mgr.getService().IUnattended_getTimeZone(self.handle)
       return String(self.mgr, val)

   def setTimeZone(self, value):
       """
        The guest time zone specifier.

        This is unfortunately guest OS specific.

        Windows XP and earlier takes the index number from this table:
        https://support.microsoft.com/en-gb/help/973627/microsoft-time-zone-index-values

        Windows Vista and later takes the time zone string from this table:
        https://technet.microsoft.com/en-us/library/cc749073(v=ws.10).aspx

        Linux usually takes the TZ string from this table:
        https://en.wikipedia.org/wiki/List_of_tz_database_time_zones

        The default is currently UTC/GMT, but this may change to be same as
        the host later.

        TODO: Investigate automatic mapping between linux and the two windows
              time zone formats.
        TODO: Take default from host (this requires mapping).
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setTimeZone(_this, _val)

   def getLocale(self):
       """
        The 5 letter locale identifier, no codesets or such.

        The format is two lower case language letters (ISO 639-1), underscore ('_'),
        and two upper case country letters (ISO 3166-1 alpha-2).  For instance
        'en_US', 'de_DE', or 'ny_NO'.

        The default is taken from the host if possible, with 'en_US' as fallback.
       """
       val = self.mgr.getService().IUnattended_getLocale(self.handle)
       return String(self.mgr, val)

   def setLocale(self, value):
       """
        The 5 letter locale identifier, no codesets or such.

        The format is two lower case language letters (ISO 639-1), underscore ('_'),
        and two upper case country letters (ISO 3166-1 alpha-2).  For instance
        'en_US', 'de_DE', or 'ny_NO'.

        The default is taken from the host if possible, with 'en_US' as fallback.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setLocale(_this, _val)

   def getLanguage(self):
       """
        This is more or less a Windows specific setting for choosing the UI language
        setting of the installer.

        The value should be from the list availble via IUnattended::detectedOSLanguages.
        The typical format is {language-code}-{COUNTRY} but windows may also use
        {16-bit code}:{32-bit code} or insert another component between the language
        and country codes.  We consider the format guest OS specific.

        Note that it is crucial that this is correctly specified for Windows
        installations.  If an unsupported value is given the installer will ask
        for an installation language and wait for user input.  Best to leave it
        to the default value.

        The default is the first one from IUnattended::detectedOSLanguages.
       """
       val = self.mgr.getService().IUnattended_getLanguage(self.handle)
       return String(self.mgr, val)

   def setLanguage(self, value):
       """
        This is more or less a Windows specific setting for choosing the UI language
        setting of the installer.

        The value should be from the list availble via IUnattended::detectedOSLanguages.
        The typical format is {language-code}-{COUNTRY} but windows may also use
        {16-bit code}:{32-bit code} or insert another component between the language
        and country codes.  We consider the format guest OS specific.

        Note that it is crucial that this is correctly specified for Windows
        installations.  If an unsupported value is given the installer will ask
        for an installation language and wait for user input.  Best to leave it
        to the default value.

        The default is the first one from IUnattended::detectedOSLanguages.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setLanguage(_this, _val)

   def getCountry(self):
       """
        The 2 upper case letter country identifier, ISO 3166-1 alpha-2.

        This is used for mirrors and such.

        The default is taken from the host when possible, falling back on
        IUnattended::locale.
       """
       val = self.mgr.getService().IUnattended_getCountry(self.handle)
       return String(self.mgr, val)

   def setCountry(self, value):
       """
        The 2 upper case letter country identifier, ISO 3166-1 alpha-2.

        This is used for mirrors and such.

        The default is taken from the host when possible, falling back on
        IUnattended::locale.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setCountry(_this, _val)

   def getProxy(self):
       """
        Proxy incantation to pass on to the guest OS installer.

        This is important to get right if the guest OS installer is of the type
        that goes online to fetch the packages (e.g. debian-*-netinst.iso) or
        to fetch updates during the install process.

        Format: [schema=]schema://[login@password:]proxy[:port][;...]

        The default is taken from the host proxy configuration (once implemented).
       """
       val = self.mgr.getService().IUnattended_getProxy(self.handle)
       return String(self.mgr, val)

   def setProxy(self, value):
       """
        Proxy incantation to pass on to the guest OS installer.

        This is important to get right if the guest OS installer is of the type
        that goes online to fetch the packages (e.g. debian-*-netinst.iso) or
        to fetch updates during the install process.

        Format: [schema=]schema://[login@password:]proxy[:port][;...]

        The default is taken from the host proxy configuration (once implemented).
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setProxy(_this, _val)

   def getPackageSelectionAdjustments(self):
       """
        Guest OS specific package selection adjustments.

        This is a semicolon separated list of keywords, and later maybe guest OS
        package specifiers.  Currently the 'minimal' is the only recognized value,
        and this only works with a selection of linux installers.
       """
       val = self.mgr.getService().IUnattended_getPackageSelectionAdjustments(self.handle)
       return String(self.mgr, val)

   def setPackageSelectionAdjustments(self, value):
       """
        Guest OS specific package selection adjustments.

        This is a semicolon separated list of keywords, and later maybe guest OS
        package specifiers.  Currently the 'minimal' is the only recognized value,
        and this only works with a selection of linux installers.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setPackageSelectionAdjustments(_this, _val)

   def getHostname(self):
       """
        The fully qualified guest hostname.

        This defaults to machine-name + ".myguest.virtualbox.org", though it may
        change to the host domain name later.
       """
       val = self.mgr.getService().IUnattended_getHostname(self.handle)
       return String(self.mgr, val)

   def setHostname(self, value):
       """
        The fully qualified guest hostname.

        This defaults to machine-name + ".myguest.virtualbox.org", though it may
        change to the host domain name later.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setHostname(_this, _val)

   def getAuxiliaryBasePath(self):
       """
        The path + basename for auxiliary files generated by the unattended
        installation.  This defaults to the VM folder + Unattended + VM UUID.

        The files which gets generated depends on the OS being installed.  When
        installing Windows there is currently only a auxiliaryBasePath + "floppy.img"
        being created.  But for linux, a "cdrom.viso" and one or more configuration
        files are generate generated.
       """
       val = self.mgr.getService().IUnattended_getAuxiliaryBasePath(self.handle)
       return String(self.mgr, val)

   def setAuxiliaryBasePath(self, value):
       """
        The path + basename for auxiliary files generated by the unattended
        installation.  This defaults to the VM folder + Unattended + VM UUID.

        The files which gets generated depends on the OS being installed.  When
        installing Windows there is currently only a auxiliaryBasePath + "floppy.img"
        being created.  But for linux, a "cdrom.viso" and one or more configuration
        files are generate generated.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setAuxiliaryBasePath(_this, _val)

   def getImageIndex(self):
       """
        The image index on installation CD/DVD used to install.

        Used only with Windows installation CD/DVD:
        https://technet.microsoft.com/en-us/library/cc766022%28v=ws.10%29.aspx
       """
       val = self.mgr.getService().IUnattended_getImageIndex(self.handle)
       return UnsignedInt(self.mgr, val)

   def setImageIndex(self, value):
       """
        The image index on installation CD/DVD used to install.

        Used only with Windows installation CD/DVD:
        https://technet.microsoft.com/en-us/library/cc766022%28v=ws.10%29.aspx
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setImageIndex(_this, _val)

   def getScriptTemplatePath(self):
       """
        The unattended installation script template file.

        The template default is based on the guest OS type and is determined by the
        internal installer when when IUnattended::prepare is invoked.
        Most users will want the defaults.

        After IUnattended::prepare is called, it can be read to see
        which file is being used.
       """
       val = self.mgr.getService().IUnattended_getScriptTemplatePath(self.handle)
       return String(self.mgr, val)

   def setScriptTemplatePath(self, value):
       """
        The unattended installation script template file.

        The template default is based on the guest OS type and is determined by the
        internal installer when when IUnattended::prepare is invoked.
        Most users will want the defaults.

        After IUnattended::prepare is called, it can be read to see
        which file is being used.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setScriptTemplatePath(_this, _val)

   def getPostInstallScriptTemplatePath(self):
       """
        The post installation (shell/batch) script template file.

        The template default is based on the guest OS type and is determined by the
        internal installer when when IUnattended::prepare is invoked.
        Most users will want the defaults.

        After IUnattended::prepare is called, it can be read to see
        which file is being used.
       """
       val = self.mgr.getService().IUnattended_getPostInstallScriptTemplatePath(self.handle)
       return String(self.mgr, val)

   def setPostInstallScriptTemplatePath(self, value):
       """
        The post installation (shell/batch) script template file.

        The template default is based on the guest OS type and is determined by the
        internal installer when when IUnattended::prepare is invoked.
        Most users will want the defaults.

        After IUnattended::prepare is called, it can be read to see
        which file is being used.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setPostInstallScriptTemplatePath(_this, _val)

   def getPostInstallCommand(self):
       """
        Custom post installation command.

        Exactly what is expected as input here depends on the guest OS installer
        and the post installation script template (see
        IUnattended::postInstallScriptTemplatePath).
        Most users will not need to set this attribute.
       """
       val = self.mgr.getService().IUnattended_getPostInstallCommand(self.handle)
       return String(self.mgr, val)

   def setPostInstallCommand(self, value):
       """
        Custom post installation command.

        Exactly what is expected as input here depends on the guest OS installer
        and the post installation script template (see
        IUnattended::postInstallScriptTemplatePath).
        Most users will not need to set this attribute.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setPostInstallCommand(_this, _val)

   def getExtraInstallKernelParameters(self):
       """
        Extra kernel arguments passed to the install kernel of some guests.

        This is currently only picked up by linux guests.  The exact parameters
        are specific to the guest OS being installed of course.

        After IUnattended::prepare is called, it can be read to see
        which parameters are being used.
       """
       val = self.mgr.getService().IUnattended_getExtraInstallKernelParameters(self.handle)
       return String(self.mgr, val)

   def setExtraInstallKernelParameters(self, value):
       """
        Extra kernel arguments passed to the install kernel of some guests.

        This is currently only picked up by linux guests.  The exact parameters
        are specific to the guest OS being installed of course.

        After IUnattended::prepare is called, it can be read to see
        which parameters are being used.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUnattended_setExtraInstallKernelParameters(_this, _val)

   def getDetectedOSTypeId(self):
       """
        The detected OS type ID (IGuestOSType::id).

        Set by IUnattended::detectIsoOS or IUnattended::prepare.

        Not yet implemented.
       """
       val = self.mgr.getService().IUnattended_getDetectedOSTypeId(self.handle)
       return String(self.mgr, val)

   def getDetectedOSVersion(self):
       """
        The detected OS version string.

        Set by IUnattended::detectIsoOS or IUnattended::prepare.

        Not yet implemented.
       """
       val = self.mgr.getService().IUnattended_getDetectedOSVersion(self.handle)
       return String(self.mgr, val)

   def getDetectedOSFlavor(self):
       """
        The detected OS flavor (e.g. server, desktop, etc)

        Set by IUnattended::detectIsoOS or IUnattended::prepare.

        Not yet implemented.
       """
       val = self.mgr.getService().IUnattended_getDetectedOSFlavor(self.handle)
       return String(self.mgr, val)

   def getDetectedOSLanguages(self):
       """
        The space separated list of (Windows) installation UI languages we detected (lang.ini).

        The language specifier format is specific to the guest OS.  They are
        used to set IUnattended::language.

        Set by IUnattended::detectIsoOS or IUnattended::prepare.

        Partially implemented.
       """
       val = self.mgr.getService().IUnattended_getDetectedOSLanguages(self.handle)
       return String(self.mgr, val)

   def getDetectedOSHints(self):
       """
        Space separated list of other stuff detected about the OS and the
        installation ISO.

        Set by IUnattended::detectIsoOS or IUnattended::prepare.

        Not yet implemented.
       """
       val = self.mgr.getService().IUnattended_getDetectedOSHints(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'isoPath':[getIsoPath,setIsoPath,],
              'machine':[getMachine,setMachine,],
              'user':[getUser,setUser,],
              'password':[getPassword,setPassword,],
              'fullUserName':[getFullUserName,setFullUserName,],
              'productKey':[getProductKey,setProductKey,],
              'additionsIsoPath':[getAdditionsIsoPath,setAdditionsIsoPath,],
              'installGuestAdditions':[getInstallGuestAdditions,setInstallGuestAdditions,],
              'validationKitIsoPath':[getValidationKitIsoPath,setValidationKitIsoPath,],
              'installTestExecService':[getInstallTestExecService,setInstallTestExecService,],
              'timeZone':[getTimeZone,setTimeZone,],
              'locale':[getLocale,setLocale,],
              'language':[getLanguage,setLanguage,],
              'country':[getCountry,setCountry,],
              'proxy':[getProxy,setProxy,],
              'packageSelectionAdjustments':[getPackageSelectionAdjustments,setPackageSelectionAdjustments,],
              'hostname':[getHostname,setHostname,],
              'auxiliaryBasePath':[getAuxiliaryBasePath,setAuxiliaryBasePath,],
              'imageIndex':[getImageIndex,setImageIndex,],
              'scriptTemplatePath':[getScriptTemplatePath,setScriptTemplatePath,],
              'postInstallScriptTemplatePath':[getPostInstallScriptTemplatePath,setPostInstallScriptTemplatePath,],
              'postInstallCommand':[getPostInstallCommand,setPostInstallCommand,],
              'extraInstallKernelParameters':[getExtraInstallKernelParameters,setExtraInstallKernelParameters,],
              'detectedOSTypeId':[getDetectedOSTypeId,None],
              'detectedOSVersion':[getDetectedOSVersion,None],
              'detectedOSFlavor':[getDetectedOSFlavor,None],
              'detectedOSLanguages':[getDetectedOSLanguages,None],
              'detectedOSHints':[getDetectedOSHints,None]}

class IGraphicsAdapter(IUnknown):
   """
        The IGraphicsAdapter interface represents the graphics adapter
        of the virtual machine.
    
      Interface ID:
        {F692806F-FEBE-4049-B476-1292A8E45B09}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGraphicsAdapter(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGraphicsAdapter._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGraphicsAdapter._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getGraphicsControllerType(self):
       """Graphics controller type. """
       val = self.mgr.getService().IGraphicsAdapter_getGraphicsControllerType(self.handle)
       return GraphicsControllerType(self.mgr, val)

   def setGraphicsControllerType(self, value):
       """Graphics controller type. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IGraphicsAdapter_setGraphicsControllerType(_this, _val)

   def getVRAMSize(self):
       """Video memory size in megabytes. """
       val = self.mgr.getService().IGraphicsAdapter_getVRAMSize(self.handle)
       return UnsignedInt(self.mgr, val)

   def setVRAMSize(self, value):
       """Video memory size in megabytes. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IGraphicsAdapter_setVRAMSize(_this, _val)

   def getAccelerate3DEnabled(self):
       """
        This setting determines whether VirtualBox allows this machine to make
        use of the 3D graphics support available on the host. """
       val = self.mgr.getService().IGraphicsAdapter_getAccelerate3DEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setAccelerate3DEnabled(self, value):
       """
        This setting determines whether VirtualBox allows this machine to make
        use of the 3D graphics support available on the host. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IGraphicsAdapter_setAccelerate3DEnabled(_this, _val)

   def getAccelerate2DVideoEnabled(self):
       """
        This setting determines whether VirtualBox allows this machine to make
        use of the 2D video acceleration support available on the host. """
       val = self.mgr.getService().IGraphicsAdapter_getAccelerate2DVideoEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setAccelerate2DVideoEnabled(self, value):
       """
        This setting determines whether VirtualBox allows this machine to make
        use of the 2D video acceleration support available on the host. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IGraphicsAdapter_setAccelerate2DVideoEnabled(_this, _val)

   def getMonitorCount(self):
       """
        Number of virtual monitors.
        
        .. note:: 
          Only effective on Windows XP and later guests with
          Guest Additions installed.
         """
       val = self.mgr.getService().IGraphicsAdapter_getMonitorCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def setMonitorCount(self, value):
       """
        Number of virtual monitors.
        
        .. note:: 
          Only effective on Windows XP and later guests with
          Guest Additions installed.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IGraphicsAdapter_setMonitorCount(_this, _val)



   _Attrs_ = {'graphicsControllerType':[getGraphicsControllerType,setGraphicsControllerType,],
              'VRAMSize':[getVRAMSize,setVRAMSize,],
              'accelerate3DEnabled':[getAccelerate3DEnabled,setAccelerate3DEnabled,],
              'accelerate2DVideoEnabled':[getAccelerate2DVideoEnabled,setAccelerate2DVideoEnabled,],
              'monitorCount':[getMonitorCount,setMonitorCount,]}

class IBIOSSettings(IUnknown):
   """
        The IBIOSSettings interface represents BIOS settings of the virtual
        machine. This is used only in the IMachine::BIOSSettings attribute.
    
      Interface ID:
        {73AF4152-7E67-4144-BF34-41C38E8B4CC7}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IBIOSSettings(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IBIOSSettings._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IBIOSSettings._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getLogoFadeIn(self):
       """Fade in flag for BIOS logo animation. """
       val = self.mgr.getService().IBIOSSettings_getLogoFadeIn(self.handle)
       return Boolean(self.mgr, val)

   def setLogoFadeIn(self, value):
       """Fade in flag for BIOS logo animation. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setLogoFadeIn(_this, _val)

   def getLogoFadeOut(self):
       """Fade out flag for BIOS logo animation. """
       val = self.mgr.getService().IBIOSSettings_getLogoFadeOut(self.handle)
       return Boolean(self.mgr, val)

   def setLogoFadeOut(self, value):
       """Fade out flag for BIOS logo animation. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setLogoFadeOut(_this, _val)

   def getLogoDisplayTime(self):
       """BIOS logo display time in milliseconds (0 = default). """
       val = self.mgr.getService().IBIOSSettings_getLogoDisplayTime(self.handle)
       return UnsignedInt(self.mgr, val)

   def setLogoDisplayTime(self, value):
       """BIOS logo display time in milliseconds (0 = default). """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setLogoDisplayTime(_this, _val)

   def getLogoImagePath(self):
       """
        Local file system path for external BIOS splash image. Empty string
        means the default image is shown on boot.
       """
       val = self.mgr.getService().IBIOSSettings_getLogoImagePath(self.handle)
       return String(self.mgr, val)

   def setLogoImagePath(self, value):
       """
        Local file system path for external BIOS splash image. Empty string
        means the default image is shown on boot.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setLogoImagePath(_this, _val)

   def getBootMenuMode(self):
       """Mode of the BIOS boot device menu. """
       val = self.mgr.getService().IBIOSSettings_getBootMenuMode(self.handle)
       return BIOSBootMenuMode(self.mgr, val)

   def setBootMenuMode(self, value):
       """Mode of the BIOS boot device menu. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setBootMenuMode(_this, _val)

   def getACPIEnabled(self):
       """ACPI support flag. """
       val = self.mgr.getService().IBIOSSettings_getACPIEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setACPIEnabled(self, value):
       """ACPI support flag. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setACPIEnabled(_this, _val)

   def getIOAPICEnabled(self):
       """
        I/O-APIC support flag. If set, VirtualBox will provide an I/O-APIC
        and support IRQs above 15.
       """
       val = self.mgr.getService().IBIOSSettings_getIOAPICEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setIOAPICEnabled(self, value):
       """
        I/O-APIC support flag. If set, VirtualBox will provide an I/O-APIC
        and support IRQs above 15.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setIOAPICEnabled(_this, _val)

   def getAPICMode(self):
       """
        APIC mode to set up by the firmware.
       """
       val = self.mgr.getService().IBIOSSettings_getAPICMode(self.handle)
       return APICMode(self.mgr, val)

   def setAPICMode(self, value):
       """
        APIC mode to set up by the firmware.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setAPICMode(_this, _val)

   def getTimeOffset(self):
       """
        Offset in milliseconds from the host system time. This allows for
        guests running with a different system date/time than the host.
        It is equivalent to setting the system date/time in the BIOS except
        it is not an absolute value but a relative one. Guest Additions
        time synchronization honors this offset.
       """
       val = self.mgr.getService().IBIOSSettings_getTimeOffset(self.handle)
       return Long(self.mgr, val)

   def setTimeOffset(self, value):
       """
        Offset in milliseconds from the host system time. This allows for
        guests running with a different system date/time than the host.
        It is equivalent to setting the system date/time in the BIOS except
        it is not an absolute value but a relative one. Guest Additions
        time synchronization honors this offset.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setTimeOffset(_this, _val)

   def getPXEDebugEnabled(self):
       """
        PXE debug logging flag. If set, VirtualBox will write extensive
        PXE trace information to the release log.
       """
       val = self.mgr.getService().IBIOSSettings_getPXEDebugEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setPXEDebugEnabled(self, value):
       """
        PXE debug logging flag. If set, VirtualBox will write extensive
        PXE trace information to the release log.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setPXEDebugEnabled(_this, _val)

   def getNonVolatileStorageFile(self):
       """
        The location of the file storing the non-volatile memory content when
        the VM is powered off.  The file does not always exist.
       """
       val = self.mgr.getService().IBIOSSettings_getNonVolatileStorageFile(self.handle)
       return String(self.mgr, val)

   def getSMBIOSUuidLittleEndian(self):
       """
        Flag to control whether the SMBIOS system UUID is presented in little endian
        form to the guest as mandated by the SMBIOS spec chapter 7.2.1.
        Before VirtualBox version 6.1 it was always presented in big endian form
        and to retain the old behavior this flag was introduced so it can be changed.
        VMs created with VBox 6.1 will default to true for this flag.
       """
       val = self.mgr.getService().IBIOSSettings_getSMBIOSUuidLittleEndian(self.handle)
       return Boolean(self.mgr, val)

   def setSMBIOSUuidLittleEndian(self, value):
       """
        Flag to control whether the SMBIOS system UUID is presented in little endian
        form to the guest as mandated by the SMBIOS spec chapter 7.2.1.
        Before VirtualBox version 6.1 it was always presented in big endian form
        and to retain the old behavior this flag was introduced so it can be changed.
        VMs created with VBox 6.1 will default to true for this flag.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBIOSSettings_setSMBIOSUuidLittleEndian(_this, _val)



   _Attrs_ = {'logoFadeIn':[getLogoFadeIn,setLogoFadeIn,],
              'logoFadeOut':[getLogoFadeOut,setLogoFadeOut,],
              'logoDisplayTime':[getLogoDisplayTime,setLogoDisplayTime,],
              'logoImagePath':[getLogoImagePath,setLogoImagePath,],
              'bootMenuMode':[getBootMenuMode,setBootMenuMode,],
              'ACPIEnabled':[getACPIEnabled,setACPIEnabled,],
              'IOAPICEnabled':[getIOAPICEnabled,setIOAPICEnabled,],
              'APICMode':[getAPICMode,setAPICMode,],
              'timeOffset':[getTimeOffset,setTimeOffset,],
              'PXEDebugEnabled':[getPXEDebugEnabled,setPXEDebugEnabled,],
              'nonVolatileStorageFile':[getNonVolatileStorageFile,None],
              'SMBIOSUuidLittleEndian':[getSMBIOSUuidLittleEndian,setSMBIOSUuidLittleEndian,]}

class IRecordingScreenSettings(IUnknown):
   """
      The IRecordingScreenSettings interface represents recording settings of a
      single virtual screen. This is used only in the ::IRecordingSettings
      interface.
    
      Interface ID:
        {678FBD9A-93AF-42A7-7F13-79AD6EF1A18D}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IRecordingScreenSettings(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IRecordingScreenSettings._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IRecordingScreenSettings._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def isFeatureEnabled(self, _arg_feature):
       """Returns whether a particular recording feature is enabled for this
        screen or not.
        :param _arg_feature: Feature to check for.
        :return: @c true if the feature is enabled, @c false if not.
        :rtype: boolean

       """
   
       req = (self.handle,)
       req += (_arg_feature,)
       val = self.mgr.getService().IRecordingScreenSettings_isFeatureEnabled(*req)
       
       return Boolean(self.mgr, val)

   def getId(self):
       """
        This attribute contains the screen ID bound to these settings.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getId(self.handle)
       return UnsignedInt(self.mgr, val)

   def getEnabled(self):
       """
        This setting determines whether this screen is enabled while recording.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEnabled(self, value):
       """
        This setting determines whether this screen is enabled while recording.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setEnabled(_this, _val)

   def getFeatures(self):
       """This setting determines all enabled recording features for this
        screen. """
       val = self.mgr.getService().IRecordingScreenSettings_getFeatures(self.handle)
       return UnsignedInt(self.mgr, val)

   def setFeatures(self, value):
       """This setting determines all enabled recording features for this
        screen. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setFeatures(_this, _val)

   def getDestination(self):
       """This setting determines the recording destination for this
        screen. """
       val = self.mgr.getService().IRecordingScreenSettings_getDestination(self.handle)
       return RecordingDestination(self.mgr, val)

   def setDestination(self, value):
       """This setting determines the recording destination for this
        screen. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setDestination(_this, _val)

   def getFilename(self):
       """
        This setting determines the filename VirtualBox uses to save
        the recorded content. This setting cannot be changed while video
        recording is enabled.
        
        .. note:: 
          When setting this attribute, the specified path has to be
          absolute (full path). When reading this attribute, a full path is
          always returned.
         """
       val = self.mgr.getService().IRecordingScreenSettings_getFilename(self.handle)
       return String(self.mgr, val)

   def setFilename(self, value):
       """
        This setting determines the filename VirtualBox uses to save
        the recorded content. This setting cannot be changed while video
        recording is enabled.
        
        .. note:: 
          When setting this attribute, the specified path has to be
          absolute (full path). When reading this attribute, a full path is
          always returned.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setFilename(_this, _val)

   def getMaxTime(self):
       """
        This setting defines the maximum amount of time in seconds
        to record. Recording will stop as soon as the defined time
        interval has elapsed. If this value is zero, recording will not be
        limited by time. This setting cannot be changed while recording is
        enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getMaxTime(self.handle)
       return UnsignedInt(self.mgr, val)

   def setMaxTime(self, value):
       """
        This setting defines the maximum amount of time in seconds
        to record. Recording will stop as soon as the defined time
        interval has elapsed. If this value is zero, recording will not be
        limited by time. This setting cannot be changed while recording is
        enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setMaxTime(_this, _val)

   def getMaxFileSize(self):
       """
        This setting determines the maximal number of recording file
        size in MB. Recording will stop as soon as the file size has
        reached the defined value. If this value is zero, recording
        will not be limited by the file size. This setting cannot be changed
        while recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getMaxFileSize(self.handle)
       return UnsignedInt(self.mgr, val)

   def setMaxFileSize(self, value):
       """
        This setting determines the maximal number of recording file
        size in MB. Recording will stop as soon as the file size has
        reached the defined value. If this value is zero, recording
        will not be limited by the file size. This setting cannot be changed
        while recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setMaxFileSize(_this, _val)

   def getOptions(self):
       """
        This setting contains any additional recording options
        required in comma-separated key=value format. This setting
        cannot be changed while recording is enabled.

        The following keys and their corresponding values are available:

        ac_enabledEnables audio recording when set to true, otherwise
                set to false to disable.

                This feature is considered being experimental. """
       val = self.mgr.getService().IRecordingScreenSettings_getOptions(self.handle)
       return String(self.mgr, val)

   def setOptions(self, value):
       """
        This setting contains any additional recording options
        required in comma-separated key=value format. This setting
        cannot be changed while recording is enabled.

        The following keys and their corresponding values are available:

        ac_enabledEnables audio recording when set to true, otherwise
                set to false to disable.

                This feature is considered being experimental. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setOptions(_this, _val)

   def getAudioCodec(self):
       """
        Determines the audio codec to use for encoding the
        recorded audio data. This setting cannot be changed while recording is
        enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getAudioCodec(self.handle)
       return RecordingAudioCodec(self.mgr, val)

   def setAudioCodec(self, value):
       """
        Determines the audio codec to use for encoding the
        recorded audio data. This setting cannot be changed while recording is
        enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setAudioCodec(_this, _val)

   def getAudioHz(self):
       """
        Determines the Hertz (Hz) rate of the recorded audio data. This setting
        cannot be changed while recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getAudioHz(self.handle)
       return UnsignedInt(self.mgr, val)

   def setAudioHz(self, value):
       """
        Determines the Hertz (Hz) rate of the recorded audio data. This setting
        cannot be changed while recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setAudioHz(_this, _val)

   def getAudioBits(self):
       """
        Determines the bits per sample of the recorded audio data. This setting
        cannot be changed while recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getAudioBits(self.handle)
       return UnsignedInt(self.mgr, val)

   def setAudioBits(self, value):
       """
        Determines the bits per sample of the recorded audio data. This setting
        cannot be changed while recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setAudioBits(_this, _val)

   def getAudioChannels(self):
       """
        Determines the audio channels of the recorded audio data.
        Specifiy 2 for stereo or 1 for mono. More than stereo (2) channels
        are not supported at the moment. This setting cannot be changed while
        recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getAudioChannels(self.handle)
       return UnsignedInt(self.mgr, val)

   def setAudioChannels(self, value):
       """
        Determines the audio channels of the recorded audio data.
        Specifiy 2 for stereo or 1 for mono. More than stereo (2) channels
        are not supported at the moment. This setting cannot be changed while
        recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setAudioChannels(_this, _val)

   def getVideoCodec(self):
       """
        Determines the video codec to use for encoding the recorded video data.
        This setting cannot be changed while recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getVideoCodec(self.handle)
       return RecordingVideoCodec(self.mgr, val)

   def setVideoCodec(self, value):
       """
        Determines the video codec to use for encoding the recorded video data.
        This setting cannot be changed while recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setVideoCodec(_this, _val)

   def getVideoWidth(self):
       """
        Determines the horizontal resolution of the recorded video data. This
        setting cannot be changed while recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getVideoWidth(self.handle)
       return UnsignedInt(self.mgr, val)

   def setVideoWidth(self, value):
       """
        Determines the horizontal resolution of the recorded video data. This
        setting cannot be changed while recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setVideoWidth(_this, _val)

   def getVideoHeight(self):
       """
        Determines the vertical resolution of the recorded video data. This
        setting cannot be changed while recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getVideoHeight(self.handle)
       return UnsignedInt(self.mgr, val)

   def setVideoHeight(self, value):
       """
        Determines the vertical resolution of the recorded video data. This
        setting cannot be changed while recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setVideoHeight(_this, _val)

   def getVideoRate(self):
       """
        Determines the bitrate in kilobits per second. Increasing this value
        makes the video look better for the cost of an increased file size or
        transfer rate. This setting cannot be changed while recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getVideoRate(self.handle)
       return UnsignedInt(self.mgr, val)

   def setVideoRate(self, value):
       """
        Determines the bitrate in kilobits per second. Increasing this value
        makes the video look better for the cost of an increased file size or
        transfer rate. This setting cannot be changed while recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setVideoRate(_this, _val)

   def getVideoRateControlMode(self):
       """
        Determines the rate control mode. This setting cannot be changed
        while recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getVideoRateControlMode(self.handle)
       return RecordingVideoRateControlMode(self.mgr, val)

   def setVideoRateControlMode(self, value):
       """
        Determines the rate control mode. This setting cannot be changed
        while recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setVideoRateControlMode(_this, _val)

   def getVideoFPS(self):
       """
        Determines the maximum number of frames per second (FPS). Frames with
        a higher frequency will be skipped. Reducing this value increases the
        number of skipped frames and reduces the file size or transfer rate.
        This setting cannot be changed while recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getVideoFPS(self.handle)
       return UnsignedInt(self.mgr, val)

   def setVideoFPS(self, value):
       """
        Determines the maximum number of frames per second (FPS). Frames with
        a higher frequency will be skipped. Reducing this value increases the
        number of skipped frames and reduces the file size or transfer rate.
        This setting cannot be changed while recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setVideoFPS(_this, _val)

   def getVideoScalingMethod(self):
       """
        Determines the video scaling method to use.
        This setting cannot be changed while recording is enabled.
       """
       val = self.mgr.getService().IRecordingScreenSettings_getVideoScalingMethod(self.handle)
       return RecordingVideoScalingMethod(self.mgr, val)

   def setVideoScalingMethod(self, value):
       """
        Determines the video scaling method to use.
        This setting cannot be changed while recording is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingScreenSettings_setVideoScalingMethod(_this, _val)



   _Attrs_ = {'id':[getId,None],
              'enabled':[getEnabled,setEnabled,],
              'features':[getFeatures,setFeatures,],
              'destination':[getDestination,setDestination,],
              'filename':[getFilename,setFilename,],
              'maxTime':[getMaxTime,setMaxTime,],
              'maxFileSize':[getMaxFileSize,setMaxFileSize,],
              'options':[getOptions,setOptions,],
              'audioCodec':[getAudioCodec,setAudioCodec,],
              'audioHz':[getAudioHz,setAudioHz,],
              'audioBits':[getAudioBits,setAudioBits,],
              'audioChannels':[getAudioChannels,setAudioChannels,],
              'videoCodec':[getVideoCodec,setVideoCodec,],
              'videoWidth':[getVideoWidth,setVideoWidth,],
              'videoHeight':[getVideoHeight,setVideoHeight,],
              'videoRate':[getVideoRate,setVideoRate,],
              'videoRateControlMode':[getVideoRateControlMode,setVideoRateControlMode,],
              'videoFPS':[getVideoFPS,setVideoFPS,],
              'videoScalingMethod':[getVideoScalingMethod,setVideoScalingMethod,]}

class IRecordingSettings(IUnknown):
   """
      The IRecordingSettings interface represents recording settings of the virtual
      machine. This is used only in the IMachine::recordingSettings
      attribute.
    
      Interface ID:
        {D88F2A5A-47C7-4A3F-AAE1-1B516817DB41}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IRecordingSettings(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IRecordingSettings._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IRecordingSettings._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getScreenSettings(self, _arg_screenId):
       """Returns the recording settings for a particular screen.
        :param _arg_screenId: Screen ID to retrieve recording screen settings for.
        :return: Recording screen settings for the requested screen.
        :rtype: IRecordingScreenSettings

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       val = self.mgr.getService().IRecordingSettings_getScreenSettings(*req)
       
       return IRecordingScreenSettings(self.mgr, val)

   def getEnabled(self):
       """
        This setting determines whether VirtualBox uses recording to record a
        VM session. """
       val = self.mgr.getService().IRecordingSettings_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEnabled(self, value):
       """
        This setting determines whether VirtualBox uses recording to record a
        VM session. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IRecordingSettings_setEnabled(_this, _val)

   def getScreens(self):
       """
        This setting returns an array for recording settings of all configured
        virtual screens. """
       val = self.mgr.getService().IRecordingSettings_getScreens(self.handle)
       return IRecordingScreenSettings(self.mgr, val, True)



   _Attrs_ = {'enabled':[getEnabled,setEnabled,],
              'screens':[getScreens,None]}

class IPCIAddress(IUnknown):
   """
      Address on the PCI bus.
    
      Interface ID:
        {C984D15F-E191-400B-840E-970F3DAD7296}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IPCIAddress(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IPCIAddress._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IPCIAddress._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def asLong(self):
       """
        Convert PCI address into long.
      
        :return: 
        :rtype: long

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IPCIAddress_asLong(*req)
       
       return Int(self.mgr, val)

   def fromLong(self, _arg_number):
       """
        Make PCI address from long.
      
        :param _arg_number: 

       """
   
       req = (self.handle,)
       req += (_arg_number,)
       val = self.mgr.getService().IPCIAddress_fromLong(*req)
       
       return 

   def getBus(self):
       """
        Bus number.
       """
       val = self.mgr.getService().IPCIAddress_getBus(self.handle)
       return Short(self.mgr, val)

   def setBus(self, value):
       """
        Bus number.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IPCIAddress_setBus(_this, _val)

   def getDevice(self):
       """
        Device number.
       """
       val = self.mgr.getService().IPCIAddress_getDevice(self.handle)
       return Short(self.mgr, val)

   def setDevice(self, value):
       """
        Device number.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IPCIAddress_setDevice(_this, _val)

   def getDevFunction(self):
       """
        Device function number.
       """
       val = self.mgr.getService().IPCIAddress_getDevFunction(self.handle)
       return Short(self.mgr, val)

   def setDevFunction(self, value):
       """
        Device function number.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IPCIAddress_setDevFunction(_this, _val)



   _Attrs_ = {'bus':[getBus,setBus,],
              'device':[getDevice,setDevice,],
              'devFunction':[getDevFunction,setDevFunction,]}

class IMachine(IUnknown):
   """
      The IMachine interface represents a virtual machine, or guest, created
      in VirtualBox.

      This interface is used in two contexts. First of all, a collection of
      objects implementing this interface is stored in the
      IVirtualBox::machines attribute which lists all the virtual
      machines that are currently registered with this VirtualBox
      installation. Also, once a session has been opened for the given virtual
      machine (e.g. the virtual machine is running), the machine object
      associated with the open session can be queried from the session object;
      see ::ISession for details.

      The main role of this interface is to expose the settings of the virtual
      machine and provide methods to change various aspects of the virtual
      machine's configuration. For machine objects stored in the
      IVirtualBox::machines collection, all attributes are
      read-only unless explicitly stated otherwise in individual attribute
      and method descriptions.

      In order to change a machine setting, a session for this machine must be
      opened using one of the IMachine::lockMachine or
      IMachine::launchVMProcess methods. After the
      machine has been successfully locked for a session, a mutable machine object
      needs to be queried from the session object and then the desired settings
      changes can be applied to the returned object using IMachine attributes and
      methods. See the ::ISession interface description for more
      information about sessions.

      Note that IMachine does not provide methods to control virtual machine
      execution (such as start the machine, or power it down) -- these methods
      are grouped in a separate interface called ::IConsole.

      
        .. sealso:: ::ISession, ::IConsole
      Interface ID:
        {85632C68-B5BB-4316-A900-5EB28D3413DF}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMachine(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachine._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachine._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def lockMachine(self, _arg_session, _arg_lockType):
       """
        Locks the machine for the given session to enable the caller
        to make changes to the machine or start the VM or control
        VM execution.

        There are two ways to lock a machine for such uses:

          * If you want to make changes to the machine settings,
            you must obtain an exclusive write lock on the machine
            by setting @a lockType to @c Write.

            This will only succeed if no other process has locked
            the machine to prevent conflicting changes. Only after
            an exclusive write lock has been obtained using this method, one
            can change all VM settings or execute the VM in the process
            space of the session object. (Note that the latter is only of
            interest if you actually want to write a new front-end for
            virtual machines; but this API gets called internally by
            the existing front-ends such as VBoxHeadless and the VirtualBox
            GUI to acquire a write lock on the machine that they are running.)

            On success, write-locking the machine for a session creates
            a second copy of the IMachine object. It is this second object
            upon which changes can be made; in VirtualBox terminology, the
            second copy is "mutable". It is only this second, mutable machine
            object upon which you can call methods that change the
            machine state. After having called this method, you can
            obtain this second, mutable machine object using the
            ISession::machine attribute.
          
          * If you only want to check the machine state or control
            machine execution without actually changing machine
            settings (e.g. to get access to VM statistics or take
            a snapshot or save the machine state), then set the
            @a lockType argument to @c Shared.

            If no other session has obtained a lock, you will obtain an
            exclusive write lock as described above. However, if another
            session has already obtained such a lock, then a link to that
            existing session will be established which allows you
            to control that existing session.

            To find out which type of lock was obtained, you can
            inspect ISession::type, which will have been
            set to either @c WriteLock or @c Shared.
          

        In either case, you can get access to the ::IConsole
        object which controls VM execution.

        Also in all of the above cases, one must always call
        ISession::unlockMachine to release the lock on the machine, or
        the machine's state will eventually be set to "Aborted".

        To change settings on a machine, the following sequence is typically
        performed:

          * Call this method to obtain an exclusive write lock for the current session.
          * Obtain a mutable IMachine object from ISession::machine.
          * Change the settings of the machine by invoking IMachine methods.
          * Call IMachine::saveSettings.
          * Release the write lock by calling ISession::unlockMachine.

        
        :param _arg_session: Session object for which the machine will be locked.
        :param _arg_lockType: If set to @c Write, then attempt to acquire an exclusive write lock or fail. If set to @c Shared, then either acquire an exclusive write lock or establish a link to an existing session.

        Expected result codes:
        E_UNEXPECTED
          Virtual machine not registered.
        E_ACCESSDENIED
          Process not started by IMachine::launchVMProcess.
        VBOX_E_INVALID_OBJECT_STATE
          Session already open or being opened.
        VBOX_E_VM_ERROR
          Failed to assign machine to session.
        
       """
   
       req = (self.handle,)
       req += (_arg_session,)
       req += (_arg_lockType,)
       val = self.mgr.getService().IMachine_lockMachine(*req)
       
       return 

   def launchVMProcess(self, _arg_session, _arg_name, _arg_environmentChanges):
       """
        Spawns a new process that will execute the virtual machine and obtains a shared
        lock on the machine for the calling session.

        If launching the VM succeeds, the new VM process will create its own session
        and write-lock the machine for it, preventing conflicting changes from other
        processes. If the machine is already locked (because it is already running or
        because another session has a write lock), launching the VM process will therefore
        fail. Reversely, future attempts to obtain a write lock will also fail while the
        machine is running.

        The caller's session object remains separate from the session opened by the new
        VM process. It receives its own ::IConsole object which can be used
        to control machine execution, but it cannot be used to change all VM settings
        which would be available after a #lockMachine call.

        The caller must eventually release the session's shared lock by calling
        ISession::unlockMachine on the local session object once this call
        has returned. However, the session's state (see ISession::state)
        will not return to "Unlocked" until the remote session has also unlocked
        the machine (i.e. the machine has stopped running).

        Launching a VM process can take some time (a new VM is started in a new process,
        for which memory and other resources need to be set up). Because of this,
        an ::IProgress object is returned to allow the caller to wait
        for this asynchronous operation to be completed. Until then, the caller's
        session object remains in the "Unlocked" state, and its ISession::machine
        and ISession::console attributes cannot be accessed.
        It is recommended to use IProgress::waitForCompletion or
        similar calls to wait for completion. Completion is signalled when the VM
        is powered on. If launching the VM fails, error messages can be queried
        via the progress object, if available.

        The progress object will have at least 2 sub-operations. The first
        operation covers the period up to the new VM process calls powerUp.
        The subsequent operations mirror the IConsole::powerUp
        progress object. Because IConsole::powerUp may require
        some extra sub-operations, the IProgress::operationCount
        may change at the completion of operation.

        For details on the teleportation progress operation, see
        IConsole::powerUp.

        The @a environmentChanges argument is a list of strings where every string contains
        environment variable in the putenv style, i.e. "VAR=VALUE" for setting/replacing
        and "VAR" for unsetting. These environment variables will be applied to the environment
        of the VirtualBox server process. If an environment variable exists both in the server
        process and in this list, the value from this list takes precedence over the
        server's variable. If the value of the environment variable is omitted, this variable
        will be removed from the resulting environment. If the list is empty, the server
        environment is inherited by the started process as is.

        
        :param _arg_session: Client session object to which the VM process will be connected (this must be in "Unlocked" state).
        :param _arg_name: Front-end to use for the new VM process. The following are currently supported: "gui": VirtualBox Qt GUI front-end "headless": VBoxHeadless (VRDE Server) front-end "sdl": VirtualBox SDL front-end "emergencystop": reserved value, used for aborting the currently running VM or session owner. In this case the @a session parameter may be @c null (if it is non-null it isn't used in any way), and the @a progress return value will be always @c null. The operation completes immediately. "": use the per-VM default frontend if set, otherwise the global default defined in the system properties. If neither are set, the API will launch a "gui" session, which may fail if there is no windowing environment available. See and .
        :param _arg_environmentChanges: The list of putenv-style changes to the VM process environment.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        E_UNEXPECTED
          Virtual machine not registered.
        E_INVALIDARG
          Invalid session type @a type.
        VBOX_E_OBJECT_NOT_FOUND
          No machine matching @a machineId found.
        VBOX_E_INVALID_OBJECT_STATE
          Session already open or being opened.
        VBOX_E_IPRT_ERROR
          Launching process for machine failed.
        VBOX_E_VM_ERROR
          Failed to assign machine to session.
        
       """
   
       req = (self.handle,)
       req += (_arg_session,)
       req += (_arg_name,)
       req += (_arg_environmentChanges,)
       val = self.mgr.getService().IMachine_launchVMProcess(*req)
       
       return IProgress(self.mgr, val)

   def setBootOrder(self, _arg_position, _arg_device):
       """
        Puts the given device to the specified position in
        the boot order.

        To indicate that no device is associated with the given position,
        ::DeviceType_Null should be used.

        @todo setHardDiskBootOrder(), setNetworkBootOrder()

        
        :param _arg_position: Position in the boot order (@c 1 to the total number of devices the machine can boot from, as returned by ).
        :param _arg_device: The type of the device used to boot at the given position.

        Expected result codes:
        E_INVALIDARG
          Boot @a position out of range.
        E_NOTIMPL
          Booting from USB @a device currently not supported.
        
       """
   
       req = (self.handle,)
       req += (_arg_position,)
       req += (_arg_device,)
       val = self.mgr.getService().IMachine_setBootOrder(*req)
       
       return 

   def getBootOrder(self, _arg_position):
       """
        Returns the device type that occupies the specified
        position in the boot order.

        @todo [remove?]
        If the machine can have more than one device of the returned type
        (such as hard disks), then a separate method should be used to
        retrieve the individual device that occupies the given position.

        If here are no devices at the given position, then
        ::DeviceType_Null is returned.

        @todo getHardDiskBootOrder(), getNetworkBootOrder()

        
        :param _arg_position: Position in the boot order (@c 1 to the total number of devices the machine can boot from, as returned by ).
        :return: Device at the given position.
        :rtype: DeviceType

        Expected result codes:
        E_INVALIDARG
          Boot @a position out of range.
        
       """
   
       req = (self.handle,)
       req += (_arg_position,)
       val = self.mgr.getService().IMachine_getBootOrder(*req)
       
       return DeviceType(self.mgr, val)

   def attachDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_type, _arg_medium):
       """
        Attaches a device and optionally mounts a medium to the given storage
        controller (::IStorageController, identified by @a name),
        at the indicated port and device.

        This method is intended for managing storage devices in general while a
        machine is powered off. It can be used to attach and detach fixed
        and removable media. The following kind of media can be attached
        to a machine:

          * For fixed and removable media, you can pass in a medium that was
            previously opened using IVirtualBox::openMedium.
          
          * Only for storage devices supporting removable media (such as
            DVDs and floppies), you can also specify a null pointer to
            indicate an empty drive or one of the medium objects listed
            in the IHost::DVDDrives and IHost::floppyDrives
            arrays to indicate a host drive.
            For removable devices, you can also use IMachine::mountMedium
            to change the media while the machine is running.
          

        In a VM's default configuration of virtual machines, the secondary
        master of the IDE controller is used for a CD/DVD drive.

        After calling this returns successfully, a new instance of
        ::IMediumAttachment will appear in the machine's list of medium
        attachments (see IMachine::mediumAttachments).

        See ::IMedium and ::IMediumAttachment for more
        information about attaching media.

        The specified device slot must not have a device attached to it,
        or this method will fail.

        
        :param _arg_name: Name of the storage controller to attach the device to.
        :param _arg_controllerPort: Port to attach the device to. For an IDE controller, 0 specifies the primary controller and 1 specifies the secondary controller. For a SCSI controller, this must range from 0 to 15; for a SATA controller, from 0 to 29; for an SAS controller, from 0 to 7.
        :param _arg_device: Device slot in the given port to attach the device to. This is only relevant for IDE controllers, for which 0 specifies the master device and 1 specifies the slave device. For all other controller types, this must be 0.
        :param _arg_type: Device type of the attached device. For media opened by , this must match the device type specified there.
        :param _arg_medium: Medium to mount or @c null for an empty drive.

        Expected result codes:
        E_INVALIDARG
          SATA device, SATA port, IDE port or IDE slot out of range, or
          file or UUID not found.
        VBOX_E_INVALID_OBJECT_STATE
          Machine must be registered before media can be attached.
        VBOX_E_INVALID_VM_STATE
          Invalid machine state.
        VBOX_E_OBJECT_IN_USE
          A medium is already attached to this or another virtual machine.
        
        .. note:: 
          You cannot attach a device to a newly created machine until
          this machine's settings are saved to disk using
          #saveSettings.
        
        .. note:: 
          If the medium is being attached indirectly, a new differencing medium
          will implicitly be created for it and attached instead. If the
          changes made to the machine settings (including this indirect
          attachment) are later cancelled using #discardSettings,
          this implicitly created differencing medium will implicitly
          be deleted.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       req += (_arg_type,)
       req += (_arg_medium,)
       val = self.mgr.getService().IMachine_attachDevice(*req)
       
       return 

   def attachDeviceWithoutMedium(self, _arg_name, _arg_controllerPort, _arg_device, _arg_type):
       """
      Attaches a device and optionally mounts a medium to the given storage
      controller (::IStorageController, identified by @a name),
      at the indicated port and device.

      This method is intended for managing storage devices in general while a
      machine is powered off. It can be used to attach and detach fixed
      and removable media. The following kind of media can be attached
      to a machine:
        * 
      For fixed and removable media, you can pass in a medium that was
      previously opened using IVirtualBox::openMedium.
      
          * Only for storage devices supporting removable media (such as
      DVDs and floppies) with an empty drive or one of the medium objects listed
      in the IHost::DVDDrives and IHost::floppyDrives
      arrays to indicate a host drive.
      For removable devices, you can also use IMachine::mountMedium
      to change the media while the machine is running.
      

      In a VM's default configuration of virtual machines, the secondary
      master of the IDE controller is used for a CD/DVD drive.
      ::IMediumAttachment will appear in the machine's list of medium
      attachments (see IMachine::mediumAttachments).

      See ::IMedium and ::IMediumAttachment for more
      information about attaching media.

      The specified device slot must not have a device attached to it,
      or this method will fail.
      
        :param _arg_name: Name of the storage controller to attach the device to.
        :param _arg_controllerPort: Port to attach the device to. For an IDE controller, 0 specifies the primary controller and 1 specifies the secondary controller. For a SCSI controller, this must range from 0 to 15; for a SATA controller, from 0 to 29; for an SAS controller, from 0 to 7.
        :param _arg_device: Device slot in the given port to attach the device to. This is only relevant for IDE controllers, for which 0 specifies the master device and 1 specifies the slave device. For all other controller types, this must be 0.
        :param _arg_type: Device type of the attached device. For media opened by , this must match the device type specified there.

        Expected result codes:
        E_INVALIDARG
        SATA device, SATA port, IDE port or IDE slot out of range, or
            file or UUID not found.
      VBOX_E_INVALID_OBJECT_STATE
        Machine must be registered before media can be attached.
      VBOX_E_INVALID_VM_STATE
      Invalid machine state.
      VBOX_E_OBJECT_IN_USE
      A medium is already attached to this or another virtual machine.
      
        .. note:: 
      You cannot attach a device to a newly created machine until
      this machine's settings are saved to disk using
      #saveSettings.
      
        .. note:: 
      If the medium is being attached indirectly, a new differencing medium
      will implicitly be created for it and attached instead. If the
      changes made to the machine settings (including this indirect
      attachment) are later cancelled using #discardSettings,
      this implicitly created differencing medium will implicitly
      be deleted.
      
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       req += (_arg_type,)
       val = self.mgr.getService().IMachine_attachDeviceWithoutMedium(*req)
       
       return 

   def detachDevice(self, _arg_name, _arg_controllerPort, _arg_device):
       """
        Detaches the device attached to a device slot of the specified bus.

        Detaching the device from the virtual machine is deferred. This means
        that the medium remains associated with the machine when this method
        returns and gets actually de-associated only after a successful
        #saveSettings call. See ::IMedium
        for more detailed information about attaching media.

        
        :param _arg_name: Name of the storage controller to detach the medium from.
        :param _arg_controllerPort: Port number to detach the medium from.
        :param _arg_device: Device slot number to detach the medium from.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Attempt to detach medium from a running virtual machine.
        VBOX_E_OBJECT_NOT_FOUND
          No medium attached to given slot/bus.
        VBOX_E_NOT_SUPPORTED
          Medium format does not support storage deletion (only for implicitly
          created differencing media, should not happen).
        
        .. note:: 
          You cannot detach a device from a running machine.
        
        .. note:: 
          Detaching differencing media implicitly created by #attachDevice for the indirect attachment using this
          method will not implicitly delete them. The
          IMedium::deleteStorage operation should be
          explicitly performed by the caller after the medium is successfully
          detached and the settings are saved with
          #saveSettings, if it is the desired action.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       val = self.mgr.getService().IMachine_detachDevice(*req)
       
       return 

   def passthroughDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_passthrough):
       """
        Sets the passthrough mode of an existing DVD device. Changing the
        setting while the VM is running is forbidden. The setting is only used
        if at VM start the device is configured as a host DVD drive, in all
        other cases it is ignored. The device must already exist; see
        IMachine::attachDevice for how to attach a new device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with IMachine::attachDevice.

        
        :param _arg_name: Name of the storage controller.
        :param _arg_controllerPort: Storage controller port.
        :param _arg_device: Device slot in the given port.
        :param _arg_passthrough: New value for the passthrough setting.

        Expected result codes:
        E_INVALIDARG
          SATA device, SATA port, IDE port or IDE slot out of range.
        VBOX_E_INVALID_OBJECT_STATE
          Attempt to modify an unregistered virtual machine.
        VBOX_E_INVALID_VM_STATE
          Invalid machine state.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       req += (_arg_passthrough,)
       val = self.mgr.getService().IMachine_passthroughDevice(*req)
       
       return 

   def temporaryEjectDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_temporaryEject):
       """
        Sets the behavior for guest-triggered medium eject. In some situations
        it is desirable that such ejects update the VM configuration, and in
        others the eject should keep the VM configuration. The device must
        already exist; see IMachine::attachDevice for how to
        attach a new device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with IMachine::attachDevice.

        
        :param _arg_name: Name of the storage controller.
        :param _arg_controllerPort: Storage controller port.
        :param _arg_device: Device slot in the given port.
        :param _arg_temporaryEject: New value for the eject behavior.

        Expected result codes:
        E_INVALIDARG
          SATA device, SATA port, IDE port or IDE slot out of range.
        VBOX_E_INVALID_OBJECT_STATE
          Attempt to modify an unregistered virtual machine.
        VBOX_E_INVALID_VM_STATE
          Invalid machine state.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       req += (_arg_temporaryEject,)
       val = self.mgr.getService().IMachine_temporaryEjectDevice(*req)
       
       return 

   def nonRotationalDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_nonRotational):
       """
        Sets a flag in the device information which indicates that the medium
        is not based on rotational technology, i.e. that the access times are
        more or less independent of the position on the medium. This may or may
        not be supported by a particular drive, and is silently ignored in the
        latter case. At the moment only hard disks (which is a misnomer in this
        context) accept this setting. Changing the setting while the VM is
        running is forbidden. The device must already exist; see
        IMachine::attachDevice for how to attach a new device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with IMachine::attachDevice.

        
        :param _arg_name: Name of the storage controller.
        :param _arg_controllerPort: Storage controller port.
        :param _arg_device: Device slot in the given port.
        :param _arg_nonRotational: New value for the non-rotational device flag.

        Expected result codes:
        E_INVALIDARG
          SATA device, SATA port, IDE port or IDE slot out of range.
        VBOX_E_INVALID_OBJECT_STATE
          Attempt to modify an unregistered virtual machine.
        VBOX_E_INVALID_VM_STATE
          Invalid machine state.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       req += (_arg_nonRotational,)
       val = self.mgr.getService().IMachine_nonRotationalDevice(*req)
       
       return 

   def setAutoDiscardForDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_discard):
       """
        Sets a flag in the device information which indicates that the medium
        supports discarding unused blocks (called trimming for SATA or unmap
        for SCSI devices) .This may or may not be supported by a particular drive,
        and is silently ignored in the latter case. At the moment only hard disks
        (which is a misnomer in this context) accept this setting. Changing the
        setting while the VM is running is forbidden. The device must already
        exist; see IMachine::attachDevice for how to attach a new
        device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with IMachine::attachDevice.

        
        :param _arg_name: Name of the storage controller.
        :param _arg_controllerPort: Storage controller port.
        :param _arg_device: Device slot in the given port.
        :param _arg_discard: New value for the discard device flag.

        Expected result codes:
        E_INVALIDARG
          SATA device, SATA port, SCSI port out of range.
        VBOX_E_INVALID_OBJECT_STATE
          Attempt to modify an unregistered virtual machine.
        VBOX_E_INVALID_VM_STATE
          Invalid machine state.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       req += (_arg_discard,)
       val = self.mgr.getService().IMachine_setAutoDiscardForDevice(*req)
       
       return 

   def setHotPluggableForDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_hotPluggable):
       """
        Sets a flag in the device information which indicates that the attached
        device is hot pluggable or not. This may or may not be supported by a
        particular controller and/or drive, and is silently ignored in the
        latter case. Changing the setting while the VM is running is forbidden.
        The device must already exist; see IMachine::attachDevice
        for how to attach a new device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with IMachine::attachDevice.

        
        :param _arg_name: Name of the storage controller.
        :param _arg_controllerPort: Storage controller port.
        :param _arg_device: Device slot in the given port.
        :param _arg_hotPluggable: New value for the hot-pluggable device flag.

        Expected result codes:
        E_INVALIDARG
          SATA device, SATA port, IDE port or IDE slot out of range.
        VBOX_E_INVALID_OBJECT_STATE
          Attempt to modify an unregistered virtual machine.
        VBOX_E_INVALID_VM_STATE
          Invalid machine state.
        VBOX_E_NOT_SUPPORTED
          Controller doesn't support hot plugging.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       req += (_arg_hotPluggable,)
       val = self.mgr.getService().IMachine_setHotPluggableForDevice(*req)
       
       return 

   def setBandwidthGroupForDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_bandwidthGroup):
       """
        Sets the bandwidth group of an existing storage device.
        The device must already exist; see IMachine::attachDevice
        for how to attach a new device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with IMachine::attachDevice.

        
        :param _arg_name: Name of the storage controller.
        :param _arg_controllerPort: Storage controller port.
        :param _arg_device: Device slot in the given port.
        :param _arg_bandwidthGroup: New value for the bandwidth group or @c null for no group.

        Expected result codes:
        E_INVALIDARG
          SATA device, SATA port, IDE port or IDE slot out of range.
        VBOX_E_INVALID_OBJECT_STATE
          Attempt to modify an unregistered virtual machine.
        VBOX_E_INVALID_VM_STATE
          Invalid machine state.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       req += (_arg_bandwidthGroup,)
       val = self.mgr.getService().IMachine_setBandwidthGroupForDevice(*req)
       
       return 

   def setNoBandwidthGroupForDevice(self, _arg_name, _arg_controllerPort, _arg_device):
       """
      Sets no bandwidth group for an existing storage device.
      The device must already exist; see IMachine::attachDevice
      for how to attach a new device.
      The @a controllerPort and @a device parameters specify the device slot and
      have have the same meaning as with IMachine::attachDevice.
      
        :param _arg_name: Name of the storage controller.
        :param _arg_controllerPort: Storage controller port.
        :param _arg_device: Device slot in the given port.

        Expected result codes:
        E_INVALIDARG
      SATA device, SATA port, IDE port or IDE slot out of range.
      VBOX_E_INVALID_OBJECT_STATE
      Attempt to modify an unregistered virtual machine.
      VBOX_E_INVALID_VM_STATE
      Invalid machine state.
      
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       val = self.mgr.getService().IMachine_setNoBandwidthGroupForDevice(*req)
       
       return 

   def unmountMedium(self, _arg_name, _arg_controllerPort, _arg_device, _arg_force):
       """
        Unmounts any currently mounted medium (::IMedium,
        identified by the given UUID @a id) to the given storage controller
        (::IStorageController, identified by @a name),
        at the indicated port and device. The device must already exist;

        This method is intended only for managing removable media, where the
        device is fixed but media is changeable at runtime (such as DVDs
        and floppies). It cannot be used for fixed media such as hard disks.

        The @a controllerPort and @a device parameters specify the device slot
        and have have the same meaning as with
        IMachine::attachDevice.

        The specified device slot must have a medium mounted, which will be
        unmounted. If there is no mounted medium it will do nothing.
        See ::IMedium for more detailed information about
        attaching/unmounting media.

        
        :param _arg_name: Name of the storage controller to unmount the medium from.
        :param _arg_controllerPort: Port to unmount the medium from.
        :param _arg_device: Device slot in the given port to unmount the medium from.
        :param _arg_force: Allows to force unmount of a medium which is locked by the device slot in the given port medium is attached to.

        Expected result codes:
        E_INVALIDARG
          SATA device, SATA port, IDE port or IDE slot out of range.
        VBOX_E_INVALID_OBJECT_STATE
          Attempt to unmount medium that is not removable - not DVD or floppy.
        VBOX_E_INVALID_VM_STATE
          Invalid machine state.
        VBOX_E_OBJECT_IN_USE
          Medium already attached to this or another virtual machine.
        VBOX_E_OBJECT_NOT_FOUND
          Medium not attached to specified port, device, controller.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       req += (_arg_force,)
       val = self.mgr.getService().IMachine_unmountMedium(*req)
       
       return 

   def mountMedium(self, _arg_name, _arg_controllerPort, _arg_device, _arg_medium, _arg_force):
       """
        Mounts a medium (::IMedium, identified
        by the given UUID @a id) to the given storage controller
        (::IStorageController, identified by @a name),
        at the indicated port and device. The device must already exist;
        see IMachine::attachDevice for how to attach a new device.

        This method is intended only for managing removable media, where the
        device is fixed but media is changeable at runtime (such as DVDs
        and floppies). It cannot be used for fixed media such as hard disks.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with IMachine::attachDevice.

        The specified device slot can have a medium mounted, which will be
        unmounted first. Specifying a zero UUID (or an empty string) for
        @a medium does just an unmount.

        See ::IMedium for more detailed information about
        attaching media.

        
        :param _arg_name: Name of the storage controller to attach the medium to.
        :param _arg_controllerPort: Port to attach the medium to.
        :param _arg_device: Device slot in the given port to attach the medium to.
        :param _arg_medium: Medium to mount or @c null for an empty drive.
        :param _arg_force: Allows to force unmount/mount of a medium which is locked by the device slot in the given port to attach the medium to.

        Expected result codes:
        E_INVALIDARG
          SATA device, SATA port, IDE port or IDE slot out of range.
        VBOX_E_INVALID_OBJECT_STATE
          Attempt to attach medium to an unregistered virtual machine.
        VBOX_E_INVALID_VM_STATE
          Invalid machine state.
        VBOX_E_OBJECT_IN_USE
          Medium already attached to this or another virtual machine.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       req += (_arg_medium,)
       req += (_arg_force,)
       val = self.mgr.getService().IMachine_mountMedium(*req)
       
       return 

   def getMedium(self, _arg_name, _arg_controllerPort, _arg_device):
       """
        Returns the virtual medium attached to a device slot of the specified
        bus.

        Note that if the medium was indirectly attached by
        #mountMedium to the given device slot then this
        method will return not the same object as passed to the
        #mountMedium call. See ::IMedium for
        more detailed information about mounting a medium.

        
        :param _arg_name: Name of the storage controller the medium is attached to.
        :param _arg_controllerPort: Port to query.
        :param _arg_device: Device slot in the given port to query.
        :return: Attached medium object.
        :rtype: IMedium

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          No medium attached to given slot/bus.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       val = self.mgr.getService().IMachine_getMedium(*req)
       
       return IMedium(self.mgr, val)

   def getMediumAttachmentsOfController(self, _arg_name):
       """
        Returns an array of medium attachments which are attached to the
        the controller with the given name.

        
        :param _arg_name: 
        :return: 
        :rtype: List[IMediumAttachment]

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          A storage controller with given name doesn't exist.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachine_getMediumAttachmentsOfController(*req)
       
       return IMediumAttachment(self.mgr, val, True)

   def getMediumAttachment(self, _arg_name, _arg_controllerPort, _arg_device):
       """
        Returns a medium attachment which corresponds to the controller with
        the given name, on the given port and device slot.

        
        :param _arg_name: 
        :param _arg_controllerPort: 
        :param _arg_device: 
        :return: 
        :rtype: IMediumAttachment

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          No attachment exists for the given controller/port/device combination.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_controllerPort,)
       req += (_arg_device,)
       val = self.mgr.getService().IMachine_getMediumAttachment(*req)
       
       return IMediumAttachment(self.mgr, val)

   def attachHostPCIDevice(self, _arg_hostAddress, _arg_desiredGuestAddress, _arg_tryToUnbind):
       """
        Attaches host PCI device with the given (host) PCI address to the
        PCI bus of the virtual machine. Please note, that this operation
        is two phase, as real attachment will happen when VM will start,
        and most information will be delivered as IHostPCIDevicePlugEvent
        on IVirtualBox event source.

        
        :param _arg_hostAddress: Address of the host PCI device.
        :param _arg_desiredGuestAddress: Desired position of this device on guest PCI bus.
        :param _arg_tryToUnbind: If VMM shall try to unbind existing drivers from the device before attaching it to the guest.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine state is not stopped (PCI hotplug not yet implemented).
        VBOX_E_PDM_ERROR
          Virtual machine does not have a PCI controller allowing attachment of physical devices.
        VBOX_E_NOT_SUPPORTED
          Hardware or host OS doesn't allow PCI device passthrough.
        
       """
   
       req = (self.handle,)
       req += (_arg_hostAddress,)
       req += (_arg_desiredGuestAddress,)
       req += (_arg_tryToUnbind,)
       val = self.mgr.getService().IMachine_attachHostPCIDevice(*req)
       
       return 

   def detachHostPCIDevice(self, _arg_hostAddress):
       """
        Detach host PCI device from the virtual machine.
        Also HostPCIDevicePlugEvent on IVirtualBox event source
        will be delivered. As currently we don't support hot device
        unplug, IHostPCIDevicePlugEvent event is delivered immediately.

        
        :param _arg_hostAddress: Address of the host PCI device.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine state is not stopped (PCI hotplug not yet implemented).
        VBOX_E_OBJECT_NOT_FOUND
          This host device is not attached to this machine.
        VBOX_E_PDM_ERROR
          Virtual machine does not have a PCI controller allowing attachment of physical devices.
        VBOX_E_NOT_SUPPORTED
          Hardware or host OS doesn't allow PCI device passthrough.
        
       """
   
       req = (self.handle,)
       req += (_arg_hostAddress,)
       val = self.mgr.getService().IMachine_detachHostPCIDevice(*req)
       
       return 

   def getNetworkAdapter(self, _arg_slot):
       """
        Returns the network adapter associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of adapters per machine is defined by the
        ISystemProperties::getMaxNetworkAdapters property,
        so the maximum slot number is one less than that property's value.

        
        :param _arg_slot: 
        :return: 
        :rtype: INetworkAdapter

        Expected result codes:
        E_INVALIDARG
          Invalid @a slot number.
        
       """
   
       req = (self.handle,)
       req += (_arg_slot,)
       val = self.mgr.getService().IMachine_getNetworkAdapter(*req)
       
       return INetworkAdapter(self.mgr, val)

   def addStorageController(self, _arg_name, _arg_connectionType):
       """
        Adds a new storage controller (SCSI, SAS or SATA controller) to the
        machine and returns it as an instance of
        ::IStorageController.

        @a name identifies the controller for subsequent calls such as
        #getStorageControllerByName,
        #getStorageControllerByInstance,
        #removeStorageController,
        #attachDevice or #mountMedium.

        After the controller has been added, you can set its exact
        type by setting the IStorageController::controllerType.

        
        :param _arg_name: 
        :param _arg_connectionType: 
        :return: 
        :rtype: IStorageController

        Expected result codes:
        VBOX_E_OBJECT_IN_USE
          A storage controller with given name exists already.
        E_INVALIDARG
          Invalid @a controllerType.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_connectionType,)
       val = self.mgr.getService().IMachine_addStorageController(*req)
       
       return IStorageController(self.mgr, val)

   def getStorageControllerByName(self, _arg_name):
       """
        Returns a storage controller with the given name.

        
        :param _arg_name: 
        :return: 
        :rtype: IStorageController

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          A storage controller with given name doesn't exist.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachine_getStorageControllerByName(*req)
       
       return IStorageController(self.mgr, val)

   def getStorageControllerByInstance(self, _arg_connectionType, _arg_instance):
       """
        Returns a storage controller of a specific storage bus
        with the given instance number.

        
        :param _arg_connectionType: 
        :param _arg_instance: 
        :return: 
        :rtype: IStorageController

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          A storage controller with given instance number doesn't exist.
        
       """
   
       req = (self.handle,)
       req += (_arg_connectionType,)
       req += (_arg_instance,)
       val = self.mgr.getService().IMachine_getStorageControllerByInstance(*req)
       
       return IStorageController(self.mgr, val)

   def removeStorageController(self, _arg_name):
       """
        Removes a storage controller from the machine with all devices attached to it.

        
        :param _arg_name: 

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          A storage controller with given name doesn't exist.
        VBOX_E_NOT_SUPPORTED
          Medium format does not support storage deletion (only for implicitly
          created differencing media, should not happen).
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachine_removeStorageController(*req)
       
       return 

   def setStorageControllerBootable(self, _arg_name, _arg_bootable):
       """
        Sets the bootable flag of the storage controller with the given name.

        
        :param _arg_name: 
        :param _arg_bootable: 

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          A storage controller with given name doesn't exist.
        VBOX_E_OBJECT_IN_USE
          Another storage controller is marked as bootable already.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_bootable,)
       val = self.mgr.getService().IMachine_setStorageControllerBootable(*req)
       
       return 

   def addUSBController(self, _arg_name, _arg_type):
       """
        Adds a new USB controller to the machine and returns it as an instance of
        ::IUSBController.

        
        :param _arg_name: 
        :param _arg_type: 
        :return: 
        :rtype: IUSBController

        Expected result codes:
        VBOX_E_OBJECT_IN_USE
          A USB controller with given type exists already.
        E_INVALIDARG
          Invalid @a controllerType.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_type,)
       val = self.mgr.getService().IMachine_addUSBController(*req)
       
       return IUSBController(self.mgr, val)

   def removeUSBController(self, _arg_name):
       """
        Removes a USB controller from the machine.

        
        :param _arg_name: 

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          A USB controller with given type doesn't exist.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachine_removeUSBController(*req)
       
       return 

   def getUSBControllerByName(self, _arg_name):
       """
        Returns a USB controller with the given type.

        
        :param _arg_name: 
        :return: 
        :rtype: IUSBController

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          A USB controller with given name doesn't exist.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachine_getUSBControllerByName(*req)
       
       return IUSBController(self.mgr, val)

   def getUSBControllerCountByType(self, _arg_type):
       """
        Returns the number of USB controllers of the given type attached to the VM.
      
        :param _arg_type: 
        :return: 
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_type,)
       val = self.mgr.getService().IMachine_getUSBControllerCountByType(*req)
       
       return UnsignedInt(self.mgr, val)

   def getSerialPort(self, _arg_slot):
       """
        Returns the serial port associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of serial ports per machine is defined by the
        ISystemProperties::serialPortCount property,
        so the maximum slot number is one less than that property's value.

        
        :param _arg_slot: 
        :return: 
        :rtype: ISerialPort

        Expected result codes:
        E_INVALIDARG
          Invalid @a slot number.
        
       """
   
       req = (self.handle,)
       req += (_arg_slot,)
       val = self.mgr.getService().IMachine_getSerialPort(*req)
       
       return ISerialPort(self.mgr, val)

   def getParallelPort(self, _arg_slot):
       """
        Returns the parallel port associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of parallel ports per machine is defined by the
        ISystemProperties::parallelPortCount property,
        so the maximum slot number is one less than that property's value.

        
        :param _arg_slot: 
        :return: 
        :rtype: IParallelPort

        Expected result codes:
        E_INVALIDARG
          Invalid @a slot number.
        
       """
   
       req = (self.handle,)
       req += (_arg_slot,)
       val = self.mgr.getService().IMachine_getParallelPort(*req)
       
       return IParallelPort(self.mgr, val)

   def getExtraDataKeys(self):
       """
            Returns an array representing the machine-specific extra data keys
            which currently have values defined.
        
        :return: Array of extra data keys.
        :rtype: List[wstring]

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMachine_getExtraDataKeys(*req)
       
       return String(self.mgr, val, True)

   def getExtraData(self, _arg_key):
       """
        Returns associated machine-specific extra data.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

        
        :param _arg_key: Name of the data key to get.
        :return: Value of the requested data key.
        :rtype: wstring

        Expected result codes:
        VBOX_E_FILE_ERROR
          Settings file not accessible.
        VBOX_E_XML_ERROR
          Could not parse the settings file.
        
       """
   
       req = (self.handle,)
       req += (_arg_key,)
       val = self.mgr.getService().IMachine_getExtraData(*req)
       
       return String(self.mgr, val)

   def setExtraData(self, _arg_key, _arg_value):
       """
        Sets associated machine-specific extra data.

        If you pass @c null or an empty string as a key @a value, the given
        @a key will be deleted.

        
        :param _arg_key: Name of the data key to set.
        :param _arg_value: Value to assign to the key.

        Expected result codes:
        VBOX_E_FILE_ERROR
          Settings file not accessible.
        VBOX_E_XML_ERROR
          Could not parse the settings file.
        E_INVALIDARG
          Key contains invalid characters.
        
        .. note:: 
          Key must contain printable (non-control) UTF-8 characters only.
        
        .. note:: 
          Before performing the actual data change, this method will ask all
          registered event listeners using the
          ::IExtraDataCanChangeEvent
          notification for a permission. If one of the listeners refuses the
          new value, the change will not be performed.
        
        .. note:: 
          On success, the
          ::IExtraDataChangedEvent notification
          is called to inform all registered listeners about a successful data
          change.
        
        .. note:: 
          This method can be called outside the machine session and therefore
          it's a caller's responsibility to handle possible race conditions
          when several clients change the same key at the same time.
        
       """
   
       req = (self.handle,)
       req += (_arg_key,)
       req += (_arg_value,)
       val = self.mgr.getService().IMachine_setExtraData(*req)
       
       return 

   def getCPUProperty(self, _arg_property):
       """
        Returns the virtual CPU boolean value of the specified property.

        
        :param _arg_property: Property type to query.
        :return: Property value.
        :rtype: boolean

        Expected result codes:
        E_INVALIDARG
          Invalid property.
        
       """
   
       req = (self.handle,)
       req += (_arg_property,)
       val = self.mgr.getService().IMachine_getCPUProperty(*req)
       
       return Boolean(self.mgr, val)

   def setCPUProperty(self, _arg_property, _arg_value):
       """
        Sets the virtual CPU boolean value of the specified property.

        
        :param _arg_property: Property type to query.
        :param _arg_value: Property value.

        Expected result codes:
        E_INVALIDARG
          Invalid property.
        
       """
   
       req = (self.handle,)
       req += (_arg_property,)
       req += (_arg_value,)
       val = self.mgr.getService().IMachine_setCPUProperty(*req)
       
       return 

   def getCPUIDLeafByOrdinal(self, _arg_ordinal):
       """
        Used to enumerate CPUID information override values.

        
        :param _arg_ordinal: The ordinal number of the leaf to get.







        Expected result codes:
        E_INVALIDARG
          Invalid ordinal number is out of range.
        
       """
   
       req = (self.handle,)
       req += (_arg_ordinal,)
       val = self.mgr.getService().IMachine_getCPUIDLeafByOrdinal(*req)
       
       return UnsignedInt(self.mgr,val["idx"]), UnsignedInt(self.mgr,val["idxSub"]), UnsignedInt(self.mgr,val["valEax"]), UnsignedInt(self.mgr,val["valEbx"]), UnsignedInt(self.mgr,val["valEcx"]), UnsignedInt(self.mgr,val["valEdx"])

   def getCPUIDLeaf(self, _arg_idx, _arg_idxSub):
       """
        Returns the virtual CPU cpuid information for the specified leaf.

        Currently supported index values for cpuid:
        Standard CPUID leaves: 0 - 0x1f
        Extended CPUID leaves: 0x80000000 - 0x8000001f
        VIA CPUID leaves:      0xc0000000 - 0xc000000f

        See the Intel, AMD and VIA programmer's manuals for detailed information
        about the CPUID instruction and its leaves.
        
        :param _arg_idx: CPUID leaf index.
        :param _arg_idxSub: CPUID leaf sub-index (ECX). Set to 0xffffffff (or 0) if not applicable.





        Expected result codes:
        E_INVALIDARG
          Invalid index.
        
       """
   
       req = (self.handle,)
       req += (_arg_idx,)
       req += (_arg_idxSub,)
       val = self.mgr.getService().IMachine_getCPUIDLeaf(*req)
       
       return UnsignedInt(self.mgr,val["valEax"]), UnsignedInt(self.mgr,val["valEbx"]), UnsignedInt(self.mgr,val["valEcx"]), UnsignedInt(self.mgr,val["valEdx"])

   def setCPUIDLeaf(self, _arg_idx, _arg_idxSub, _arg_valEax, _arg_valEbx, _arg_valEcx, _arg_valEdx):
       """
        Sets the virtual CPU cpuid information for the specified leaf. Note that these values
        are not passed unmodified. VirtualBox clears features that it doesn't support.

        Currently supported index values for cpuid:
        Standard CPUID leaves: 0 - 0x1f
        Extended CPUID leaves: 0x80000000 - 0x8000001f
        VIA CPUID leaves:      0xc0000000 - 0xc000000f

        The subleaf index is only applicable to certain leaves (see manuals as this is
        subject to change).

        See the Intel, AMD and VIA programmer's manuals for detailed information
        about the cpuid instruction and its leaves.

        Do not use this method unless you know exactly what you're doing. Misuse can lead to
        random crashes inside VMs.
        
        :param _arg_idx: CPUID leaf index.
        :param _arg_idxSub: CPUID leaf sub-index (ECX). Set to 0xffffffff (or 0) if not applicable. The 0xffffffff causes it to remove all other subleaves before adding one with sub-index 0.
        :param _arg_valEax: CPUID leaf value for register eax.
        :param _arg_valEbx: CPUID leaf value for register ebx.
        :param _arg_valEcx: CPUID leaf value for register ecx.
        :param _arg_valEdx: CPUID leaf value for register edx.

        Expected result codes:
        E_INVALIDARG
          Invalid index.
        
       """
   
       req = (self.handle,)
       req += (_arg_idx,)
       req += (_arg_idxSub,)
       req += (_arg_valEax,)
       req += (_arg_valEbx,)
       req += (_arg_valEcx,)
       req += (_arg_valEdx,)
       val = self.mgr.getService().IMachine_setCPUIDLeaf(*req)
       
       return 

   def removeCPUIDLeaf(self, _arg_idx, _arg_idxSub):
       """
        Removes the virtual CPU cpuid leaf for the specified index

        
        :param _arg_idx: CPUID leaf index.
        :param _arg_idxSub: CPUID leaf sub-index (ECX). Set to 0xffffffff (or 0) if not applicable. The 0xffffffff value works like a wildcard.

        Expected result codes:
        E_INVALIDARG
          Invalid index.
        
       """
   
       req = (self.handle,)
       req += (_arg_idx,)
       req += (_arg_idxSub,)
       val = self.mgr.getService().IMachine_removeCPUIDLeaf(*req)
       
       return 

   def removeAllCPUIDLeaves(self):
       """
        Removes all the virtual CPU cpuid leaves
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMachine_removeAllCPUIDLeaves(*req)
       
       return 

   def getHWVirtExProperty(self, _arg_property):
       """
        Returns the value of the specified hardware virtualization boolean property.

        
        :param _arg_property: Property type to query.
        :return: Property value.
        :rtype: boolean

        Expected result codes:
        E_INVALIDARG
          Invalid property.
        
       """
   
       req = (self.handle,)
       req += (_arg_property,)
       val = self.mgr.getService().IMachine_getHWVirtExProperty(*req)
       
       return Boolean(self.mgr, val)

   def setHWVirtExProperty(self, _arg_property, _arg_value):
       """
        Sets a new value for the specified hardware virtualization boolean property.

        
        :param _arg_property: Property type to set.
        :param _arg_value: New property value.

        Expected result codes:
        E_INVALIDARG
          Invalid property.
        
       """
   
       req = (self.handle,)
       req += (_arg_property,)
       req += (_arg_value,)
       val = self.mgr.getService().IMachine_setHWVirtExProperty(*req)
       
       return 

   def setSettingsFilePath(self, _arg_settingsFilePath):
       """
        Currently, it is an error to change this property on any machine.
        Later this will allow setting a new path for the settings file, with
        automatic relocation of all files (including snapshots and disk images)
        which are inside the base directory. This operation is only allowed
        when there are no pending unsaved settings.

        
        :param _arg_settingsFilePath: New settings file path, will be used to determine the new location for the attached media if it is in the same directory or below as the original settings file.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        E_NOTIMPL
          The operation is not implemented yet.
        
        .. note:: 
          Setting this property to @c null or to an empty string is forbidden.
          When setting this property, the specified path must be absolute.
          The specified path may not exist, it will be created when necessary.
        
       """
   
       req = (self.handle,)
       req += (_arg_settingsFilePath,)
       val = self.mgr.getService().IMachine_setSettingsFilePath(*req)
       
       return IProgress(self.mgr, val)

   def saveSettings(self):
       """
        Saves any changes to machine settings made since the session
        has been opened or a new machine has been created, or since the
        last call to #saveSettings or #discardSettings.
        For registered machines, new settings become visible to all
        other VirtualBox clients after successful invocation of this
        method.
        

        Expected result codes:
        VBOX_E_FILE_ERROR
          Settings file not accessible.
        VBOX_E_XML_ERROR
          Could not parse the settings file.
        E_ACCESSDENIED
          Modification request refused.
        
        .. note:: 
          The method sends ::IMachineDataChangedEvent
          notification event after the configuration has been successfully
          saved (only for registered machines).
        
        .. note:: 
          Calling this method is only valid on instances returned
          by ISession::machine and on new machines
          created by IVirtualBox::createMachine but not
          yet registered, or on unregistered machines after calling
          IMachine::unregister.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMachine_saveSettings(*req)
       
       return 

   def discardSettings(self):
       """
        Discards any changes to the machine settings made since the session
        has been opened or since the last call to #saveSettings
        or #discardSettings.
        

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine is not mutable.
        
        .. note:: 
          Calling this method is only valid on instances returned
          by ISession::machine and on new machines
          created by IVirtualBox::createMachine or
          opened by IVirtualBox::openMachine but not
          yet registered, or on unregistered machines after calling
          IMachine::unregister.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMachine_discardSettings(*req)
       
       return 

   def unregister(self, _arg_cleanupMode):
       """
        Unregisters a machine previously registered with
        IVirtualBox::registerMachine and optionally do additional
        cleanup before the machine is unregistered.

        This method does not delete any files. It only changes the machine configuration and
        the list of registered machines in the VirtualBox object. To delete the files which
        belonged to the machine, including the XML file of the machine itself, call
        #deleteConfig, optionally with the array of IMedium objects which was returned
        from this method.

        How thoroughly this method cleans up the machine configuration before unregistering
        the machine depends on the @a cleanupMode argument.

          * With "UnregisterOnly", the machine will only be unregistered, but no additional
            cleanup will be performed. The call will fail if the machine is in "Saved" state
            or has any snapshots or any media attached (see ::IMediumAttachment).
            It is the responsibility of the caller to delete all such configuration in this mode.
            In this mode, the API behaves like the former @c IVirtualBox::unregisterMachine() API
            which it replaces.
          * With "DetachAllReturnNone", the call will succeed even if the machine is in "Saved"
            state or if it has snapshots or media attached. All media attached to the current machine
            state or in snapshots will be detached. No medium objects will be returned;
            all of the machine's media will remain open.
          * With "DetachAllReturnHardDisksOnly", the call will behave like with "DetachAllReturnNone",
            except that all the hard disk medium objects which were detached from the machine will
            be returned as an array. This allows for quickly passing them to the #deleteConfig
            API for closing and deletion.
          * With "Full", the call will behave like with "DetachAllReturnHardDisksOnly", except
            that all media will be returned in the array, including removable media like DVDs and
            floppies. This might be useful if the user wants to inspect in detail which media were
            attached to the machine. Be careful when passing the media array to #deleteConfig
            in that case because users will typically want to preserve ISO and RAW image files.

        A typical implementation will use "DetachAllReturnHardDisksOnly" and then pass the
        resulting IMedium array to #deleteConfig. This way, the machine is completely
        deleted with all its saved states and hard disk images, but images for removable
        drives (such as ISO and RAW files) will remain on disk.

        This API does not verify whether the media files returned in the array are still
        attached to other machines (i.e. shared between several machines). If such a shared
        image is passed to #deleteConfig however, closing the image will fail there
        and the image will be silently skipped.

        This API may, however, move media from this machine's media registry to other media
        registries (see ::IMedium for details on media registries). For machines
        created with VirtualBox 4.0 or later, if media from this machine's media registry
        are also attached to another machine (shared attachments), each such medium will be
        moved to another machine's registry. This is because without this machine's media
        registry, the other machine cannot find its media any more and would become inaccessible.

        This API implicitly calls #saveSettings to save all current machine settings
        before unregistering it. It may also silently call #saveSettings on other machines
        if media are moved to other machines' media registries.

        After successful method invocation, the ::IMachineRegisteredEvent event
        is fired.

        The call will fail if the machine is currently locked (see ::ISession).

        
        :param _arg_cleanupMode: How to clean up after the machine has been unregistered.
        :return: List of media detached from the machine, depending on the @a cleanupMode parameter.
        :rtype: List[IMedium]

        Expected result codes:
        VBOX_E_INVALID_OBJECT_STATE
          Machine is currently locked for a session.
        
        .. note:: 
          If the given machine is inaccessible (see #accessible), it
          will be unregistered and fully uninitialized right afterwards. As a result,
          the returned machine object will be unusable and an attempt to call
          any method will return the "Object not ready" error.
        
       """
   
       req = (self.handle,)
       req += (_arg_cleanupMode,)
       val = self.mgr.getService().IMachine_unregister(*req)
       
       return IMedium(self.mgr, val, True)

   def deleteConfig(self, _arg_media):
       """
        Deletes the files associated with this machine from disk. If medium objects are passed
        in with the @a aMedia argument, they are closed and, if closing was successful, their
        storage files are deleted as well. For convenience, this array of media files can be
        the same as the one returned from a previous #unregister call.

        This method must only be called on machines which are either write-locked (i.e. on instances
        returned by ISession::machine) or on unregistered machines (i.e. not yet
        registered machines created by IVirtualBox::createMachine or opened by
        IVirtualBox::openMachine, or after having called #unregister).

        The following files will be deleted by this method:
          * If #unregister had been previously called with a @a cleanupMode
            argument other than "UnregisterOnly", this will delete all saved state files that
            the machine had in use; possibly one if the machine was in "Saved" state and one
            for each online snapshot that the machine had.
          * On each medium object passed in the @a aMedia array, this will call
            IMedium::close. If that succeeds, this will attempt to delete the
            medium's storage on disk. Since the IMedium::close call will fail if the medium is still
            in use, e.g. because it is still attached to a second machine; in that case the
            storage will not be deleted.
          * Finally, the machine's own XML file will be deleted.

        Since deleting large disk image files can be a time-consuming I/O operation, this
        method operates asynchronously and returns an IProgress object to allow the caller
        to monitor the progress. There will be one sub-operation for each file that is
        being deleted (saved state or medium storage file).

        
        :param _arg_media: List of media to be closed and whose storage files will be deleted.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Machine is registered but not write-locked.
        VBOX_E_IPRT_ERROR
          Could not delete the settings file.
        
        .. note:: #settingsModified will return @c true after this
          method successfully returns.
        
       """
   
       req = (self.handle,)
       req += (_arg_media,)
       val = self.mgr.getService().IMachine_deleteConfig(*req)
       
       return IProgress(self.mgr, val)

   def exportTo(self, _arg_appliance, _arg_location):
       """Exports the machine to an OVF appliance. See ::IAppliance for the
            steps required to export VirtualBox machines to OVF.
      
        :param _arg_appliance: Appliance to export this machine to.
        :param _arg_location: The target location.
        :return: VirtualSystemDescription object which is created for this machine.
        :rtype: IVirtualSystemDescription

       """
   
       req = (self.handle,)
       req += (_arg_appliance,)
       req += (_arg_location,)
       val = self.mgr.getService().IMachine_exportTo(*req)
       
       return IVirtualSystemDescription(self.mgr, val)

   def findSnapshot(self, _arg_nameOrId):
       """
        Returns a snapshot of this machine with the given name or UUID.

        Returns a snapshot of this machine with the given UUID.
        A @c null argument can be used to obtain the first snapshot
        taken on this machine. To traverse the whole tree of snapshots
        starting from the root, inspect the root snapshot's
        ISnapshot::children attribute and recurse over those children.

        
        :param _arg_nameOrId: What to search for. Name or UUID of the snapshot to find
        :return: Snapshot object with the given name.
        :rtype: ISnapshot

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Virtual machine has no snapshots or snapshot not found.
        
       """
   
       req = (self.handle,)
       req += (_arg_nameOrId,)
       val = self.mgr.getService().IMachine_findSnapshot(*req)
       
       return ISnapshot(self.mgr, val)

   def createSharedFolder(self, _arg_name, _arg_hostPath, _arg_writable, _arg_automount, _arg_autoMountPoint):
       """
        Creates a new permanent shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        ::ISharedFolder to read more about logical names.

        
        :param _arg_name: Unique logical name of the shared folder.
        :param _arg_hostPath: Full path to the shared folder in the host file system.
        :param _arg_writable: Whether the share is writable or read-only.
        :param _arg_automount: Whether the share gets automatically mounted by the guest or not.
        :param _arg_autoMountPoint: Where the guest should automatically mount the folder, if possible. For Windows and OS/2 guests this should be a drive letter, while other guests it should be a absolute directory.

        Expected result codes:
        VBOX_E_OBJECT_IN_USE
          Shared folder already exists.
        VBOX_E_FILE_ERROR
          Shared folder @a hostPath not accessible.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_hostPath,)
       req += (_arg_writable,)
       req += (_arg_automount,)
       req += (_arg_autoMountPoint,)
       val = self.mgr.getService().IMachine_createSharedFolder(*req)
       
       return 

   def removeSharedFolder(self, _arg_name):
       """
        Removes the permanent shared folder with the given name previously
        created by #createSharedFolder from the collection of
        shared folders and stops sharing it.

        
        :param _arg_name: Logical name of the shared folder to remove.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine is not mutable.
        VBOX_E_OBJECT_NOT_FOUND
          Shared folder @a name does not exist.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachine_removeSharedFolder(*req)
       
       return 

   def canShowConsoleWindow(self):
       """
        Returns @c true if the VM console process can activate the
        console window and bring it to foreground on the desktop of
        the host PC.
        
        :return: @c true if the console window can be shown and @c false otherwise.
        :rtype: boolean

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Machine session is not open.
        
        .. note:: 
          This method will fail if a session for this machine is not
          currently open.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMachine_canShowConsoleWindow(*req)
       
       return Boolean(self.mgr, val)

   def showConsoleWindow(self):
       """
        Activates the console window and brings it to foreground on
        the desktop of the host PC. Many modern window managers on
        many platforms implement some sort of focus stealing
        prevention logic, so that it may be impossible to activate
        a window without the help of the currently active
        application. In this case, this method will return a non-zero
        identifier that represents the top-level window of the VM
        console process. The caller, if it represents a currently
        active process, is responsible to use this identifier (in a
        platform-dependent manner) to perform actual window
        activation.
        
        :return: Platform-dependent identifier of the top-level VM console window, or zero if this method has performed all actions necessary to implement the show window semantics for the given platform and/or VirtualBox front-end.
        :rtype: long long

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Machine session is not open.
        
        .. note:: 
          This method will fail if a session for this machine is not
          currently open.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMachine_showConsoleWindow(*req)
       
       return Long(self.mgr, val)

   def getGuestProperty(self, _arg_name):
       """
        Reads an entry from the machine's guest property store.

        
        :param _arg_name: The name of the property to read.




        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Machine session is not open.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachine_getGuestProperty(*req)
       
       return String(self.mgr,val["value"]), Long(self.mgr,val["timestamp"]), String(self.mgr,val["flags"])

   def getGuestPropertyValue(self, _arg_property):
       """
        Reads a value from the machine's guest property store.

        
        :param _arg_property: The name of the property to read.
        :return: The value of the property. If the property does not exist then this will be empty.
        :rtype: wstring

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Machine session is not open.
        
       """
   
       req = (self.handle,)
       req += (_arg_property,)
       val = self.mgr.getService().IMachine_getGuestPropertyValue(*req)
       
       return String(self.mgr, val)

   def getGuestPropertyTimestamp(self, _arg_property):
       """
        Reads a property timestamp from the machine's guest property store.

        
        :param _arg_property: The name of the property to read.
        :return: The timestamp. If the property does not exist then this will be empty.
        :rtype: long long

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Machine session is not open.
        
       """
   
       req = (self.handle,)
       req += (_arg_property,)
       val = self.mgr.getService().IMachine_getGuestPropertyTimestamp(*req)
       
       return Long(self.mgr, val)

   def setGuestProperty(self, _arg_property, _arg_value, _arg_flags):
       """
        Sets, changes or deletes an entry in the machine's guest property
        store.

        
        :param _arg_property: The name of the property to set, change or delete.
        :param _arg_value: The new value of the property to set, change or delete. If the property does not yet exist and value is non-empty, it will be created. If the value is @c null or empty, the property will be deleted if it exists.
        :param _arg_flags: Additional property parameters, passed as a comma-separated list of "name=value" type entries.

        Expected result codes:
        E_ACCESSDENIED
          Property cannot be changed.
        E_INVALIDARG
          Invalid @a flags.
        VBOX_E_INVALID_VM_STATE
          Virtual machine is not mutable or session not open.
        VBOX_E_INVALID_OBJECT_STATE
          Cannot set transient property when machine not running.
        
       """
   
       req = (self.handle,)
       req += (_arg_property,)
       req += (_arg_value,)
       req += (_arg_flags,)
       val = self.mgr.getService().IMachine_setGuestProperty(*req)
       
       return 

   def setGuestPropertyValue(self, _arg_property, _arg_value):
       """
        Sets or changes a value in the machine's guest property
        store. The flags field will be left unchanged or created empty for a
        new property.

        
        :param _arg_property: The name of the property to set or change.
        :param _arg_value: The new value of the property to set or change. If the property does not yet exist and value is non-empty, it will be created.

        Expected result codes:
        E_ACCESSDENIED
          Property cannot be changed.
        VBOX_E_INVALID_VM_STATE
          Virtual machine is not mutable or session not open.
        VBOX_E_INVALID_OBJECT_STATE
          Cannot set transient property when machine not running.
        
       """
   
       req = (self.handle,)
       req += (_arg_property,)
       req += (_arg_value,)
       val = self.mgr.getService().IMachine_setGuestPropertyValue(*req)
       
       return 

   def deleteGuestProperty(self, _arg_name):
       """
        Deletes an entry from the machine's guest property store.

        
        :param _arg_name: The name of the property to delete.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Machine session is not open.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachine_deleteGuestProperty(*req)
       
       return 

   def enumerateGuestProperties(self, _arg_patterns):
       """
        Return a list of the guest properties matching a set of patterns along
        with their values, timestamps and flags.
      
        :param _arg_patterns: The patterns to match the properties against, separated by '|' characters. If this is empty or @c null, all properties will match.





       """
   
       req = (self.handle,)
       req += (_arg_patterns,)
       val = self.mgr.getService().IMachine_enumerateGuestProperties(*req)
       
       return String(self.mgr,val["names"], True), String(self.mgr,val["values"], True), Long(self.mgr,val["timestamps"], True), String(self.mgr,val["flags"], True)

   def querySavedGuestScreenInfo(self, _arg_screenId):
       """
        Returns the guest dimensions from the saved state.
      
        :param _arg_screenId: Saved guest screen to query info from.






       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       val = self.mgr.getService().IMachine_querySavedGuestScreenInfo(*req)
       
       return UnsignedInt(self.mgr,val["originX"]), UnsignedInt(self.mgr,val["originY"]), UnsignedInt(self.mgr,val["width"]), UnsignedInt(self.mgr,val["height"]), Boolean(self.mgr,val["enabled"])

   def readSavedThumbnailToArray(self, _arg_screenId, _arg_bitmapFormat):
       """
        Thumbnail is retrieved to an array of bytes in the requested format.
      
        :param _arg_screenId: Saved guest screen to read from.
        :param _arg_bitmapFormat: The requested format.


        :return: Array with resulting bitmap data.
        :rtype: List[octet]

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_bitmapFormat,)
       val = self.mgr.getService().IMachine_readSavedThumbnailToArray(*req)
       
       return self.mgr.decodebase64(val["returnval"]), UnsignedInt(self.mgr,val["width"]), UnsignedInt(self.mgr,val["height"])

   def querySavedScreenshotInfo(self, _arg_screenId):
       """
        Returns available formats and size of the screenshot from saved state.
      
        :param _arg_screenId: Saved guest screen to query info from.


        :return: Formats supported by readSavedScreenshotToArray.
        :rtype: List[BitmapFormat]

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       val = self.mgr.getService().IMachine_querySavedScreenshotInfo(*req)
       
       return BitmapFormat(self.mgr,val["returnval"], True), UnsignedInt(self.mgr,val["width"]), UnsignedInt(self.mgr,val["height"])

   def readSavedScreenshotToArray(self, _arg_screenId, _arg_bitmapFormat):
       """
        Screenshot in requested format is retrieved to an array of bytes.
      
        :param _arg_screenId: Saved guest screen to read from.
        :param _arg_bitmapFormat: The requested format.


        :return: Array with resulting image data.
        :rtype: List[octet]

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_bitmapFormat,)
       val = self.mgr.getService().IMachine_readSavedScreenshotToArray(*req)
       
       return self.mgr.decodebase64(val["returnval"]), UnsignedInt(self.mgr,val["width"]), UnsignedInt(self.mgr,val["height"])

   def hotPlugCPU(self, _arg_cpu):
       """
        Plugs a CPU into the machine.
      
        :param _arg_cpu: The CPU id to insert.

       """
   
       req = (self.handle,)
       req += (_arg_cpu,)
       val = self.mgr.getService().IMachine_hotPlugCPU(*req)
       
       return 

   def hotUnplugCPU(self, _arg_cpu):
       """
        Removes a CPU from the machine.
      
        :param _arg_cpu: The CPU id to remove.

       """
   
       req = (self.handle,)
       req += (_arg_cpu,)
       val = self.mgr.getService().IMachine_hotUnplugCPU(*req)
       
       return 

   def getCPUStatus(self, _arg_cpu):
       """
        Returns the current status of the given CPU.
      
        :param _arg_cpu: The CPU id to check for.
        :return: Status of the CPU.
        :rtype: boolean

       """
   
       req = (self.handle,)
       req += (_arg_cpu,)
       val = self.mgr.getService().IMachine_getCPUStatus(*req)
       
       return Boolean(self.mgr, val)

   def getEffectiveParavirtProvider(self):
       """
        Returns the effective paravirtualization provider for this VM.
      
        :return: The effective paravirtualization provider for this VM.
        :rtype: ParavirtProvider

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMachine_getEffectiveParavirtProvider(*req)
       
       return ParavirtProvider(self.mgr, val)

   def queryLogFilename(self, _arg_idx):
       """
        Queries for the VM log file name of an given index. Returns an empty
        string if a log file with that index doesn't exists.
      
        :param _arg_idx: Which log file name to query. 0=current log file.
        :return: On return the full path to the log file or an empty string on error.
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_idx,)
       val = self.mgr.getService().IMachine_queryLogFilename(*req)
       
       return String(self.mgr, val)

   def readLog(self, _arg_idx, _arg_offset, _arg_size):
       """
        Reads the VM log file. The chunk size is limited, so even if you
        ask for a big piece there might be less data returned.
      
        :param _arg_idx: Which log file to read. 0=current log file.
        :param _arg_offset: Offset in the log file.
        :param _arg_size: Chunk size to read in the log file.
        :return: Data read from the log file. A data size of 0 means end of file if the requested chunk size was not 0. This is the unprocessed file data, i.e. the line ending style depends on the platform of the system the server is running on.
        :rtype: List[octet]

       """
   
       req = (self.handle,)
       req += (_arg_idx,)
       req += (_arg_offset,)
       req += (_arg_size,)
       val = self.mgr.getService().IMachine_readLog(*req)
       
       return self.mgr.decodebase64( val)

   def cloneTo(self, _arg_target, _arg_mode, _arg_options):
       """
        Creates a clone of this machine, either as a full clone (which means
        creating independent copies of the hard disk media, save states and so
        on), or as a linked clone (which uses its own differencing media,
        sharing the parent media with the source machine).

        The target machine object must have been created previously with IVirtualBox::createMachine, and all the settings will be
        transferred except the VM name and the hardware UUID. You can set the
        VM name and the new hardware UUID when creating the target machine. The
        network MAC addresses are newly created for all enabled network
        adapters. You can change that behaviour with the options parameter.
        The operation is performed asynchronously, so the machine object will
        be not be usable until the @a progress object signals completion.

        
        :param _arg_target: Target machine object.
        :param _arg_mode: Which states should be cloned.
        :param _arg_options: Options for the cloning operation.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        E_INVALIDARG
          @a target is @c null.
        
       """
   
       req = (self.handle,)
       req += (_arg_target,)
       req += (_arg_mode,)
       req += (_arg_options,)
       val = self.mgr.getService().IMachine_cloneTo(*req)
       
       return IProgress(self.mgr, val)

   def moveTo(self, _arg_folder, _arg_type):
       """
        Move machine on to new place/folder
        
        :param _arg_folder: Target folder where machine is moved.
        :param _arg_type: Type of moving. Possible values: basic - Only the files which belong solely to this machine are moved from the original machine's folder to a new folder.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        E_INVALIDARG
          @a target is @c null.
        
       """
   
       req = (self.handle,)
       req += (_arg_folder,)
       req += (_arg_type,)
       val = self.mgr.getService().IMachine_moveTo(*req)
       
       return IProgress(self.mgr, val)

   def saveState(self):
       """
        Saves the current execution state of a running virtual machine
        and stops its execution.

        After this operation completes, the machine will go to the
        Saved state. Next time it is powered up, this state will
        be restored and the machine will continue its execution from
        the place where it was saved.

        This operation differs from taking a snapshot to the effect
        that it doesn't create new differencing media. Also, once
        the machine is powered up from the state saved using this method,
        the saved state is deleted, so it will be impossible to return
        to this state later.

        
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine state neither Running nor Paused.
        VBOX_E_FILE_ERROR
          Failed to create directory for saved state file.
        
        .. note:: 
          On success, this method implicitly calls
          #saveSettings to save all current machine
          settings (including runtime changes to the DVD medium, etc.).
          Together with the impossibility to change any VM settings when it is
          in the Saved state, this guarantees adequate hardware
          configuration of the machine when it is restored from the saved
          state file.
        
        .. note:: 
          The machine must be in the Running or Paused state, otherwise
          the operation will fail.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMachine_saveState(*req)
       
       return IProgress(self.mgr, val)

   def adoptSavedState(self, _arg_savedStateFile):
       """
        Associates the given saved state file to the virtual machine.

        On success, the machine will go to the Saved state. Next time it is
        powered up, it will be restored from the adopted saved state and
        continue execution from the place where the saved state file was
        created.

        The specified saved state file path may be absolute or relative to the
        folder the VM normally saves the state to (usually,
        #snapshotFolder).

        
        :param _arg_savedStateFile: Path to the saved state file to adopt.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine state neither PoweredOff nor Aborted.
        
        .. note:: 
          It's a caller's responsibility to make sure the given saved state
          file is compatible with the settings of this virtual machine that
          represent its virtual hardware (memory size, storage disk configuration
          etc.). If there is a mismatch, the behavior of the virtual machine
          is undefined.
        
       """
   
       req = (self.handle,)
       req += (_arg_savedStateFile,)
       val = self.mgr.getService().IMachine_adoptSavedState(*req)
       
       return 

   def discardSavedState(self, _arg_fRemoveFile):
       """
        Forcibly resets the machine to "Powered Off" state if it is
        currently in the "Saved" state (previously created by #saveState).
        Next time the machine is powered up, a clean boot will occur.
        
        If @a fRemoveFile is @c true, the file in the machine directory
        into which the machine state was saved is also deleted. If
        this is @c false, then the state can be recovered and later
        re-inserted into a machine using #adoptSavedState.
        The location of the file can be found in the
        #stateFilePath attribute.
        
        :param _arg_fRemoveFile: Whether to also remove the saved state file.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine not in state Saved.
        
        .. note:: 
          This operation is equivalent to resetting or powering off
          the machine without doing a proper shutdown of the guest
          operating system; as with resetting a running phyiscal
          computer, it can can lead to data loss.
        
       """
   
       req = (self.handle,)
       req += (_arg_fRemoveFile,)
       val = self.mgr.getService().IMachine_discardSavedState(*req)
       
       return 

   def takeSnapshot(self, _arg_name, _arg_description, _arg_pause):
       """
        Saves the current execution state
        and all settings of the machine and creates differencing images
        for all normal (non-independent) media.
        See ::ISnapshot for an introduction to snapshots.

        This method can be called for a PoweredOff, Saved (see
        #saveState), Running or
        Paused virtual machine. When the machine is PoweredOff, an
        offline snapshot is created. When the machine is Running a live
        snapshot is created, and an online snapshot is created when Paused.

        The taken snapshot is always based on the
        #currentSnapshot
        of the associated virtual machine and becomes a new current snapshot.

        
        :param _arg_name: Short name for the snapshot.
        :param _arg_description: Optional description of the snapshot.
        :param _arg_pause: Whether the VM should be paused while taking the snapshot. Only relevant when the VM is running, and distinguishes between online (@c true) and live (@c false) snapshots. When the VM is not running the result is always an offline snapshot.

        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine currently changing state.
        
        .. note:: 
          This method implicitly calls #saveSettings to
          save all current machine settings before taking an offline snapshot.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_description,)
       req += (_arg_pause,)
       val = self.mgr.getService().IMachine_takeSnapshot(*req)
       
       return IProgress(self.mgr,val["returnval"]), String(self.mgr,val["id"])

   def deleteSnapshot(self, _arg_id):
       """
        Starts deleting the specified snapshot asynchronously.
        See ::ISnapshot for an introduction to snapshots.

        The execution state and settings of the associated machine stored in
        the snapshot will be deleted. The contents of all differencing media of
        this snapshot will be merged with the contents of their dependent child
        media to keep the medium chain valid (in other words, all changes
        represented by media being deleted will be propagated to their child
        medium). After that, this snapshot's differencing medium will be
        deleted. The parent of this snapshot will become a new parent for all
        its child snapshots.

        If the deleted snapshot is the current one, its parent snapshot will
        become a new current snapshot. The current machine state is not directly
        affected in this case, except that currently attached differencing
        media based on media of the deleted snapshot will be also merged as
        described above.

        If the deleted snapshot is the first or current snapshot, then the
        respective IMachine attributes will be adjusted. Deleting the current
        snapshot will also implicitly call #saveSettings
        to make all current machine settings permanent.

        Deleting a snapshot has the following preconditions:

          * Child media of all normal media of the deleted snapshot
          must be accessible (see IMedium::state) for this
          operation to succeed. If only one running VM refers to all images
          which participates in merging the operation can be performed while
          the VM is running. Otherwise all virtual machines whose media are
          directly or indirectly based on the media of deleted snapshot must
          be powered off. In any case, online snapshot deleting usually is
          slower than the same operation without any running VM.
          * You cannot delete the snapshot if a medium attached to it has
          more than one child medium (differencing images) because otherwise
          merging would be impossible. This might be the case if there is
          more than one child snapshot or differencing images were created
          for other reason (e.g. implicitly because of multiple machine
          attachments).

        The virtual machine's #state is
        changed to "DeletingSnapshot", "DeletingSnapshotOnline" or
        "DeletingSnapshotPaused" while this operation is in progress.

        
        :param _arg_id: UUID of the snapshot to delete.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          The running virtual machine prevents deleting this snapshot. This
          happens only in very specific situations, usually snapshots can be
          deleted without trouble while a VM is running. The error message
          text explains the reason for the failure.
        
        .. note:: 
          Merging medium contents can be very time and disk space
          consuming, if these media are big in size and have many
          children. However, if the snapshot being deleted is the last
          (head) snapshot on the branch, the operation will be rather
          quick.
        
       """
   
       req = (self.handle,)
       req += (_arg_id,)
       val = self.mgr.getService().IMachine_deleteSnapshot(*req)
       
       return IProgress(self.mgr, val)

   def deleteSnapshotAndAllChildren(self, _arg_id):
       """
        Starts deleting the specified snapshot and all its children
        asynchronously. See ::ISnapshot for an introduction to
        snapshots. The conditions and many details are the same as with
        #deleteSnapshot.

        This operation is very fast if the snapshot subtree does not include
        the current state. It is still significantly faster than deleting the
        snapshots one by one if the current state is in the subtree and there
        are more than one snapshots from current state to the snapshot which
        marks the subtree, since it eliminates the incremental image merging.

        
        :param _arg_id: UUID of the snapshot to delete, including all its children.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          The running virtual machine prevents deleting this snapshot. This
          happens only in very specific situations, usually snapshots can be
          deleted without trouble while a VM is running. The error message
          text explains the reason for the failure.
        E_NOTIMPL
          The method is not implemented yet.
        
        .. note:: This API method is right now not implemented!
       """
   
       req = (self.handle,)
       req += (_arg_id,)
       val = self.mgr.getService().IMachine_deleteSnapshotAndAllChildren(*req)
       
       return IProgress(self.mgr, val)

   def deleteSnapshotRange(self, _arg_startId, _arg_endId):
       """
        Starts deleting the specified snapshot range. This is limited to
        linear snapshot lists, which means there may not be any other child
        snapshots other than the direct sequence between the start and end
        snapshot. If the start and end snapshot point to the same snapshot this
        method is completely equivalent to #deleteSnapshot. See
        ::ISnapshot for an introduction to snapshots. The
        conditions and many details are the same as with
        #deleteSnapshot.

        This operation is generally faster than deleting snapshots one by one
        and often also needs less extra disk space before freeing up disk space
        by deleting the removed disk images corresponding to the snapshot.

        
        :param _arg_startId: UUID of the first snapshot to delete.
        :param _arg_endId: UUID of the last snapshot to delete.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          The running virtual machine prevents deleting this snapshot. This
          happens only in very specific situations, usually snapshots can be
          deleted without trouble while a VM is running. The error message
          text explains the reason for the failure.
        E_NOTIMPL
          The method is not implemented yet.
        
        .. note:: This API method is right now not implemented!
       """
   
       req = (self.handle,)
       req += (_arg_startId,)
       req += (_arg_endId,)
       val = self.mgr.getService().IMachine_deleteSnapshotRange(*req)
       
       return IProgress(self.mgr, val)

   def restoreSnapshot(self, _arg_snapshot):
       """
        Starts resetting the machine's current state to the state contained
        in the given snapshot, asynchronously. All current settings of the
        machine will be reset and changes stored in differencing media
        will be lost.
        See ::ISnapshot for an introduction to snapshots.

        After this operation is successfully completed, new empty differencing
        media are created for all normal media of the machine.

        If the given snapshot is an online snapshot, the machine will go to
        the ::MachineState_Saved, so that the
        next time it is powered on, the execution state will be restored
        from the state of the snapshot.

        
        :param _arg_snapshot: The snapshot to restore the VM state from.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine is running.
        
        .. note:: 
          The machine must not be running, otherwise the operation will fail.
        
        .. note:: 
          If the machine state is ::MachineState_Saved
          prior to this operation, the saved state file will be implicitly
          deleted (as if IMachine::discardSavedState were
          called).
        
       """
   
       req = (self.handle,)
       req += (_arg_snapshot,)
       val = self.mgr.getService().IMachine_restoreSnapshot(*req)
       
       return IProgress(self.mgr, val)

   def applyDefaults(self, _arg_flags):
       """
        Applies the defaults for the configured guest OS type. This is
        primarily for getting sane settings straight after creating a
        new VM, but it can also be applied later.

        
        :param _arg_flags: Additional flags, to be defined later.

        Expected result codes:
        E_FAIL
          General error.
        VBOX_E_INVALID_VM_STATE
          The machine is in invalid state.
        VBOX_E_OBJECT_IN_USE
          Some of the applied objects already exist. The method has been
          called to already configured machine.
        
        .. note:: 
          This is primarily a shortcut, centralizing the tedious job of
          getting the recommended settings and translating them into
          settings updates. The settings are made at the end of the call,
          but not saved.
        
       """
   
       req = (self.handle,)
       req += (_arg_flags,)
       val = self.mgr.getService().IMachine_applyDefaults(*req)
       
       return 

   def getParent(self):
       """Associated parent object. """
       val = self.mgr.getService().IMachine_getParent(self.handle)
       return IVirtualBox(self.mgr, val)

   def getIcon(self):
       """Overridden VM Icon details. """
       val = self.mgr.getService().IMachine_getIcon(self.handle)
       return self.mgr.decodebase64( val)

   def setIcon(self, value):
       """Overridden VM Icon details. """
       _this=self.handle
       if type(value) in [int, bool, str, tuple, list]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setIcon(_this, _val)

   def getAccessible(self):
       """
        Whether this virtual machine is currently accessible or not.

        A machine is always deemed accessible unless it is registered and
        its settings file cannot be read or parsed (either because the file itself
        is unavailable or has invalid XML contents).

        Every time this property is read, the accessibility state of
        this machine is re-evaluated. If the returned value is @c false,
        the #accessError property may be used to get the
        detailed error information describing the reason of
        inaccessibility, including XML error messages.

        When the machine is inaccessible, only the following properties
        can be used on it:
          * #parent
          * #id
          * #settingsFilePath
          * #accessible
          * #accessError

        An attempt to access any other property or method will return
        an error.

        The only possible action you can perform on an inaccessible
        machine is to unregister it using the
        IMachine::unregister call (or, to check
        for the accessibility state once more by querying this
        property).

        
        .. note:: 
          In the current implementation, once this property returns
          @c true, the machine will never become inaccessible
          later, even if its settings file cannot be successfully
          read/written any more (at least, until the VirtualBox
          server is restarted). This limitation may be removed in
          future releases.
         """
       val = self.mgr.getService().IMachine_getAccessible(self.handle)
       return Boolean(self.mgr, val)

   def getAccessError(self):
       """
        Error information describing the reason of machine
        inaccessibility.

        Reading this property is only valid after the last call to
        #accessible returned @c false (i.e. the
        machine is currently inaccessible). Otherwise, a @c null
        IVirtualBoxErrorInfo object will be returned.
       """
       val = self.mgr.getService().IMachine_getAccessError(self.handle)
       return IVirtualBoxErrorInfo(self.mgr, val)

   def getName(self):
       """
        Name of the virtual machine.

        Besides being used for human-readable identification purposes
        everywhere in VirtualBox, the virtual machine name is also used
        as a name of the machine's settings file and as a name of the
        subdirectory this settings file resides in. Thus, every time you
        change the value of this property, the settings file will be
        renamed once you call #saveSettings to confirm the
        change. The containing subdirectory will be also renamed, but
        only if it has exactly the same name as the settings file
        itself prior to changing this property (for backward compatibility
        with previous API releases). The above implies the following
        limitations:
          * The machine name cannot be empty.
          * The machine name can contain only characters that are valid
            file name characters according to the rules of the file
            system used to store VirtualBox configuration.
          * You cannot have two or more machines with the same name
            if they use the same subdirectory for storing the machine
            settings files.
          * You cannot change the name of the machine if it is running,
            or if any file in the directory containing the settings file
            is being used by another running machine or by any other
            process in the host operating system at a time when
            #saveSettings is called.
          
        If any of the above limitations are hit, #saveSettings
        will return an appropriate error message explaining the exact
        reason and the changes you made to this machine will not be saved.

        Starting with VirtualBox 4.0, a ".vbox" extension of the settings
        file is recommended, but not enforced. (Previous versions always
        used a generic ".xml" extension.)
       """
       val = self.mgr.getService().IMachine_getName(self.handle)
       return String(self.mgr, val)

   def setName(self, value):
       """
        Name of the virtual machine.

        Besides being used for human-readable identification purposes
        everywhere in VirtualBox, the virtual machine name is also used
        as a name of the machine's settings file and as a name of the
        subdirectory this settings file resides in. Thus, every time you
        change the value of this property, the settings file will be
        renamed once you call #saveSettings to confirm the
        change. The containing subdirectory will be also renamed, but
        only if it has exactly the same name as the settings file
        itself prior to changing this property (for backward compatibility
        with previous API releases). The above implies the following
        limitations:
          * The machine name cannot be empty.
          * The machine name can contain only characters that are valid
            file name characters according to the rules of the file
            system used to store VirtualBox configuration.
          * You cannot have two or more machines with the same name
            if they use the same subdirectory for storing the machine
            settings files.
          * You cannot change the name of the machine if it is running,
            or if any file in the directory containing the settings file
            is being used by another running machine or by any other
            process in the host operating system at a time when
            #saveSettings is called.
          
        If any of the above limitations are hit, #saveSettings
        will return an appropriate error message explaining the exact
        reason and the changes you made to this machine will not be saved.

        Starting with VirtualBox 4.0, a ".vbox" extension of the settings
        file is recommended, but not enforced. (Previous versions always
        used a generic ".xml" extension.)
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setName(_this, _val)

   def getDescription(self):
       """
        Description of the virtual machine.

        The description attribute can contain any text and is
        typically used to describe the hardware and software
        configuration of the virtual machine in detail (i.e. network
        settings, versions of the installed software and so on).
       """
       val = self.mgr.getService().IMachine_getDescription(self.handle)
       return String(self.mgr, val)

   def setDescription(self, value):
       """
        Description of the virtual machine.

        The description attribute can contain any text and is
        typically used to describe the hardware and software
        configuration of the virtual machine in detail (i.e. network
        settings, versions of the installed software and so on).
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setDescription(_this, _val)

   def getId(self):
       """UUID of the virtual machine. """
       val = self.mgr.getService().IMachine_getId(self.handle)
       return String(self.mgr, val)

   def getGroups(self):
       """
        Array of machine group names of which this machine is a member.
        "" and "/" are synonyms for the toplevel group. Each
        group is only listed once, however they are listed in no particular
        order and there is no guarantee that there are no gaps in the group
        hierarchy (i.e. "/group",
        "/group/subgroup/subsubgroup" is a valid result).
       """
       val = self.mgr.getService().IMachine_getGroups(self.handle)
       return String(self.mgr, val, True)

   def setGroups(self, value):
       """
        Array of machine group names of which this machine is a member.
        "" and "/" are synonyms for the toplevel group. Each
        group is only listed once, however they are listed in no particular
        order and there is no guarantee that there are no gaps in the group
        hierarchy (i.e. "/group",
        "/group/subgroup/subsubgroup" is a valid result).
       """
       _this=self.handle
       if type(value) in [int, bool, str, tuple, list]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setGroups(_this, _val)

   def getOSTypeId(self):
       """
        User-defined identifier of the Guest OS type.
        You may use IVirtualBox::getGuestOSType to obtain
        an IGuestOSType object representing details about the given
        Guest OS type. All Guest OS types are considered valid, even those
        which are not known to IVirtualBox::getGuestOSType.
        
        .. note:: 
          This value may differ from the value returned by
          IGuest::OSTypeId if Guest Additions are
          installed to the guest OS.
         """
       val = self.mgr.getService().IMachine_getOSTypeId(self.handle)
       return String(self.mgr, val)

   def setOSTypeId(self, value):
       """
        User-defined identifier of the Guest OS type.
        You may use IVirtualBox::getGuestOSType to obtain
        an IGuestOSType object representing details about the given
        Guest OS type. All Guest OS types are considered valid, even those
        which are not known to IVirtualBox::getGuestOSType.
        
        .. note:: 
          This value may differ from the value returned by
          IGuest::OSTypeId if Guest Additions are
          installed to the guest OS.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setOSTypeId(_this, _val)

   def getHardwareVersion(self):
       """Hardware version identifier. Internal use only for now. """
       val = self.mgr.getService().IMachine_getHardwareVersion(self.handle)
       return String(self.mgr, val)

   def setHardwareVersion(self, value):
       """Hardware version identifier. Internal use only for now. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setHardwareVersion(_this, _val)

   def getHardwareUUID(self):
       """
        The UUID presented to the guest via memory tables, hardware and guest
        properties. For most VMs this is the same as the @a id, but for VMs
        which have been cloned or teleported it may be the same as the source
        VM. The latter is because the guest shouldn't notice that it was
        cloned or teleported.
       """
       val = self.mgr.getService().IMachine_getHardwareUUID(self.handle)
       return String(self.mgr, val)

   def setHardwareUUID(self, value):
       """
        The UUID presented to the guest via memory tables, hardware and guest
        properties. For most VMs this is the same as the @a id, but for VMs
        which have been cloned or teleported it may be the same as the source
        VM. The latter is because the guest shouldn't notice that it was
        cloned or teleported.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setHardwareUUID(_this, _val)

   def getCPUCount(self):
       """Number of virtual CPUs in the VM. """
       val = self.mgr.getService().IMachine_getCPUCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def setCPUCount(self, value):
       """Number of virtual CPUs in the VM. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setCPUCount(_this, _val)

   def getCPUHotPlugEnabled(self):
       """
        This setting determines whether VirtualBox allows CPU
        hotplugging for this machine. """
       val = self.mgr.getService().IMachine_getCPUHotPlugEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setCPUHotPlugEnabled(self, value):
       """
        This setting determines whether VirtualBox allows CPU
        hotplugging for this machine. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setCPUHotPlugEnabled(_this, _val)

   def getCPUExecutionCap(self):
       """
        Means to limit the number of CPU cycles a guest can use. The unit
        is percentage of host CPU cycles per second. The valid range
        is 1 - 100. 100 (the default) implies no limit.
       """
       val = self.mgr.getService().IMachine_getCPUExecutionCap(self.handle)
       return UnsignedInt(self.mgr, val)

   def setCPUExecutionCap(self, value):
       """
        Means to limit the number of CPU cycles a guest can use. The unit
        is percentage of host CPU cycles per second. The valid range
        is 1 - 100. 100 (the default) implies no limit.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setCPUExecutionCap(_this, _val)

   def getCPUIDPortabilityLevel(self):
       """Virtual CPUID portability level, the higher number the fewer newer
        or vendor specific CPU feature is reported to the guest (via the CPUID
        instruction).  The default level of zero (0) means that all virtualized
        features supported by the host is pass thru to the guest.  While the
        three (3) is currently the level supressing the most features.

        Exactly which of the CPUID features are left out by the VMM at which
        level is subject to change with each major version.
         """
       val = self.mgr.getService().IMachine_getCPUIDPortabilityLevel(self.handle)
       return UnsignedInt(self.mgr, val)

   def setCPUIDPortabilityLevel(self, value):
       """Virtual CPUID portability level, the higher number the fewer newer
        or vendor specific CPU feature is reported to the guest (via the CPUID
        instruction).  The default level of zero (0) means that all virtualized
        features supported by the host is pass thru to the guest.  While the
        three (3) is currently the level supressing the most features.

        Exactly which of the CPUID features are left out by the VMM at which
        level is subject to change with each major version.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setCPUIDPortabilityLevel(_this, _val)

   def getMemorySize(self):
       """System memory size in megabytes. """
       val = self.mgr.getService().IMachine_getMemorySize(self.handle)
       return UnsignedInt(self.mgr, val)

   def setMemorySize(self, value):
       """System memory size in megabytes. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setMemorySize(_this, _val)

   def getMemoryBalloonSize(self):
       """Memory balloon size in megabytes. """
       val = self.mgr.getService().IMachine_getMemoryBalloonSize(self.handle)
       return UnsignedInt(self.mgr, val)

   def setMemoryBalloonSize(self, value):
       """Memory balloon size in megabytes. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setMemoryBalloonSize(_this, _val)

   def getPageFusionEnabled(self):
       """
        This setting determines whether VirtualBox allows page
        fusion for this machine (64-bit hosts only).
       """
       val = self.mgr.getService().IMachine_getPageFusionEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setPageFusionEnabled(self, value):
       """
        This setting determines whether VirtualBox allows page
        fusion for this machine (64-bit hosts only).
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setPageFusionEnabled(_this, _val)

   def getGraphicsAdapter(self):
       """Graphics adapter object. """
       val = self.mgr.getService().IMachine_getGraphicsAdapter(self.handle)
       return IGraphicsAdapter(self.mgr, val)

   def getBIOSSettings(self):
       """Object containing all BIOS settings. """
       val = self.mgr.getService().IMachine_getBIOSSettings(self.handle)
       return IBIOSSettings(self.mgr, val)

   def getRecordingSettings(self):
       """Object containing all recording settings. """
       val = self.mgr.getService().IMachine_getRecordingSettings(self.handle)
       return IRecordingSettings(self.mgr, val)

   def getFirmwareType(self):
       """Type of firmware (such as legacy BIOS or EFI), used for initial
        bootstrap in this VM. """
       val = self.mgr.getService().IMachine_getFirmwareType(self.handle)
       return FirmwareType(self.mgr, val)

   def setFirmwareType(self, value):
       """Type of firmware (such as legacy BIOS or EFI), used for initial
        bootstrap in this VM. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setFirmwareType(_this, _val)

   def getPointingHIDType(self):
       """Type of pointing HID (such as mouse or tablet) used in this VM.
        The default is typically "PS2Mouse" but can vary depending on the
        requirements of the guest operating system. """
       val = self.mgr.getService().IMachine_getPointingHIDType(self.handle)
       return PointingHIDType(self.mgr, val)

   def setPointingHIDType(self, value):
       """Type of pointing HID (such as mouse or tablet) used in this VM.
        The default is typically "PS2Mouse" but can vary depending on the
        requirements of the guest operating system. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setPointingHIDType(_this, _val)

   def getKeyboardHIDType(self):
       """Type of keyboard HID used in this VM.
        The default is typically "PS2Keyboard" but can vary depending on the
        requirements of the guest operating system. """
       val = self.mgr.getService().IMachine_getKeyboardHIDType(self.handle)
       return KeyboardHIDType(self.mgr, val)

   def setKeyboardHIDType(self, value):
       """Type of keyboard HID used in this VM.
        The default is typically "PS2Keyboard" but can vary depending on the
        requirements of the guest operating system. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setKeyboardHIDType(_this, _val)

   def getHPETEnabled(self):
       """This attribute controls if High Precision Event Timer (HPET) is
        enabled in this VM. Use this property if you want to provide guests
        with additional time source, or if guest requires HPET to function correctly.
        Default is false. """
       val = self.mgr.getService().IMachine_getHPETEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setHPETEnabled(self, value):
       """This attribute controls if High Precision Event Timer (HPET) is
        enabled in this VM. Use this property if you want to provide guests
        with additional time source, or if guest requires HPET to function correctly.
        Default is false. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setHPETEnabled(_this, _val)

   def getChipsetType(self):
       """Chipset type used in this VM. """
       val = self.mgr.getService().IMachine_getChipsetType(self.handle)
       return ChipsetType(self.mgr, val)

   def setChipsetType(self, value):
       """Chipset type used in this VM. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setChipsetType(_this, _val)

   def getSnapshotFolder(self):
       """
        Full path to the directory used to store snapshot data
        (differencing media and saved state files) of this machine.

        The initial value of this property is
        <#settingsFilePath>/<#id>.

        Currently, it is an error to try to change this property on
        a machine that has snapshots (because this would require to
        move possibly large files to a different location).
        A separate method will be available for this purpose later.

        
        .. note:: 
          Setting this property to @c null or to an empty string will restore
          the initial value.
        
        .. note:: 
          When setting this property, the specified path can be
          absolute (full path) or relative to the directory where the
          #settingsFilePath
          is located. When reading this property, a full path is
          always returned.
        
        .. note:: 
          The specified path may not exist, it will be created
          when necessary.
         """
       val = self.mgr.getService().IMachine_getSnapshotFolder(self.handle)
       return String(self.mgr, val)

   def setSnapshotFolder(self, value):
       """
        Full path to the directory used to store snapshot data
        (differencing media and saved state files) of this machine.

        The initial value of this property is
        <#settingsFilePath>/<#id>.

        Currently, it is an error to try to change this property on
        a machine that has snapshots (because this would require to
        move possibly large files to a different location).
        A separate method will be available for this purpose later.

        
        .. note:: 
          Setting this property to @c null or to an empty string will restore
          the initial value.
        
        .. note:: 
          When setting this property, the specified path can be
          absolute (full path) or relative to the directory where the
          #settingsFilePath
          is located. When reading this property, a full path is
          always returned.
        
        .. note:: 
          The specified path may not exist, it will be created
          when necessary.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setSnapshotFolder(_this, _val)

   def getVRDEServer(self):
       """VirtualBox Remote Desktop Extension (VRDE) server object. """
       val = self.mgr.getService().IMachine_getVRDEServer(self.handle)
       return IVRDEServer(self.mgr, val)

   def getEmulatedUSBCardReaderEnabled(self):
       """ """
       val = self.mgr.getService().IMachine_getEmulatedUSBCardReaderEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEmulatedUSBCardReaderEnabled(self, value):
       """ """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setEmulatedUSBCardReaderEnabled(_this, _val)

   def getMediumAttachments(self):
       """Array of media attached to this machine. """
       val = self.mgr.getService().IMachine_getMediumAttachments(self.handle)
       return IMediumAttachment(self.mgr, val, True)

   def getUSBControllers(self):
       """
        Array of USB controllers attached to this machine.

        
        .. note:: 
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
         """
       val = self.mgr.getService().IMachine_getUSBControllers(self.handle)
       return IUSBController(self.mgr, val, True)

   def getUSBDeviceFilters(self):
       """
        Associated USB device filters object.

        
        .. note:: 
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
         """
       val = self.mgr.getService().IMachine_getUSBDeviceFilters(self.handle)
       return IUSBDeviceFilters(self.mgr, val)

   def getAudioAdapter(self):
       """Associated audio adapter, always present. """
       val = self.mgr.getService().IMachine_getAudioAdapter(self.handle)
       return IAudioAdapter(self.mgr, val)

   def getStorageControllers(self):
       """Array of storage controllers attached to this machine. """
       val = self.mgr.getService().IMachine_getStorageControllers(self.handle)
       return IStorageController(self.mgr, val, True)

   def getSettingsFilePath(self):
       """
        Full name of the file containing machine settings data.
       """
       val = self.mgr.getService().IMachine_getSettingsFilePath(self.handle)
       return String(self.mgr, val)

   def getSettingsAuxFilePath(self):
       """
        Full name of the file containing auxiliary machine settings data.
       """
       val = self.mgr.getService().IMachine_getSettingsAuxFilePath(self.handle)
       return String(self.mgr, val)

   def getSettingsModified(self):
       """
        Whether the settings of this machine have been modified
        (but neither yet saved nor discarded).
        
        .. note:: 
          Reading this property is only valid on instances returned
          by ISession::machine and on new machines
          created by IVirtualBox::createMachine or opened
          by IVirtualBox::openMachine but not
          yet registered, or on unregistered machines after calling
          IMachine::unregister. For all other
          cases, the settings can never be modified.
        
        .. note:: 
          For newly created unregistered machines, the value of this
          property is always @c true until #saveSettings
          is called (no matter if any machine settings have been
          changed after the creation or not). For opened machines
          the value is set to @c false (and then follows to normal rules).
         """
       val = self.mgr.getService().IMachine_getSettingsModified(self.handle)
       return Boolean(self.mgr, val)

   def getSessionState(self):
       """Current session state for this machine. """
       val = self.mgr.getService().IMachine_getSessionState(self.handle)
       return SessionState(self.mgr, val)

   def getSessionName(self):
       """
        Name of the session. If #sessionState is
        Spawning or Locked, this attribute contains the
        same value as passed to the
        IMachine::launchVMProcess method in the
        @a name parameter. If the session was established with
        IMachine::lockMachine, it is the name of the session
        (if set, otherwise empty string). If
        #sessionState is SessionClosed, the value of this
        attribute is an empty string.
       """
       val = self.mgr.getService().IMachine_getSessionName(self.handle)
       return String(self.mgr, val)

   def getSessionPID(self):
       """
        Identifier of the session process. This attribute contains the
        platform-dependent identifier of the process whose session was
        used with IMachine::lockMachine call. The returned
        value is only valid if #sessionState is Locked or
        Unlocking by the time this property is read.
       """
       val = self.mgr.getService().IMachine_getSessionPID(self.handle)
       return UnsignedInt(self.mgr, val)

   def getState(self):
       """Current execution state of this machine. """
       val = self.mgr.getService().IMachine_getState(self.handle)
       return MachineState(self.mgr, val)

   def getLastStateChange(self):
       """
        Timestamp of the last execution state change,
        in milliseconds since 1970-01-01 UTC.
       """
       val = self.mgr.getService().IMachine_getLastStateChange(self.handle)
       return Long(self.mgr, val)

   def getStateFilePath(self):
       """
        Full path to the file that stores the execution state of
        the machine when it is in the ::MachineState_Saved state.
        
        .. note:: 
          When the machine is not in the Saved state, this attribute is
          an empty string.
         """
       val = self.mgr.getService().IMachine_getStateFilePath(self.handle)
       return String(self.mgr, val)

   def getLogFolder(self):
       """
        Full path to the folder that stores a set of rotated log files
        recorded during machine execution. The most recent log file is
        named VBox.log, the previous log file is
        named VBox.log.1 and so on (up to VBox.log.3
        in the current version).
       """
       val = self.mgr.getService().IMachine_getLogFolder(self.handle)
       return String(self.mgr, val)

   def getCurrentSnapshot(self):
       """
        Current snapshot of this machine. This is @c null if the machine
        currently has no snapshots. If it is not @c null, then it was
        set by one of #takeSnapshot, #deleteSnapshot
        or #restoreSnapshot, depending on which was called last.
        See ::ISnapshot for details.
       """
       val = self.mgr.getService().IMachine_getCurrentSnapshot(self.handle)
       return ISnapshot(self.mgr, val)

   def getSnapshotCount(self):
       """
        Number of snapshots taken on this machine. Zero means the
        machine doesn't have any snapshots.
       """
       val = self.mgr.getService().IMachine_getSnapshotCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getCurrentStateModified(self):
       """
        Returns @c true if the current state of the machine is not
        identical to the state stored in the current snapshot.

        The current state is identical to the current snapshot only
        directly after one of the following calls are made:

          * #restoreSnapshot
          * #takeSnapshot (issued on a "powered off" or "saved"
            machine, for which #settingsModified returns @c false)
          

        The current state remains identical until one of the following
        happens:
          * settings of the machine are changed
          * the saved state is deleted
          * the current snapshot is deleted
          * an attempt to execute the machine is made
        .. note:: 
          For machines that don't have snapshots, this property is
          always @c false.
         """
       val = self.mgr.getService().IMachine_getCurrentStateModified(self.handle)
       return Boolean(self.mgr, val)

   def getSharedFolders(self):
       """
        Collection of shared folders for this machine (permanent shared
        folders). These folders are shared automatically at machine startup
        and available only to the guest OS installed within this machine.

        New shared folders are added to the collection using
        #createSharedFolder. Existing shared folders can be
        removed using #removeSharedFolder.
       """
       val = self.mgr.getService().IMachine_getSharedFolders(self.handle)
       return ISharedFolder(self.mgr, val, True)

   def getClipboardMode(self):
       """
        Synchronization mode between the host OS clipboard
        and the guest OS clipboard.
       """
       val = self.mgr.getService().IMachine_getClipboardMode(self.handle)
       return ClipboardMode(self.mgr, val)

   def setClipboardMode(self, value):
       """
        Synchronization mode between the host OS clipboard
        and the guest OS clipboard.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setClipboardMode(_this, _val)

   def getClipboardFileTransfersEnabled(self):
       """
        Sets or retrieves whether clipboard file transfers are allowed or not.

        When set to @a true, clipboard file transfers between supported
        host and guest OSes are allowed.
       """
       val = self.mgr.getService().IMachine_getClipboardFileTransfersEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setClipboardFileTransfersEnabled(self, value):
       """
        Sets or retrieves whether clipboard file transfers are allowed or not.

        When set to @a true, clipboard file transfers between supported
        host and guest OSes are allowed.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setClipboardFileTransfersEnabled(_this, _val)

   def getDnDMode(self):
       """
        Sets or retrieves the current drag'n drop mode.
       """
       val = self.mgr.getService().IMachine_getDnDMode(self.handle)
       return DnDMode(self.mgr, val)

   def setDnDMode(self, value):
       """
        Sets or retrieves the current drag'n drop mode.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setDnDMode(_this, _val)

   def getTeleporterEnabled(self):
       """
        When set to @a true, the virtual machine becomes a target teleporter
        the next time it is powered on. This can only set to @a true when the
        VM is in the @a PoweredOff or @a Aborted state.

         """
       val = self.mgr.getService().IMachine_getTeleporterEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setTeleporterEnabled(self, value):
       """
        When set to @a true, the virtual machine becomes a target teleporter
        the next time it is powered on. This can only set to @a true when the
        VM is in the @a PoweredOff or @a Aborted state.

         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setTeleporterEnabled(_this, _val)

   def getTeleporterPort(self):
       """
        The TCP port the target teleporter will listen for incoming
        teleportations on.

        0 means the port is automatically selected upon power on. The actual
        value can be read from this property while the machine is waiting for
        incoming teleportations.
       """
       val = self.mgr.getService().IMachine_getTeleporterPort(self.handle)
       return UnsignedInt(self.mgr, val)

   def setTeleporterPort(self, value):
       """
        The TCP port the target teleporter will listen for incoming
        teleportations on.

        0 means the port is automatically selected upon power on. The actual
        value can be read from this property while the machine is waiting for
        incoming teleportations.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setTeleporterPort(_this, _val)

   def getTeleporterAddress(self):
       """
        The address the target teleporter will listen on. If set to an empty
        string, it will listen on all addresses.
       """
       val = self.mgr.getService().IMachine_getTeleporterAddress(self.handle)
       return String(self.mgr, val)

   def setTeleporterAddress(self, value):
       """
        The address the target teleporter will listen on. If set to an empty
        string, it will listen on all addresses.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setTeleporterAddress(_this, _val)

   def getTeleporterPassword(self):
       """
        The password to check for on the target teleporter. This is just a
        very basic measure to prevent simple hacks and operators accidentally
        beaming a virtual machine to the wrong place.

        Note that you SET a plain text password while reading back a HASHED
        password. Setting a hashed password is currently not supported.
       """
       val = self.mgr.getService().IMachine_getTeleporterPassword(self.handle)
       return String(self.mgr, val)

   def setTeleporterPassword(self, value):
       """
        The password to check for on the target teleporter. This is just a
        very basic measure to prevent simple hacks and operators accidentally
        beaming a virtual machine to the wrong place.

        Note that you SET a plain text password while reading back a HASHED
        password. Setting a hashed password is currently not supported.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setTeleporterPassword(_this, _val)

   def getParavirtProvider(self):
       """
        The paravirtualized guest interface provider.
       """
       val = self.mgr.getService().IMachine_getParavirtProvider(self.handle)
       return ParavirtProvider(self.mgr, val)

   def setParavirtProvider(self, value):
       """
        The paravirtualized guest interface provider.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setParavirtProvider(_this, _val)

   def getRTCUseUTC(self):
       """
        When set to @a true, the RTC device of the virtual machine will run
        in UTC time, otherwise in local time. Especially Unix guests prefer
        the time in UTC.
       """
       val = self.mgr.getService().IMachine_getRTCUseUTC(self.handle)
       return Boolean(self.mgr, val)

   def setRTCUseUTC(self, value):
       """
        When set to @a true, the RTC device of the virtual machine will run
        in UTC time, otherwise in local time. Especially Unix guests prefer
        the time in UTC.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setRTCUseUTC(_this, _val)

   def getIOCacheEnabled(self):
       """
        When set to @a true, the builtin I/O cache of the virtual machine
        will be enabled.
       """
       val = self.mgr.getService().IMachine_getIOCacheEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setIOCacheEnabled(self, value):
       """
        When set to @a true, the builtin I/O cache of the virtual machine
        will be enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setIOCacheEnabled(_this, _val)

   def getIOCacheSize(self):
       """
        Maximum size of the I/O cache in MB.
       """
       val = self.mgr.getService().IMachine_getIOCacheSize(self.handle)
       return UnsignedInt(self.mgr, val)

   def setIOCacheSize(self, value):
       """
        Maximum size of the I/O cache in MB.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setIOCacheSize(_this, _val)

   def getPCIDeviceAssignments(self):
       """Array of PCI devices assigned to this machine, to get list of all
        PCI devices attached to the machine use
        IConsole::attachedPCIDevices attribute, as this attribute
        is intended to list only devices additional to what described in
        virtual hardware config. Usually, this list keeps host's physical
        devices assigned to the particular machine.
       """
       val = self.mgr.getService().IMachine_getPCIDeviceAssignments(self.handle)
       return IPCIDeviceAttachment(self.mgr, val, True)

   def getBandwidthControl(self):
       """
        Bandwidth control manager.
       """
       val = self.mgr.getService().IMachine_getBandwidthControl(self.handle)
       return IBandwidthControl(self.mgr, val)

   def getTracingEnabled(self):
       """
        Enables the tracing facility in the VMM (including PDM devices +
        drivers). The VMM will consume about 0.5MB of more memory when
        enabled and there may be some extra overhead from tracepoints that are
        always enabled.
       """
       val = self.mgr.getService().IMachine_getTracingEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setTracingEnabled(self, value):
       """
        Enables the tracing facility in the VMM (including PDM devices +
        drivers). The VMM will consume about 0.5MB of more memory when
        enabled and there may be some extra overhead from tracepoints that are
        always enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setTracingEnabled(_this, _val)

   def getTracingConfig(self):
       """
        Tracepoint configuration to apply at startup when
        IMachine::tracingEnabled is true. The string specifies
        a space separated of tracepoint group names to enable. The special
        group 'all' enables all tracepoints. Check DBGFR3TracingConfig for
        more details on available tracepoint groups and such.

        Note that on hosts supporting DTrace (or similar), a lot of the
        tracepoints may be implemented exclusively as DTrace probes. So, the
        effect of the same config may differ between Solaris and Windows for
        example.
       """
       val = self.mgr.getService().IMachine_getTracingConfig(self.handle)
       return String(self.mgr, val)

   def setTracingConfig(self, value):
       """
        Tracepoint configuration to apply at startup when
        IMachine::tracingEnabled is true. The string specifies
        a space separated of tracepoint group names to enable. The special
        group 'all' enables all tracepoints. Check DBGFR3TracingConfig for
        more details on available tracepoint groups and such.

        Note that on hosts supporting DTrace (or similar), a lot of the
        tracepoints may be implemented exclusively as DTrace probes. So, the
        effect of the same config may differ between Solaris and Windows for
        example.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setTracingConfig(_this, _val)

   def getAllowTracingToAccessVM(self):
       """
        Enables tracepoints in PDM devices and drivers to use the VMCPU or VM
        structures when firing off trace points. This is especially useful
        with DTrace tracepoints, as it allows you to use the VMCPU or VM
        pointer to obtain useful information such as guest register state.

        This is disabled by default because devices and drivers normally has no
        business accessing the VMCPU or VM structures, and are therefore unable
        to get any pointers to these.
       """
       val = self.mgr.getService().IMachine_getAllowTracingToAccessVM(self.handle)
       return Boolean(self.mgr, val)

   def setAllowTracingToAccessVM(self, value):
       """
        Enables tracepoints in PDM devices and drivers to use the VMCPU or VM
        structures when firing off trace points. This is especially useful
        with DTrace tracepoints, as it allows you to use the VMCPU or VM
        pointer to obtain useful information such as guest register state.

        This is disabled by default because devices and drivers normally has no
        business accessing the VMCPU or VM structures, and are therefore unable
        to get any pointers to these.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setAllowTracingToAccessVM(_this, _val)

   def getAutostartEnabled(self):
       """
        Enables autostart of the VM during system boot.
       """
       val = self.mgr.getService().IMachine_getAutostartEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setAutostartEnabled(self, value):
       """
        Enables autostart of the VM during system boot.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setAutostartEnabled(_this, _val)

   def getAutostartDelay(self):
       """
        Number of seconds to wait until the VM should be started during system boot.
       """
       val = self.mgr.getService().IMachine_getAutostartDelay(self.handle)
       return UnsignedInt(self.mgr, val)

   def setAutostartDelay(self, value):
       """
        Number of seconds to wait until the VM should be started during system boot.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setAutostartDelay(_this, _val)

   def getAutostopType(self):
       """
        Action type to do when the system is shutting down.
       """
       val = self.mgr.getService().IMachine_getAutostopType(self.handle)
       return AutostopType(self.mgr, val)

   def setAutostopType(self, value):
       """
        Action type to do when the system is shutting down.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setAutostopType(_this, _val)

   def getDefaultFrontend(self):
       """
        Selects which VM frontend should be used by default when launching
        this VM through the IMachine::launchVMProcess method.
        Empty or @c null strings do not define a particular default, it is up
        to IMachine::launchVMProcess to select one. See the
        description of IMachine::launchVMProcess for the valid
        frontend types.

        This per-VM setting overrides the default defined by
        ISystemProperties::defaultFrontend attribute, and is
        overridden by a frontend type passed to
        IMachine::launchVMProcess.
       """
       val = self.mgr.getService().IMachine_getDefaultFrontend(self.handle)
       return String(self.mgr, val)

   def setDefaultFrontend(self, value):
       """
        Selects which VM frontend should be used by default when launching
        this VM through the IMachine::launchVMProcess method.
        Empty or @c null strings do not define a particular default, it is up
        to IMachine::launchVMProcess to select one. See the
        description of IMachine::launchVMProcess for the valid
        frontend types.

        This per-VM setting overrides the default defined by
        ISystemProperties::defaultFrontend attribute, and is
        overridden by a frontend type passed to
        IMachine::launchVMProcess.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setDefaultFrontend(_this, _val)

   def getUSBProxyAvailable(self):
       """
        Returns whether there is an USB proxy available.
       """
       val = self.mgr.getService().IMachine_getUSBProxyAvailable(self.handle)
       return Boolean(self.mgr, val)

   def getVMProcessPriority(self):
       """
        Sets the priority of the VM process. It is a VM setting which can
        be changed both before starting the VM and at runtime.

        The default value is 'Default', which selects the default
        process priority.

         """
       val = self.mgr.getService().IMachine_getVMProcessPriority(self.handle)
       return VMProcPriority(self.mgr, val)

   def setVMProcessPriority(self, value):
       """
        Sets the priority of the VM process. It is a VM setting which can
        be changed both before starting the VM and at runtime.

        The default value is 'Default', which selects the default
        process priority.

         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setVMProcessPriority(_this, _val)

   def getParavirtDebug(self):
       """
        Debug parameters for the paravirtualized guest interface provider.
       """
       val = self.mgr.getService().IMachine_getParavirtDebug(self.handle)
       return String(self.mgr, val)

   def setParavirtDebug(self, value):
       """
        Debug parameters for the paravirtualized guest interface provider.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setParavirtDebug(_this, _val)

   def getCPUProfile(self):
       """
        Experimental feature to select the guest CPU profile.  The default
        is "host", which indicates the host CPU.  All other names are subject
        to change.

        The profiles are found in src/VBox/VMM/VMMR3/cpus/.
       """
       val = self.mgr.getService().IMachine_getCPUProfile(self.handle)
       return String(self.mgr, val)

   def setCPUProfile(self, value):
       """
        Experimental feature to select the guest CPU profile.  The default
        is "host", which indicates the host CPU.  All other names are subject
        to change.

        The profiles are found in src/VBox/VMM/VMMR3/cpus/.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachine_setCPUProfile(_this, _val)



   _Attrs_ = {'parent':[getParent,None],
              'icon':[getIcon,setIcon,],
              'accessible':[getAccessible,None],
              'accessError':[getAccessError,None],
              'name':[getName,setName,],
              'description':[getDescription,setDescription,],
              'id':[getId,None],
              'groups':[getGroups,setGroups,],
              'OSTypeId':[getOSTypeId,setOSTypeId,],
              'hardwareVersion':[getHardwareVersion,setHardwareVersion,],
              'hardwareUUID':[getHardwareUUID,setHardwareUUID,],
              'CPUCount':[getCPUCount,setCPUCount,],
              'CPUHotPlugEnabled':[getCPUHotPlugEnabled,setCPUHotPlugEnabled,],
              'CPUExecutionCap':[getCPUExecutionCap,setCPUExecutionCap,],
              'CPUIDPortabilityLevel':[getCPUIDPortabilityLevel,setCPUIDPortabilityLevel,],
              'memorySize':[getMemorySize,setMemorySize,],
              'memoryBalloonSize':[getMemoryBalloonSize,setMemoryBalloonSize,],
              'pageFusionEnabled':[getPageFusionEnabled,setPageFusionEnabled,],
              'graphicsAdapter':[getGraphicsAdapter,None],
              'BIOSSettings':[getBIOSSettings,None],
              'recordingSettings':[getRecordingSettings,None],
              'firmwareType':[getFirmwareType,setFirmwareType,],
              'pointingHIDType':[getPointingHIDType,setPointingHIDType,],
              'keyboardHIDType':[getKeyboardHIDType,setKeyboardHIDType,],
              'HPETEnabled':[getHPETEnabled,setHPETEnabled,],
              'chipsetType':[getChipsetType,setChipsetType,],
              'snapshotFolder':[getSnapshotFolder,setSnapshotFolder,],
              'VRDEServer':[getVRDEServer,None],
              'emulatedUSBCardReaderEnabled':[getEmulatedUSBCardReaderEnabled,setEmulatedUSBCardReaderEnabled,],
              'mediumAttachments':[getMediumAttachments,None],
              'USBControllers':[getUSBControllers,None],
              'USBDeviceFilters':[getUSBDeviceFilters,None],
              'audioAdapter':[getAudioAdapter,None],
              'storageControllers':[getStorageControllers,None],
              'settingsFilePath':[getSettingsFilePath,None],
              'settingsAuxFilePath':[getSettingsAuxFilePath,None],
              'settingsModified':[getSettingsModified,None],
              'sessionState':[getSessionState,None],
              'sessionName':[getSessionName,None],
              'sessionPID':[getSessionPID,None],
              'state':[getState,None],
              'lastStateChange':[getLastStateChange,None],
              'stateFilePath':[getStateFilePath,None],
              'logFolder':[getLogFolder,None],
              'currentSnapshot':[getCurrentSnapshot,None],
              'snapshotCount':[getSnapshotCount,None],
              'currentStateModified':[getCurrentStateModified,None],
              'sharedFolders':[getSharedFolders,None],
              'clipboardMode':[getClipboardMode,setClipboardMode,],
              'clipboardFileTransfersEnabled':[getClipboardFileTransfersEnabled,setClipboardFileTransfersEnabled,],
              'dnDMode':[getDnDMode,setDnDMode,],
              'teleporterEnabled':[getTeleporterEnabled,setTeleporterEnabled,],
              'teleporterPort':[getTeleporterPort,setTeleporterPort,],
              'teleporterAddress':[getTeleporterAddress,setTeleporterAddress,],
              'teleporterPassword':[getTeleporterPassword,setTeleporterPassword,],
              'paravirtProvider':[getParavirtProvider,setParavirtProvider,],
              'RTCUseUTC':[getRTCUseUTC,setRTCUseUTC,],
              'IOCacheEnabled':[getIOCacheEnabled,setIOCacheEnabled,],
              'IOCacheSize':[getIOCacheSize,setIOCacheSize,],
              'PCIDeviceAssignments':[getPCIDeviceAssignments,None],
              'bandwidthControl':[getBandwidthControl,None],
              'tracingEnabled':[getTracingEnabled,setTracingEnabled,],
              'tracingConfig':[getTracingConfig,setTracingConfig,],
              'allowTracingToAccessVM':[getAllowTracingToAccessVM,setAllowTracingToAccessVM,],
              'autostartEnabled':[getAutostartEnabled,setAutostartEnabled,],
              'autostartDelay':[getAutostartDelay,setAutostartDelay,],
              'autostopType':[getAutostopType,setAutostopType,],
              'defaultFrontend':[getDefaultFrontend,setDefaultFrontend,],
              'USBProxyAvailable':[getUSBProxyAvailable,None],
              'VMProcessPriority':[getVMProcessPriority,setVMProcessPriority,],
              'paravirtDebug':[getParavirtDebug,setParavirtDebug,],
              'CPUProfile':[getCPUProfile,setCPUProfile,]}

class IEmulatedUSB(IUnknown):
   """
      Manages emulated USB devices.
    
      Interface ID:
        {6E253EE8-477A-2497-6759-88B8292A5AF0}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IEmulatedUSB(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IEmulatedUSB._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IEmulatedUSB._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def webcamAttach(self, _arg_path, _arg_settings):
       """
        Attaches the emulated USB webcam to the VM, which will use a host video capture device.
      
        :param _arg_path: The host path of the capture device to use.
        :param _arg_settings: Optional settings.

       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_settings,)
       val = self.mgr.getService().IEmulatedUSB_webcamAttach(*req)
       
       return 

   def webcamDetach(self, _arg_path):
       """
        Detaches the emulated USB webcam from the VM
      
        :param _arg_path: The host path of the capture device to detach.

       """
   
       req = (self.handle,)
       req += (_arg_path,)
       val = self.mgr.getService().IEmulatedUSB_webcamDetach(*req)
       
       return 

   def getWebcams(self):
       """Lists attached virtual webcams. """
       val = self.mgr.getService().IEmulatedUSB_getWebcams(self.handle)
       return String(self.mgr, val, True)



   _Attrs_ = {'webcams':[getWebcams,None]}

class IConsole(IUnknown):
   """
      The IConsole interface represents an interface to control virtual
      machine execution.

      A console object gets created when a machine has been locked for a
      particular session (client process) using IMachine::lockMachine
      or IMachine::launchVMProcess. The console object can
      then be found in the session's ISession::console attribute.

      Methods of the IConsole interface allow the caller to query the current
      virtual machine execution state, pause the machine or power it down, save
      the machine state or take a snapshot, attach and detach removable media
      and so on.

      
        .. sealso:: ::ISession
      Interface ID:
        {872DA645-4A9B-1727-BEE2-5585105B9EED}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IConsole(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IConsole._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IConsole._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def powerUp(self):
       """
        Starts the virtual machine execution using the current machine
        state (that is, its current execution state, current settings and
        current storage devices).

        

        If the machine is powered off or aborted, the execution will
        start from the beginning (as if the real hardware were just
        powered on).

        If the machine is in the ::MachineState_Saved state,
        it will continue its execution the point where the state has
        been saved.

        If the machine IMachine::teleporterEnabled property is
        enabled on the machine being powered up, the machine will wait for an
        incoming teleportation in the ::MachineState_TeleportingIn
        state. The returned progress object will have at least three
        operations where the last three are defined as: (1) powering up and
        starting TCP server, (2) waiting for incoming teleportations, and
        (3) perform teleportation. These operations will be reflected as the
        last three operations of the progress objected returned by
        IMachine::launchVMProcess as well.

        
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine already running.
        VBOX_E_HOST_ERROR
          Host interface does not exist or name not set.
        VBOX_E_FILE_ERROR
          Invalid saved state file.
        
        .. note:: 
          This method is only useful for front-ends that want to actually
          execute virtual machines in their own process (like the VirtualBox
          or VBoxSDL front-ends). Unless you are intending to write such a
          front-end, do not call this method. If you simply want to
          start virtual machine execution using one of the existing front-ends
          (for example the VirtualBox GUI or headless server), use
          IMachine::launchVMProcess instead; these
          front-ends will power up the machine automatically for you.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_powerUp(*req)
       
       return IProgress(self.mgr, val)

   def powerUpPaused(self):
       """
        Identical to powerUp except that the VM will enter the
        ::MachineState_Paused state, instead of
        ::MachineState_Running.

        
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine already running.
        VBOX_E_HOST_ERROR
          Host interface does not exist or name not set.
        VBOX_E_FILE_ERROR
          Invalid saved state file.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_powerUpPaused(*req)
       
       return IProgress(self.mgr, val)

   def powerDown(self):
       """
        Initiates the power down procedure to stop the virtual machine
        execution.

        The completion of the power down procedure is tracked using the returned
        IProgress object. After the operation is complete, the machine will go
        to the PoweredOff state.
        
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine must be Running, Paused or Stuck to be powered down.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_powerDown(*req)
       
       return IProgress(self.mgr, val)

   def reset(self):
       """Resets the virtual machine.
        

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine not in Running state.
        VBOX_E_VM_ERROR
          Virtual machine error in reset operation.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_reset(*req)
       
       return 

   def pause(self):
       """Pauses the virtual machine execution.
        

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine not in Running state.
        VBOX_E_VM_ERROR
          Virtual machine error in suspend operation.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_pause(*req)
       
       return 

   def resume(self):
       """Resumes the virtual machine execution.
        

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine not in Paused state.
        VBOX_E_VM_ERROR
          Virtual machine error in resume operation.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_resume(*req)
       
       return 

   def powerButton(self):
       """Sends the ACPI power button event to the guest.
        

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine not in Running state.
        VBOX_E_PDM_ERROR
          Controlled power off failed.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_powerButton(*req)
       
       return 

   def sleepButton(self):
       """Sends the ACPI sleep button event to the guest.
        

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine not in Running state.
        VBOX_E_PDM_ERROR
          Sending sleep button event failed.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_sleepButton(*req)
       
       return 

   def getPowerButtonHandled(self):
       """Checks if the last power button event was handled by guest.
        
        :return: 
        :rtype: boolean

        Expected result codes:
        VBOX_E_PDM_ERROR
          Checking if the event was handled by the guest OS failed.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_getPowerButtonHandled(*req)
       
       return Boolean(self.mgr, val)

   def getGuestEnteredACPIMode(self):
       """Checks if the guest entered the ACPI mode G0 (working) or
        G1 (sleeping). If this method returns @c false, the guest will
        most likely not respond to external ACPI events.
        
        :return: 
        :rtype: boolean

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine not in Running state.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_getGuestEnteredACPIMode(*req)
       
       return Boolean(self.mgr, val)

   def getDeviceActivity(self, _arg_type):
       """
        Gets the current activity type of given devices or device groups.
        
        :param _arg_type: 
        :return: 
        :rtype: List[DeviceActivity]

        Expected result codes:
        E_INVALIDARG
          Invalid device type.
        
       """
   
       req = (self.handle,)
       req += (_arg_type,)
       val = self.mgr.getService().IConsole_getDeviceActivity(*req)
       
       return DeviceActivity(self.mgr, val, True)

   def attachUSBDevice(self, _arg_id, _arg_captureFilename):
       """
        Attaches a host USB device with the given UUID to the
        USB controller of the virtual machine.

        The device needs to be in one of the following states:
        ::USBDeviceState_Busy,
        ::USBDeviceState_Available or
        ::USBDeviceState_Held,
        otherwise an error is immediately returned.

        When the device state is
        ::USBDeviceState_Busy, an error may also
        be returned if the host computer refuses to release it for some reason.

        
        :param _arg_id: UUID of the host USB device to attach.
        :param _arg_captureFilename: Filename to capture the USB traffic to.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine state neither Running nor Paused.
        VBOX_E_PDM_ERROR
          Virtual machine does not have a USB controller.
        
       """
   
       req = (self.handle,)
       req += (_arg_id,)
       req += (_arg_captureFilename,)
       val = self.mgr.getService().IConsole_attachUSBDevice(*req)
       
       return 

   def detachUSBDevice(self, _arg_id):
       """
        Detaches an USB device with the given UUID from the USB controller
        of the virtual machine.

        After this method succeeds, the VirtualBox server re-initiates
        all USB filters as if the device were just physically attached
        to the host, but filters of this machine are ignored to avoid
        a possible automatic re-attachment.

        
        :param _arg_id: UUID of the USB device to detach.
        :return: Detached USB device.
        :rtype: IUSBDevice

        Expected result codes:
        VBOX_E_PDM_ERROR
          Virtual machine does not have a USB controller.
        E_INVALIDARG
          USB device not attached to this virtual machine.
        
       """
   
       req = (self.handle,)
       req += (_arg_id,)
       val = self.mgr.getService().IConsole_detachUSBDevice(*req)
       
       return IUSBDevice(self.mgr, val)

   def findUSBDeviceByAddress(self, _arg_name):
       """
        Searches for a USB device with the given host address.

        
        :param _arg_name: Address of the USB device (as assigned by the host) to search for.
        :return: Found USB device object.
        :rtype: IUSBDevice

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Given @c name does not correspond to any USB device.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IConsole_findUSBDeviceByAddress(*req)
       
       return IUSBDevice(self.mgr, val)

   def findUSBDeviceById(self, _arg_id):
       """
        Searches for a USB device with the given UUID.

        
        :param _arg_id: UUID of the USB device to search for.
        :return: Found USB device object.
        :rtype: IUSBDevice

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Given @c id does not correspond to any USB device.
        
       """
   
       req = (self.handle,)
       req += (_arg_id,)
       val = self.mgr.getService().IConsole_findUSBDeviceById(*req)
       
       return IUSBDevice(self.mgr, val)

   def createSharedFolder(self, _arg_name, _arg_hostPath, _arg_writable, _arg_automount, _arg_autoMountPoint):
       """
        Creates a transient new shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        ::ISharedFolder to read more about logical names.

        
        :param _arg_name: Unique logical name of the shared folder.
        :param _arg_hostPath: Full path to the shared folder in the host file system.
        :param _arg_writable: Whether the share is writable or readonly
        :param _arg_automount: Whether the share gets automatically mounted by the guest or not.
        :param _arg_autoMountPoint: Where the guest should automatically mount the folder, if possible. For Windows and OS/2 guests this should be a drive letter, while other guests it should be a absolute directory.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine in Saved state or currently changing state.
        VBOX_E_FILE_ERROR
          Shared folder already exists or not accessible.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_hostPath,)
       req += (_arg_writable,)
       req += (_arg_automount,)
       req += (_arg_autoMountPoint,)
       val = self.mgr.getService().IConsole_createSharedFolder(*req)
       
       return 

   def removeSharedFolder(self, _arg_name):
       """
        Removes a transient shared folder with the given name previously
        created by #createSharedFolder from the collection of
        shared folders and stops sharing it.
        
        :param _arg_name: Logical name of the shared folder to remove.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine in Saved state or currently changing state.
        VBOX_E_FILE_ERROR
          Shared folder does not exists.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IConsole_removeSharedFolder(*req)
       
       return 

   def teleport(self, _arg_hostname, _arg_tcpport, _arg_password, _arg_maxDowntime):
       """
        Teleport the VM to a different host machine or process.

        @todo Explain the details.

        
        :param _arg_hostname: The name or IP of the host to teleport to.
        :param _arg_tcpport: The TCP port to connect to (1..65535).
        :param _arg_password: The password.
        :param _arg_maxDowntime: The maximum allowed downtime given as milliseconds. 0 is not a valid value. Recommended value: 250 ms. The higher the value is, the greater the chance for a successful teleportation. A small value may easily result in the teleportation process taking hours and eventually fail. The current implementation treats this a guideline, not as an absolute rule.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine not running or paused.
        
        .. note:: 
            The current implementation treats this a guideline, not as an
            absolute rule.
          
       """
   
       req = (self.handle,)
       req += (_arg_hostname,)
       req += (_arg_tcpport,)
       req += (_arg_password,)
       req += (_arg_maxDowntime,)
       val = self.mgr.getService().IConsole_teleport(*req)
       
       return IProgress(self.mgr, val)

   def addDiskEncryptionPassword(self, _arg_id, _arg_password, _arg_clearOnSuspend):
       """
        Adds a password used for hard disk encryption/decryption.

        
        :param _arg_id: The identifier used for the password. Must match the identifier used when the encrypted medium was created.
        :param _arg_password: The password.
        :param _arg_clearOnSuspend: Flag whether to clear the password on VM suspend (due to a suspending host for example). The password must be supplied again before the VM can resume.

        Expected result codes:
        VBOX_E_PASSWORD_INCORRECT
          The password provided wasn't correct for at least one disk using the provided
          ID.
        
       """
   
       req = (self.handle,)
       req += (_arg_id,)
       req += (_arg_password,)
       req += (_arg_clearOnSuspend,)
       val = self.mgr.getService().IConsole_addDiskEncryptionPassword(*req)
       
       return 

   def addDiskEncryptionPasswords(self, _arg_ids, _arg_passwords, _arg_clearOnSuspend):
       """
        Adds a password used for hard disk encryption/decryption.

        
        :param _arg_ids: List of identifiers for the passwords. Must match the identifier used when the encrypted medium was created.
        :param _arg_passwords: List of passwords.
        :param _arg_clearOnSuspend: Flag whether to clear the given passwords on VM suspend (due to a suspending host for example). The passwords must be supplied again before the VM can resume.

        Expected result codes:
        VBOX_E_PASSWORD_INCORRECT
          The password provided wasn't correct for at least one disk using the provided
          ID.
        
       """
   
       req = (self.handle,)
       req += (_arg_ids,)
       req += (_arg_passwords,)
       req += (_arg_clearOnSuspend,)
       val = self.mgr.getService().IConsole_addDiskEncryptionPasswords(*req)
       
       return 

   def removeDiskEncryptionPassword(self, _arg_id):
       """
        Removes a password used for hard disk encryption/decryption from
        the running VM. As soon as the medium requiring this password
        is accessed the VM is paused with an error and the password must be
        provided again.
      
        :param _arg_id: The identifier used for the password. Must match the identifier used when the encrypted medium was created.

       """
   
       req = (self.handle,)
       req += (_arg_id,)
       val = self.mgr.getService().IConsole_removeDiskEncryptionPassword(*req)
       
       return 

   def clearAllDiskEncryptionPasswords(self):
       """Clears all provided supplied disk encryption passwords.

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IConsole_clearAllDiskEncryptionPasswords(*req)
       
       return 

   def getMachine(self):
       """
        Machine object for this console session.
        
        .. note:: 
          This is a convenience property, it has the same value as
          ISession::machine of the corresponding session
          object.
         """
       val = self.mgr.getService().IConsole_getMachine(self.handle)
       return IMachine(self.mgr, val)

   def getState(self):
       """
        Current execution state of the machine.
        
        .. note:: 
          This property always returns the same value as the corresponding
          property of the IMachine object for this console session.
          For the process that owns (executes) the VM, this is the
          preferable way of querying the VM state, because no IPC
          calls are made.
         """
       val = self.mgr.getService().IConsole_getState(self.handle)
       return MachineState(self.mgr, val)

   def getGuest(self):
       """Guest object. """
       val = self.mgr.getService().IConsole_getGuest(self.handle)
       return IGuest(self.mgr, val)

   def getKeyboard(self):
       """
        Virtual keyboard object.
        
        .. note:: 
          If the machine is not running, any attempt to use
          the returned object will result in an error.
         """
       val = self.mgr.getService().IConsole_getKeyboard(self.handle)
       return IKeyboard(self.mgr, val)

   def getMouse(self):
       """
        Virtual mouse object.
        
        .. note:: 
          If the machine is not running, any attempt to use
          the returned object will result in an error.
         """
       val = self.mgr.getService().IConsole_getMouse(self.handle)
       return IMouse(self.mgr, val)

   def getDisplay(self):
       """Virtual display object.
        
        .. note:: 
          If the machine is not running, any attempt to use
          the returned object will result in an error.
         """
       val = self.mgr.getService().IConsole_getDisplay(self.handle)
       return IDisplay(self.mgr, val)

   def getDebugger(self):
       """Debugging interface. """
       val = self.mgr.getService().IConsole_getDebugger(self.handle)
       return IMachineDebugger(self.mgr, val)

   def getUSBDevices(self):
       """
        Collection of USB devices currently attached to the virtual
        USB controller.
        
        .. note:: 
          The collection is empty if the machine is not running.
         """
       val = self.mgr.getService().IConsole_getUSBDevices(self.handle)
       return IUSBDevice(self.mgr, val, True)

   def getRemoteUSBDevices(self):
       """
        List of USB devices currently attached to the remote VRDE client.
        Once a new device is physically attached to the remote host computer,
        it appears in this list and remains there until detached.
       """
       val = self.mgr.getService().IConsole_getRemoteUSBDevices(self.handle)
       return IHostUSBDevice(self.mgr, val, True)

   def getSharedFolders(self):
       """
        Collection of shared folders for the current session. These folders
        are called transient shared folders because they are available to the
        guest OS running inside the associated virtual machine only for the
        duration of the session (as opposed to
        IMachine::sharedFolders which represent permanent shared
        folders). When the session is closed (e.g. the machine is powered down),
        these folders are automatically discarded.

        New shared folders are added to the collection using
        #createSharedFolder. Existing shared folders can be
        removed using #removeSharedFolder.
       """
       val = self.mgr.getService().IConsole_getSharedFolders(self.handle)
       return ISharedFolder(self.mgr, val, True)

   def getVRDEServerInfo(self):
       """
        Interface that provides information on Remote Desktop Extension (VRDE) connection.
       """
       val = self.mgr.getService().IConsole_getVRDEServerInfo(self.handle)
       return IVRDEServerInfo(self.mgr, val)

   def getEventSource(self):
       """
        Event source for console events.
       """
       val = self.mgr.getService().IConsole_getEventSource(self.handle)
       return IEventSource(self.mgr, val)

   def getAttachedPCIDevices(self):
       """Array of PCI devices attached to this machine. """
       val = self.mgr.getService().IConsole_getAttachedPCIDevices(self.handle)
       return IPCIDeviceAttachment(self.mgr, val, True)

   def getUseHostClipboard(self):
       """
        Whether the guest clipboard should be connected to the host one or
        whether it should only be allowed access to the VRDE clipboard. This
        setting may not affect existing guest clipboard connections which
        are already connected to the host clipboard.
       """
       val = self.mgr.getService().IConsole_getUseHostClipboard(self.handle)
       return Boolean(self.mgr, val)

   def setUseHostClipboard(self, value):
       """
        Whether the guest clipboard should be connected to the host one or
        whether it should only be allowed access to the VRDE clipboard. This
        setting may not affect existing guest clipboard connections which
        are already connected to the host clipboard.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IConsole_setUseHostClipboard(_this, _val)

   def getEmulatedUSB(self):
       """
        Interface that manages emulated USB devices.
       """
       val = self.mgr.getService().IConsole_getEmulatedUSB(self.handle)
       return IEmulatedUSB(self.mgr, val)



   _Attrs_ = {'machine':[getMachine,None],
              'state':[getState,None],
              'guest':[getGuest,None],
              'keyboard':[getKeyboard,None],
              'mouse':[getMouse,None],
              'display':[getDisplay,None],
              'debugger':[getDebugger,None],
              'USBDevices':[getUSBDevices,None],
              'remoteUSBDevices':[getRemoteUSBDevices,None],
              'sharedFolders':[getSharedFolders,None],
              'VRDEServerInfo':[getVRDEServerInfo,None],
              'eventSource':[getEventSource,None],
              'attachedPCIDevices':[getAttachedPCIDevices,None],
              'useHostClipboard':[getUseHostClipboard,setUseHostClipboard,],
              'emulatedUSB':[getEmulatedUSB,None]}

class IHostNetworkInterface(IUnknown):
   """
      Represents one of host's network interfaces. IP V6 address and network
      mask are strings of 32 hexadecimal digits grouped by four. Groups are
      separated by colons.
      For example, fe80:0000:0000:0000:021e:c2ff:fed2:b030.
    
      Interface ID:
        {455F8C45-44A0-A470-BA20-27890B96DBA9}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IHostNetworkInterface(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostNetworkInterface._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostNetworkInterface._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def enableStaticIPConfig(self, _arg_IPAddress, _arg_networkMask):
       """sets and enables the static IP V4 configuration for the given interface.
        :param _arg_IPAddress: IP address.
        :param _arg_networkMask: network mask.

       """
   
       req = (self.handle,)
       req += (_arg_IPAddress,)
       req += (_arg_networkMask,)
       val = self.mgr.getService().IHostNetworkInterface_enableStaticIPConfig(*req)
       
       return 

   def enableStaticIPConfigV6(self, _arg_IPV6Address, _arg_IPV6NetworkMaskPrefixLength):
       """sets and enables the static IP V6 configuration for the given interface.
        :param _arg_IPV6Address: IP address.
        :param _arg_IPV6NetworkMaskPrefixLength: network mask.

       """
   
       req = (self.handle,)
       req += (_arg_IPV6Address,)
       req += (_arg_IPV6NetworkMaskPrefixLength,)
       val = self.mgr.getService().IHostNetworkInterface_enableStaticIPConfigV6(*req)
       
       return 

   def enableDynamicIPConfig(self):
       """enables the dynamic IP configuration.

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IHostNetworkInterface_enableDynamicIPConfig(*req)
       
       return 

   def DHCPRediscover(self):
       """refreshes the IP configuration for DHCP-enabled interface.

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IHostNetworkInterface_DHCPRediscover(*req)
       
       return 

   def getName(self):
       """Returns the host network interface name. """
       val = self.mgr.getService().IHostNetworkInterface_getName(self.handle)
       return String(self.mgr, val)

   def getShortName(self):
       """Returns the host network interface short name. """
       val = self.mgr.getService().IHostNetworkInterface_getShortName(self.handle)
       return String(self.mgr, val)

   def getId(self):
       """Returns the interface UUID. """
       val = self.mgr.getService().IHostNetworkInterface_getId(self.handle)
       return String(self.mgr, val)

   def getNetworkName(self):
       """Returns the name of a virtual network the interface gets attached to. """
       val = self.mgr.getService().IHostNetworkInterface_getNetworkName(self.handle)
       return String(self.mgr, val)

   def getDHCPEnabled(self):
       """Specifies whether the DHCP is enabled for the interface. """
       val = self.mgr.getService().IHostNetworkInterface_getDHCPEnabled(self.handle)
       return Boolean(self.mgr, val)

   def getIPAddress(self):
       """Returns the IP V4 address of the interface. """
       val = self.mgr.getService().IHostNetworkInterface_getIPAddress(self.handle)
       return String(self.mgr, val)

   def getNetworkMask(self):
       """Returns the network mask of the interface. """
       val = self.mgr.getService().IHostNetworkInterface_getNetworkMask(self.handle)
       return String(self.mgr, val)

   def getIPV6Supported(self):
       """Specifies whether the IP V6 is supported/enabled for the interface. """
       val = self.mgr.getService().IHostNetworkInterface_getIPV6Supported(self.handle)
       return Boolean(self.mgr, val)

   def getIPV6Address(self):
       """Returns the IP V6 address of the interface. """
       val = self.mgr.getService().IHostNetworkInterface_getIPV6Address(self.handle)
       return String(self.mgr, val)

   def getIPV6NetworkMaskPrefixLength(self):
       """Returns the length IP V6 network mask prefix of the interface. """
       val = self.mgr.getService().IHostNetworkInterface_getIPV6NetworkMaskPrefixLength(self.handle)
       return UnsignedInt(self.mgr, val)

   def getHardwareAddress(self):
       """Returns the hardware address. For Ethernet it is MAC address. """
       val = self.mgr.getService().IHostNetworkInterface_getHardwareAddress(self.handle)
       return String(self.mgr, val)

   def getMediumType(self):
       """Type of protocol encapsulation used. """
       val = self.mgr.getService().IHostNetworkInterface_getMediumType(self.handle)
       return HostNetworkInterfaceMediumType(self.mgr, val)

   def getStatus(self):
       """Status of the interface. """
       val = self.mgr.getService().IHostNetworkInterface_getStatus(self.handle)
       return HostNetworkInterfaceStatus(self.mgr, val)

   def getInterfaceType(self):
       """specifies the host interface type. """
       val = self.mgr.getService().IHostNetworkInterface_getInterfaceType(self.handle)
       return HostNetworkInterfaceType(self.mgr, val)

   def getWireless(self):
       """Specifies whether the interface is wireless. """
       val = self.mgr.getService().IHostNetworkInterface_getWireless(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'name':[getName,None],
              'shortName':[getShortName,None],
              'id':[getId,None],
              'networkName':[getNetworkName,None],
              'DHCPEnabled':[getDHCPEnabled,None],
              'IPAddress':[getIPAddress,None],
              'networkMask':[getNetworkMask,None],
              'IPV6Supported':[getIPV6Supported,None],
              'IPV6Address':[getIPV6Address,None],
              'IPV6NetworkMaskPrefixLength':[getIPV6NetworkMaskPrefixLength,None],
              'hardwareAddress':[getHardwareAddress,None],
              'mediumType':[getMediumType,None],
              'status':[getStatus,None],
              'interfaceType':[getInterfaceType,None],
              'wireless':[getWireless,None]}

class IHostVideoInputDevice(IUnknown):
   """
      Represents one of host's video capture devices, for example a webcam.
    
      Interface ID:
        {E8C25D4D-AC97-4C16-B3E2-81BD8A57CC27}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IHostVideoInputDevice(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostVideoInputDevice._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostVideoInputDevice._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getName(self):
       """User friendly name. """
       val = self.mgr.getService().IHostVideoInputDevice_getName(self.handle)
       return String(self.mgr, val)

   def getPath(self):
       """The host path of the device. """
       val = self.mgr.getService().IHostVideoInputDevice_getPath(self.handle)
       return String(self.mgr, val)

   def getAlias(self):
       """An alias which can be used for IEmulatedUSB::webcamAttach """
       val = self.mgr.getService().IHostVideoInputDevice_getAlias(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'name':[getName,None],
              'path':[getPath,None],
              'alias':[getAlias,None]}

class IHostUpdate(IUnknown):
   """
      Represents the state of the update checking logic (a singleton returned
      by IHost::update attribute).
    
      Interface ID:
        {6FA2671B-0547-448E-BC7C-94E9E173BF57}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IHostUpdate(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostUpdate._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostUpdate._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   


   _Attrs_ = {}

class IHost(IUnknown):
   """
      The IHost interface represents the physical machine that this VirtualBox
      installation runs on.

      An object implementing this interface is returned by the
      IVirtualBox::host attribute. This interface contains
      read-only information about the host's physical hardware (such as what
      processors and disks are available, what the host operating system is,
      and so on) and also allows for manipulating some of the host's hardware,
      such as global USB device filters and host interface networking.

    
      Interface ID:
        {16CED992-5FDC-4ABA-AFF5-6A39BBD7C38B}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IHost(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHost._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHost._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getProcessorSpeed(self, _arg_cpuId):
       """Query the (approximate) maximum speed of a specified host CPU in
        Megahertz.
      
        :param _arg_cpuId: Identifier of the CPU.
        :return: Speed value. 0 is returned if value is not known or @a cpuId is invalid.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       val = self.mgr.getService().IHost_getProcessorSpeed(*req)
       
       return UnsignedInt(self.mgr, val)

   def getProcessorFeature(self, _arg_feature):
       """Query whether a CPU feature is supported or not.
        :param _arg_feature: CPU Feature identifier.
        :return: Feature is supported or not.
        :rtype: boolean

       """
   
       req = (self.handle,)
       req += (_arg_feature,)
       val = self.mgr.getService().IHost_getProcessorFeature(*req)
       
       return Boolean(self.mgr, val)

   def getProcessorDescription(self, _arg_cpuId):
       """Query the model string of a specified host CPU.
      
        :param _arg_cpuId: Identifier of the CPU. The current implementation might not necessarily return the description for this exact CPU.
        :return: Model string. An empty string is returned if value is not known or @a cpuId is invalid.
        :rtype: wstring

        .. note:: 
            The current implementation might not necessarily return the
            description for this exact CPU.
          
       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       val = self.mgr.getService().IHost_getProcessorDescription(*req)
       
       return String(self.mgr, val)

   def getProcessorCPUIDLeaf(self, _arg_cpuId, _arg_leaf, _arg_subLeaf):
       """
        Returns the CPU cpuid information for the specified leaf.
      
        :param _arg_cpuId: Identifier of the CPU. The CPU most be online. The current implementation might not necessarily return the description for this exact CPU.
        :param _arg_leaf: CPUID leaf index (eax).
        :param _arg_subLeaf: CPUID leaf sub index (ecx). This currently only applies to cache information on Intel CPUs. Use 0 if retrieving values for .





        .. note:: 
            The current implementation might not necessarily return the
            description for this exact CPU.
          
       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       req += (_arg_leaf,)
       req += (_arg_subLeaf,)
       val = self.mgr.getService().IHost_getProcessorCPUIDLeaf(*req)
       
       return UnsignedInt(self.mgr,val["valEax"]), UnsignedInt(self.mgr,val["valEbx"]), UnsignedInt(self.mgr,val["valEcx"]), UnsignedInt(self.mgr,val["valEdx"])

   def createHostOnlyNetworkInterface(self):
       """
        Creates a new adapter for Host Only Networking.
        

        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        E_INVALIDARG
          Host network interface @a name already exists.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IHost_createHostOnlyNetworkInterface(*req)
       
       return IProgress(self.mgr,val["returnval"]), IHostNetworkInterface(self.mgr,val["hostInterface"])

   def removeHostOnlyNetworkInterface(self, _arg_id):
       """
        Removes the given Host Only Networking interface.
        
        :param _arg_id: Adapter GUID.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          No host network interface matching @a id found.
        
       """
   
       req = (self.handle,)
       req += (_arg_id,)
       val = self.mgr.getService().IHost_removeHostOnlyNetworkInterface(*req)
       
       return IProgress(self.mgr, val)

   def createUSBDeviceFilter(self, _arg_name):
       """
        Creates a new USB device filter. All attributes except
        the filter name are set to empty (any match),
        active is @c false (the filter is not active).

        The created filter can be added to the list of filters using
        #insertUSBDeviceFilter.

        
        :param _arg_name: Filter name. See for more information.
        :return: Created filter object.
        :rtype: IHostUSBDeviceFilter

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IHost_createUSBDeviceFilter(*req)
       
       return IHostUSBDeviceFilter(self.mgr, val)

   def insertUSBDeviceFilter(self, _arg_position, _arg_filter):
       """
        Inserts the given USB device to the specified position
        in the list of filters.

        Positions are numbered starting from @c 0. If the specified
        position is equal to or greater than the number of elements in
        the list, the filter is added at the end of the collection.

        
        :param _arg_position: Position to insert the filter to.
        :param _arg_filter: USB device filter to insert.

        Expected result codes:
        VBOX_E_INVALID_OBJECT_STATE
          USB device filter is not created within this VirtualBox instance.
        E_INVALIDARG
          USB device filter already in list.
        
        .. note:: 
          Duplicates are not allowed, so an attempt to insert a
          filter already in the list is an error.
        
        .. note:: 
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        
       """
   
       req = (self.handle,)
       req += (_arg_position,)
       req += (_arg_filter,)
       val = self.mgr.getService().IHost_insertUSBDeviceFilter(*req)
       
       return 

   def removeUSBDeviceFilter(self, _arg_position):
       """
        Removes a USB device filter from the specified position in the
        list of filters.

        Positions are numbered starting from @c 0. Specifying a
        position equal to or greater than the number of elements in
        the list will produce an error.

        
        :param _arg_position: Position to remove the filter from.

        Expected result codes:
        E_INVALIDARG
          USB device filter list empty or invalid @a position.
        
        .. note:: 
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        
       """
   
       req = (self.handle,)
       req += (_arg_position,)
       val = self.mgr.getService().IHost_removeUSBDeviceFilter(*req)
       
       return 

   def findHostDVDDrive(self, _arg_name):
       """
        Searches for a host DVD drive with the given @c name.

        
        :param _arg_name: Name of the host drive to search for
        :return: Found host drive object
        :rtype: IMedium

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Given @c name does not correspond to any host drive.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IHost_findHostDVDDrive(*req)
       
       return IMedium(self.mgr, val)

   def findHostFloppyDrive(self, _arg_name):
       """
        Searches for a host floppy drive with the given @c name.

        
        :param _arg_name: Name of the host floppy drive to search for
        :return: Found host floppy drive object
        :rtype: IMedium

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Given @c name does not correspond to any host floppy drive.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IHost_findHostFloppyDrive(*req)
       
       return IMedium(self.mgr, val)

   def findHostNetworkInterfaceByName(self, _arg_name):
       """
        Searches through all host network interfaces for an interface with
        the given @c name.
        
        :param _arg_name: Name of the host network interface to search for.
        :return: Found host network interface object.
        :rtype: IHostNetworkInterface

        .. note:: 
          The method returns an error if the given @c name does not
          correspond to any host network interface.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IHost_findHostNetworkInterfaceByName(*req)
       
       return IHostNetworkInterface(self.mgr, val)

   def findHostNetworkInterfaceById(self, _arg_id):
       """
        Searches through all host network interfaces for an interface with
        the given GUID.
        
        :param _arg_id: GUID of the host network interface to search for.
        :return: Found host network interface object.
        :rtype: IHostNetworkInterface

        .. note:: 
          The method returns an error if the given GUID does not
          correspond to any host network interface.
        
       """
   
       req = (self.handle,)
       req += (_arg_id,)
       val = self.mgr.getService().IHost_findHostNetworkInterfaceById(*req)
       
       return IHostNetworkInterface(self.mgr, val)

   def findHostNetworkInterfacesOfType(self, _arg_type):
       """
        Searches through all host network interfaces and returns a list of interfaces of the specified type
      
        :param _arg_type: type of the host network interfaces to search for.
        :return: Found host network interface objects.
        :rtype: List[IHostNetworkInterface]

       """
   
       req = (self.handle,)
       req += (_arg_type,)
       val = self.mgr.getService().IHost_findHostNetworkInterfacesOfType(*req)
       
       return IHostNetworkInterface(self.mgr, val, True)

   def findUSBDeviceById(self, _arg_id):
       """
        Searches for a USB device with the given UUID.

        
        :param _arg_id: UUID of the USB device to search for.
        :return: Found USB device object.
        :rtype: IHostUSBDevice

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Given @c id does not correspond to any USB device.
        
       """
   
       req = (self.handle,)
       req += (_arg_id,)
       val = self.mgr.getService().IHost_findUSBDeviceById(*req)
       
       return IHostUSBDevice(self.mgr, val)

   def findUSBDeviceByAddress(self, _arg_name):
       """
        Searches for a USB device with the given host address.

        
        :param _arg_name: Address of the USB device (as assigned by the host) to search for.
        :return: Found USB device object.
        :rtype: IHostUSBDevice

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Given @c name does not correspond to any USB device.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IHost_findUSBDeviceByAddress(*req)
       
       return IHostUSBDevice(self.mgr, val)

   def generateMACAddress(self):
       """
        Generates a valid Ethernet MAC address, 12 hexadecimal characters.
      
        :return: New Ethernet MAC address.
        :rtype: wstring

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IHost_generateMACAddress(*req)
       
       return String(self.mgr, val)

   def addUSBDeviceSource(self, _arg_backend, _arg_id, _arg_address, _arg_propertyNames, _arg_propertyValues):
       """
        Adds a new USB device source.
      
        :param _arg_backend: The backend to use as the new device source.
        :param _arg_id: Unique ID to identify the source.
        :param _arg_address: Address to use, the format is dependent on the backend. For USB/IP backends for example the notation is host[:port].
        :param _arg_propertyNames: Array of property names for more detailed configuration. Not used at the moment.
        :param _arg_propertyValues: Array of property values for more detailed configuration. Not used at the moment.

       """
   
       req = (self.handle,)
       req += (_arg_backend,)
       req += (_arg_id,)
       req += (_arg_address,)
       req += (_arg_propertyNames,)
       req += (_arg_propertyValues,)
       val = self.mgr.getService().IHost_addUSBDeviceSource(*req)
       
       return 

   def removeUSBDeviceSource(self, _arg_id):
       """
        Removes a previously added USB device source.
      
        :param _arg_id: The identifier used when the source was added.

       """
   
       req = (self.handle,)
       req += (_arg_id,)
       val = self.mgr.getService().IHost_removeUSBDeviceSource(*req)
       
       return 

   def getDVDDrives(self):
       """List of DVD drives available on the host. """
       val = self.mgr.getService().IHost_getDVDDrives(self.handle)
       return IMedium(self.mgr, val, True)

   def getFloppyDrives(self):
       """List of floppy drives available on the host. """
       val = self.mgr.getService().IHost_getFloppyDrives(self.handle)
       return IMedium(self.mgr, val, True)

   def getUSBDevices(self):
       """
        List of USB devices currently attached to the host.
        Once a new device is physically attached to the host computer,
        it appears in this list and remains there until detached.

        
        .. note:: 
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
         """
       val = self.mgr.getService().IHost_getUSBDevices(self.handle)
       return IHostUSBDevice(self.mgr, val, True)

   def getUSBDeviceFilters(self):
       """
        List of USB device filters in action.
        When a new device is physically attached to the host computer,
        filters from this list are applied to it (in order they are stored
        in the list). The first matched filter will determine the
        IHostUSBDeviceFilter::action
        performed on the device.

        Unless the device is ignored by these filters, filters of all
        currently running virtual machines
        (IUSBDeviceFilters::deviceFilters) are applied to it.

        
        .. note:: 
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        
        .. sealso:: ::IHostUSBDeviceFilter,
          ::USBDeviceState """
       val = self.mgr.getService().IHost_getUSBDeviceFilters(self.handle)
       return IHostUSBDeviceFilter(self.mgr, val, True)

   def getNetworkInterfaces(self):
       """List of host network interfaces currently defined on the host. """
       val = self.mgr.getService().IHost_getNetworkInterfaces(self.handle)
       return IHostNetworkInterface(self.mgr, val, True)

   def getNameServers(self):
       """ The list of nameservers registered in host's name resolving system. """
       val = self.mgr.getService().IHost_getNameServers(self.handle)
       return String(self.mgr, val, True)

   def getDomainName(self):
       """Domain name used for name resolving. """
       val = self.mgr.getService().IHost_getDomainName(self.handle)
       return String(self.mgr, val)

   def getSearchStrings(self):
       """Search string registered for name resolving. """
       val = self.mgr.getService().IHost_getSearchStrings(self.handle)
       return String(self.mgr, val, True)

   def getProcessorCount(self):
       """Number of (logical) CPUs installed in the host system. """
       val = self.mgr.getService().IHost_getProcessorCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getProcessorOnlineCount(self):
       """Number of (logical) CPUs online in the host system. """
       val = self.mgr.getService().IHost_getProcessorOnlineCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getProcessorCoreCount(self):
       """Number of physical processor cores installed in the host system. """
       val = self.mgr.getService().IHost_getProcessorCoreCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getProcessorOnlineCoreCount(self):
       """Number of physical processor cores online in the host system. """
       val = self.mgr.getService().IHost_getProcessorOnlineCoreCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMemorySize(self):
       """Amount of system memory in megabytes installed in the host system. """
       val = self.mgr.getService().IHost_getMemorySize(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMemoryAvailable(self):
       """Available system memory in the host system. """
       val = self.mgr.getService().IHost_getMemoryAvailable(self.handle)
       return UnsignedInt(self.mgr, val)

   def getOperatingSystem(self):
       """Name of the host system's operating system. """
       val = self.mgr.getService().IHost_getOperatingSystem(self.handle)
       return String(self.mgr, val)

   def getOSVersion(self):
       """Host operating system's version string. """
       val = self.mgr.getService().IHost_getOSVersion(self.handle)
       return String(self.mgr, val)

   def getUTCTime(self):
       """Returns the current host time in milliseconds since 1970-01-01 UTC. """
       val = self.mgr.getService().IHost_getUTCTime(self.handle)
       return Long(self.mgr, val)

   def getAcceleration3DAvailable(self):
       """Returns @c true when the host supports 3D hardware acceleration. """
       val = self.mgr.getService().IHost_getAcceleration3DAvailable(self.handle)
       return Boolean(self.mgr, val)

   def getVideoInputDevices(self):
       """List of currently available host video capture devices. """
       val = self.mgr.getService().IHost_getVideoInputDevices(self.handle)
       return IHostVideoInputDevice(self.mgr, val, True)

   def getUpdate(self):
       """List of floppy drives available on the host. """
       val = self.mgr.getService().IHost_getUpdate(self.handle)
       return IHostUpdate(self.mgr, val)



   _Attrs_ = {'DVDDrives':[getDVDDrives,None],
              'floppyDrives':[getFloppyDrives,None],
              'USBDevices':[getUSBDevices,None],
              'USBDeviceFilters':[getUSBDeviceFilters,None],
              'networkInterfaces':[getNetworkInterfaces,None],
              'nameServers':[getNameServers,None],
              'domainName':[getDomainName,None],
              'searchStrings':[getSearchStrings,None],
              'processorCount':[getProcessorCount,None],
              'processorOnlineCount':[getProcessorOnlineCount,None],
              'processorCoreCount':[getProcessorCoreCount,None],
              'processorOnlineCoreCount':[getProcessorOnlineCoreCount,None],
              'memorySize':[getMemorySize,None],
              'memoryAvailable':[getMemoryAvailable,None],
              'operatingSystem':[getOperatingSystem,None],
              'OSVersion':[getOSVersion,None],
              'UTCTime':[getUTCTime,None],
              'acceleration3DAvailable':[getAcceleration3DAvailable,None],
              'videoInputDevices':[getVideoInputDevices,None],
              'update':[getUpdate,None]}

class ISystemProperties(IUnknown):
   """
      The ISystemProperties interface represents global properties of the given
      VirtualBox installation.

      These properties define limits and default values for various attributes
      and parameters. Most of the properties are read-only, but some can be
      changed by a user.
    
      Interface ID:
        {027BC463-929C-40E8-BF16-FEA557CD8E7E}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISystemProperties(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISystemProperties._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISystemProperties._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMaxNetworkAdapters(self, _arg_chipset):
       """
        Maximum total number of network adapters associated with every
        ::IMachine instance.
      
        :param _arg_chipset: The chipset type to get the value for.
        :return: The maximum total number of network adapters allowed.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_chipset,)
       val = self.mgr.getService().ISystemProperties_getMaxNetworkAdapters(*req)
       
       return UnsignedInt(self.mgr, val)

   def getMaxNetworkAdaptersOfType(self, _arg_chipset, _arg_type):
       """
        Maximum number of network adapters of a given attachment type,
        associated with every ::IMachine instance.
      
        :param _arg_chipset: The chipset type to get the value for.
        :param _arg_type: Type of attachment.
        :return: The maximum number of network adapters allowed for particular chipset and attachment type.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_chipset,)
       req += (_arg_type,)
       val = self.mgr.getService().ISystemProperties_getMaxNetworkAdaptersOfType(*req)
       
       return UnsignedInt(self.mgr, val)

   def getMaxDevicesPerPortForStorageBus(self, _arg_bus):
       """Returns the maximum number of devices which can be attached to a port
      for the given storage bus.
        :param _arg_bus: The storage bus type to get the value for.
        :return: The maximum number of devices which can be attached to the port for the given storage bus.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_bus,)
       val = self.mgr.getService().ISystemProperties_getMaxDevicesPerPortForStorageBus(*req)
       
       return UnsignedInt(self.mgr, val)

   def getMinPortCountForStorageBus(self, _arg_bus):
       """Returns the minimum number of ports the given storage bus supports.
        :param _arg_bus: The storage bus type to get the value for.
        :return: The minimum number of ports for the given storage bus.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_bus,)
       val = self.mgr.getService().ISystemProperties_getMinPortCountForStorageBus(*req)
       
       return UnsignedInt(self.mgr, val)

   def getMaxPortCountForStorageBus(self, _arg_bus):
       """Returns the maximum number of ports the given storage bus supports.
        :param _arg_bus: The storage bus type to get the value for.
        :return: The maximum number of ports for the given storage bus.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_bus,)
       val = self.mgr.getService().ISystemProperties_getMaxPortCountForStorageBus(*req)
       
       return UnsignedInt(self.mgr, val)

   def getMaxInstancesOfStorageBus(self, _arg_chipset, _arg_bus):
       """Returns the maximum number of storage bus instances which
        can be configured for each VM. This corresponds to the number of
        storage controllers one can have. Value may depend on chipset type
        used.
        :param _arg_chipset: The chipset type to get the value for.
        :param _arg_bus: The storage bus type to get the value for.
        :return: The maximum number of instances for the given storage bus.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_chipset,)
       req += (_arg_bus,)
       val = self.mgr.getService().ISystemProperties_getMaxInstancesOfStorageBus(*req)
       
       return UnsignedInt(self.mgr, val)

   def getDeviceTypesForStorageBus(self, _arg_bus):
       """Returns list of all the supported device types
        (::DeviceType) for the given type of storage
        bus.
        :param _arg_bus: The storage bus type to get the value for.
        :return: The list of all supported device types for the given storage bus.
        :rtype: List[DeviceType]

       """
   
       req = (self.handle,)
       req += (_arg_bus,)
       val = self.mgr.getService().ISystemProperties_getDeviceTypesForStorageBus(*req)
       
       return DeviceType(self.mgr, val, True)

   def getStorageBusForStorageControllerType(self, _arg_storageControllerType):
       """Returns the ::StorageBus enum value
        for a given storage controller type.
        :param _arg_storageControllerType: The storage controller type to get the value for.
        :return: The storage bus which is applicable.
        :rtype: StorageBus

       """
   
       req = (self.handle,)
       req += (_arg_storageControllerType,)
       val = self.mgr.getService().ISystemProperties_getStorageBusForStorageControllerType(*req)
       
       return StorageBus(self.mgr, val)

   def getStorageControllerTypesForStorageBus(self, _arg_storageBus):
       """Returns the possible ::StorageControllerType enum values
        for a given storage bus.
        :param _arg_storageBus: The storage bus type to get the values for.
        :return: The enum values (sorted by what should be a sensible decreasing importance of the type) which are valid.
        :rtype: List[StorageControllerType]

       """
   
       req = (self.handle,)
       req += (_arg_storageBus,)
       val = self.mgr.getService().ISystemProperties_getStorageControllerTypesForStorageBus(*req)
       
       return StorageControllerType(self.mgr, val, True)

   def getDefaultIoCacheSettingForStorageController(self, _arg_controllerType):
       """Returns the default I/O cache setting for the
        given storage controller
        :param _arg_controllerType: The storage controller type to get the setting for.
        :return: Returned flag indicating the default value
        :rtype: boolean

       """
   
       req = (self.handle,)
       req += (_arg_controllerType,)
       val = self.mgr.getService().ISystemProperties_getDefaultIoCacheSettingForStorageController(*req)
       
       return Boolean(self.mgr, val)

   def getStorageControllerHotplugCapable(self, _arg_controllerType):
       """Returns whether the given storage controller supports
        hot-plugging devices.
        :param _arg_controllerType: The storage controller to check the setting for.
        :return: Returned flag indicating whether the controller is hotplug capable
        :rtype: boolean

       """
   
       req = (self.handle,)
       req += (_arg_controllerType,)
       val = self.mgr.getService().ISystemProperties_getStorageControllerHotplugCapable(*req)
       
       return Boolean(self.mgr, val)

   def getMaxInstancesOfUSBControllerType(self, _arg_chipset, _arg_type):
       """Returns the maximum number of USB controller instances which
        can be configured for each VM. This corresponds to the number of
        USB controllers one can have. Value may depend on chipset type
        used.
        :param _arg_chipset: The chipset type to get the value for.
        :param _arg_type: The USB controller type to get the value for.
        :return: The maximum number of instances for the given USB controller type.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_chipset,)
       req += (_arg_type,)
       val = self.mgr.getService().ISystemProperties_getMaxInstancesOfUSBControllerType(*req)
       
       return UnsignedInt(self.mgr, val)

   def getMinGuestRAM(self):
       """Minimum guest system memory in Megabytes. """
       val = self.mgr.getService().ISystemProperties_getMinGuestRAM(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMaxGuestRAM(self):
       """Maximum guest system memory in Megabytes. """
       val = self.mgr.getService().ISystemProperties_getMaxGuestRAM(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMinGuestVRAM(self):
       """Minimum guest video memory in Megabytes. """
       val = self.mgr.getService().ISystemProperties_getMinGuestVRAM(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMaxGuestVRAM(self):
       """Maximum guest video memory in Megabytes. """
       val = self.mgr.getService().ISystemProperties_getMaxGuestVRAM(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMinGuestCPUCount(self):
       """Minimum CPU count. """
       val = self.mgr.getService().ISystemProperties_getMinGuestCPUCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMaxGuestCPUCount(self):
       """Maximum CPU count. """
       val = self.mgr.getService().ISystemProperties_getMaxGuestCPUCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMaxGuestMonitors(self):
       """Maximum of monitors which could be connected. """
       val = self.mgr.getService().ISystemProperties_getMaxGuestMonitors(self.handle)
       return UnsignedInt(self.mgr, val)

   def getInfoVDSize(self):
       """Maximum size of a virtual disk image in bytes. Informational value,
      does not reflect the limits of any virtual disk image format. """
       val = self.mgr.getService().ISystemProperties_getInfoVDSize(self.handle)
       return Long(self.mgr, val)

   def getSerialPortCount(self):
       """
        Maximum number of serial ports associated with every
        ::IMachine instance.
       """
       val = self.mgr.getService().ISystemProperties_getSerialPortCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getParallelPortCount(self):
       """
        Maximum number of parallel ports associated with every
        ::IMachine instance.
       """
       val = self.mgr.getService().ISystemProperties_getParallelPortCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMaxBootPosition(self):
       """
        Maximum device position in the boot order. This value corresponds
        to the total number of devices a machine can boot from, to make it
        possible to include all possible devices to the boot list.
        
        .. sealso:: IMachine::setBootOrder """
       val = self.mgr.getService().ISystemProperties_getMaxBootPosition(self.handle)
       return UnsignedInt(self.mgr, val)

   def getRawModeSupported(self):
       """
        Indicates whether VirtualBox was built with raw-mode support.

        When this reads as False, the ::HWVirtExPropertyType_Enabled
        setting will be ignored and assumed to be True.
       """
       val = self.mgr.getService().ISystemProperties_getRawModeSupported(self.handle)
       return Boolean(self.mgr, val)

   def getExclusiveHwVirt(self):
       """
        Exclusive use of hardware virtualization by VirtualBox. When enabled,
        VirtualBox assumes it can obtain full and exclusive access to the VT-x
        or AMD-V feature of the host. To share hardware virtualization with
        other hypervisors, this property must be disabled.

        
        .. note:: This is ignored on OS X, the kernel mediates hardware
          access there. """
       val = self.mgr.getService().ISystemProperties_getExclusiveHwVirt(self.handle)
       return Boolean(self.mgr, val)

   def setExclusiveHwVirt(self, value):
       """
        Exclusive use of hardware virtualization by VirtualBox. When enabled,
        VirtualBox assumes it can obtain full and exclusive access to the VT-x
        or AMD-V feature of the host. To share hardware virtualization with
        other hypervisors, this property must be disabled.

        
        .. note:: This is ignored on OS X, the kernel mediates hardware
          access there. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setExclusiveHwVirt(_this, _val)

   def getDefaultMachineFolder(self):
       """
        Full path to the default directory used to create new or open
        existing machines when a machine settings file name contains no
        path.

        Starting with VirtualBox 4.0, by default, this attribute contains
        the full path of folder named "VirtualBox VMs" in the user's
        home directory, which depends on the host platform.

        When setting this attribute, a full path must be specified.
        Setting this property to @c null or an empty string or the
        special value "Machines" (for compatibility reasons) will restore
        that default value.

        If the folder specified herein does not exist, it will be created
        automatically as needed.

        
        .. sealso:: IVirtualBox::createMachine,
          IVirtualBox::openMachine """
       val = self.mgr.getService().ISystemProperties_getDefaultMachineFolder(self.handle)
       return String(self.mgr, val)

   def setDefaultMachineFolder(self, value):
       """
        Full path to the default directory used to create new or open
        existing machines when a machine settings file name contains no
        path.

        Starting with VirtualBox 4.0, by default, this attribute contains
        the full path of folder named "VirtualBox VMs" in the user's
        home directory, which depends on the host platform.

        When setting this attribute, a full path must be specified.
        Setting this property to @c null or an empty string or the
        special value "Machines" (for compatibility reasons) will restore
        that default value.

        If the folder specified herein does not exist, it will be created
        automatically as needed.

        
        .. sealso:: IVirtualBox::createMachine,
          IVirtualBox::openMachine """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setDefaultMachineFolder(_this, _val)

   def getLoggingLevel(self):
       """
        Specifies the logging level in current use by VirtualBox.
       """
       val = self.mgr.getService().ISystemProperties_getLoggingLevel(self.handle)
       return String(self.mgr, val)

   def setLoggingLevel(self, value):
       """
        Specifies the logging level in current use by VirtualBox.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setLoggingLevel(_this, _val)

   def getMediumFormats(self):
       """
        List of all medium storage formats supported by this VirtualBox
        installation.

        Keep in mind that the medium format identifier
        (IMediumFormat::id) used in other API calls like
        IVirtualBox::createMedium to refer to a particular
        medium format is a case-insensitive string. This means that, for
        example, all of the following strings:
        
          "VDI"
          "vdi"
          "VdI"
        refer to the same medium format.

        Note that the virtual medium framework is backend-based, therefore
        the list of supported formats depends on what backends are currently
        installed.

        
        .. sealso:: ::IMediumFormat """
       val = self.mgr.getService().ISystemProperties_getMediumFormats(self.handle)
       return IMediumFormat(self.mgr, val, True)

   def getDefaultHardDiskFormat(self):
       """
        Identifier of the default medium format used by VirtualBox.

        The medium format set by this attribute is used by VirtualBox
        when the medium format was not specified explicitly. One example is
        IVirtualBox::createMedium with the empty
        format argument. A more complex example is implicit creation of
        differencing media when taking a snapshot of a virtual machine:
        this operation will try to use a format of the parent medium first
        and if this format does not support differencing media the default
        format specified by this argument will be used.

        The list of supported medium formats may be obtained by the
        #mediumFormats call. Note that the default medium
        format must have a capability to create differencing media;
        otherwise operations that create media implicitly may fail
        unexpectedly.

        The initial value of this property is "VDI" in the current
        version of the VirtualBox product, but may change in the future.

        
        .. note:: 
          Setting this property to @c null or empty string will restore the
          initial value.
        
        .. sealso:: #mediumFormats,
          IMediumFormat::id,
          IVirtualBox::createMedium """
       val = self.mgr.getService().ISystemProperties_getDefaultHardDiskFormat(self.handle)
       return String(self.mgr, val)

   def setDefaultHardDiskFormat(self, value):
       """
        Identifier of the default medium format used by VirtualBox.

        The medium format set by this attribute is used by VirtualBox
        when the medium format was not specified explicitly. One example is
        IVirtualBox::createMedium with the empty
        format argument. A more complex example is implicit creation of
        differencing media when taking a snapshot of a virtual machine:
        this operation will try to use a format of the parent medium first
        and if this format does not support differencing media the default
        format specified by this argument will be used.

        The list of supported medium formats may be obtained by the
        #mediumFormats call. Note that the default medium
        format must have a capability to create differencing media;
        otherwise operations that create media implicitly may fail
        unexpectedly.

        The initial value of this property is "VDI" in the current
        version of the VirtualBox product, but may change in the future.

        
        .. note:: 
          Setting this property to @c null or empty string will restore the
          initial value.
        
        .. sealso:: #mediumFormats,
          IMediumFormat::id,
          IVirtualBox::createMedium """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setDefaultHardDiskFormat(_this, _val)

   def getFreeDiskSpaceWarning(self):
       """Issue a warning if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given size in
      bytes. """
       val = self.mgr.getService().ISystemProperties_getFreeDiskSpaceWarning(self.handle)
       return Long(self.mgr, val)

   def setFreeDiskSpaceWarning(self, value):
       """Issue a warning if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given size in
      bytes. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setFreeDiskSpaceWarning(_this, _val)

   def getFreeDiskSpacePercentWarning(self):
       """Issue a warning if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given percentage. """
       val = self.mgr.getService().ISystemProperties_getFreeDiskSpacePercentWarning(self.handle)
       return UnsignedInt(self.mgr, val)

   def setFreeDiskSpacePercentWarning(self, value):
       """Issue a warning if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given percentage. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setFreeDiskSpacePercentWarning(_this, _val)

   def getFreeDiskSpaceError(self):
       """Issue an error if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given size in
      bytes. """
       val = self.mgr.getService().ISystemProperties_getFreeDiskSpaceError(self.handle)
       return Long(self.mgr, val)

   def setFreeDiskSpaceError(self, value):
       """Issue an error if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given size in
      bytes. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setFreeDiskSpaceError(_this, _val)

   def getFreeDiskSpacePercentError(self):
       """Issue an error if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given percentage. """
       val = self.mgr.getService().ISystemProperties_getFreeDiskSpacePercentError(self.handle)
       return UnsignedInt(self.mgr, val)

   def setFreeDiskSpacePercentError(self, value):
       """Issue an error if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given percentage. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setFreeDiskSpacePercentError(_this, _val)

   def getVRDEAuthLibrary(self):
       """
        Library that provides authentication for Remote Desktop clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration.

        The system library extension (".DLL" or ".so") must be omitted.
        A full path can be specified; if not, then the library must reside on the
        system's default library path.

        The default value of this property is "VBoxAuth". There is a library
        of that name in one of the default VirtualBox library directories.

        For details about VirtualBox authentication libraries and how to implement
        them, please refer to the VirtualBox manual.

        
        .. note:: 
          Setting this property to @c null or empty string will restore the
          initial value.
         """
       val = self.mgr.getService().ISystemProperties_getVRDEAuthLibrary(self.handle)
       return String(self.mgr, val)

   def setVRDEAuthLibrary(self, value):
       """
        Library that provides authentication for Remote Desktop clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration.

        The system library extension (".DLL" or ".so") must be omitted.
        A full path can be specified; if not, then the library must reside on the
        system's default library path.

        The default value of this property is "VBoxAuth". There is a library
        of that name in one of the default VirtualBox library directories.

        For details about VirtualBox authentication libraries and how to implement
        them, please refer to the VirtualBox manual.

        
        .. note:: 
          Setting this property to @c null or empty string will restore the
          initial value.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setVRDEAuthLibrary(_this, _val)

   def getWebServiceAuthLibrary(self):
       """
        Library that provides authentication for webservice clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration and will be called from
        within the IWebsessionManager::logon implementation.

        As opposed to ISystemProperties::VRDEAuthLibrary,
        there is no per-VM setting for this, as the webservice is a global
        resource (if it is running). Only for this setting (for the webservice),
        setting this value to a literal "null" string disables authentication,
        meaning that IWebsessionManager::logon will always succeed,
        no matter what user name and password are supplied.

        The initial value of this property is "VBoxAuth",
        meaning that the webservice will use the same authentication
        library that is used by default for VRDE (again, see
        ISystemProperties::VRDEAuthLibrary).
        The format and calling convention of authentication libraries
        is the same for the webservice as it is for VRDE.

        
        .. note:: 
          Setting this property to @c null or empty string will restore the
          initial value.
         """
       val = self.mgr.getService().ISystemProperties_getWebServiceAuthLibrary(self.handle)
       return String(self.mgr, val)

   def setWebServiceAuthLibrary(self, value):
       """
        Library that provides authentication for webservice clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration and will be called from
        within the IWebsessionManager::logon implementation.

        As opposed to ISystemProperties::VRDEAuthLibrary,
        there is no per-VM setting for this, as the webservice is a global
        resource (if it is running). Only for this setting (for the webservice),
        setting this value to a literal "null" string disables authentication,
        meaning that IWebsessionManager::logon will always succeed,
        no matter what user name and password are supplied.

        The initial value of this property is "VBoxAuth",
        meaning that the webservice will use the same authentication
        library that is used by default for VRDE (again, see
        ISystemProperties::VRDEAuthLibrary).
        The format and calling convention of authentication libraries
        is the same for the webservice as it is for VRDE.

        
        .. note:: 
          Setting this property to @c null or empty string will restore the
          initial value.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setWebServiceAuthLibrary(_this, _val)

   def getDefaultVRDEExtPack(self):
       """
        The name of the extension pack providing the default VRDE.

        This attribute is for choosing between multiple extension packs
        providing VRDE. If only one is installed, it will automatically be the
        default one. The attribute value can be empty if no VRDE extension
        pack is installed.

        For details about VirtualBox Remote Desktop Extension and how to
        implement one, please refer to the VirtualBox SDK.
       """
       val = self.mgr.getService().ISystemProperties_getDefaultVRDEExtPack(self.handle)
       return String(self.mgr, val)

   def setDefaultVRDEExtPack(self, value):
       """
        The name of the extension pack providing the default VRDE.

        This attribute is for choosing between multiple extension packs
        providing VRDE. If only one is installed, it will automatically be the
        default one. The attribute value can be empty if no VRDE extension
        pack is installed.

        For details about VirtualBox Remote Desktop Extension and how to
        implement one, please refer to the VirtualBox SDK.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setDefaultVRDEExtPack(_this, _val)

   def getLogHistoryCount(self):
       """
        This value specifies how many old release log files are kept.
       """
       val = self.mgr.getService().ISystemProperties_getLogHistoryCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def setLogHistoryCount(self, value):
       """
        This value specifies how many old release log files are kept.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setLogHistoryCount(_this, _val)

   def getDefaultAudioDriver(self):
       """This value hold the default audio driver for the current
      system. """
       val = self.mgr.getService().ISystemProperties_getDefaultAudioDriver(self.handle)
       return AudioDriverType(self.mgr, val)

   def getAutostartDatabasePath(self):
       """
        The path to the autostart database. Depending on the host this might
        be a filesystem path or something else.
       """
       val = self.mgr.getService().ISystemProperties_getAutostartDatabasePath(self.handle)
       return String(self.mgr, val)

   def setAutostartDatabasePath(self, value):
       """
        The path to the autostart database. Depending on the host this might
        be a filesystem path or something else.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setAutostartDatabasePath(_this, _val)

   def getDefaultAdditionsISO(self):
       """
        The path to the default Guest Additions ISO image. Can be empty if
        the location is not known in this installation.
       """
       val = self.mgr.getService().ISystemProperties_getDefaultAdditionsISO(self.handle)
       return String(self.mgr, val)

   def setDefaultAdditionsISO(self, value):
       """
        The path to the default Guest Additions ISO image. Can be empty if
        the location is not known in this installation.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setDefaultAdditionsISO(_this, _val)

   def getDefaultFrontend(self):
       """
        Selects which VM frontend should be used by default when launching
        a VM through the IMachine::launchVMProcess method.
        Empty or @c null strings do not define a particular default, it is up
        to IMachine::launchVMProcess to select one. See the
        description of IMachine::launchVMProcess for the valid
        frontend types.

        This global setting is overridden by the per-VM attribute
        IMachine::defaultFrontend or a frontend type
        passed to IMachine::launchVMProcess.
       """
       val = self.mgr.getService().ISystemProperties_getDefaultFrontend(self.handle)
       return String(self.mgr, val)

   def setDefaultFrontend(self, value):
       """
        Selects which VM frontend should be used by default when launching
        a VM through the IMachine::launchVMProcess method.
        Empty or @c null strings do not define a particular default, it is up
        to IMachine::launchVMProcess to select one. See the
        description of IMachine::launchVMProcess for the valid
        frontend types.

        This global setting is overridden by the per-VM attribute
        IMachine::defaultFrontend or a frontend type
        passed to IMachine::launchVMProcess.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setDefaultFrontend(_this, _val)

   def getScreenShotFormats(self):
       """
        Supported bitmap formats which can be used with takeScreenShot
        and takeScreenShotToArray methods.
       """
       val = self.mgr.getService().ISystemProperties_getScreenShotFormats(self.handle)
       return BitmapFormat(self.mgr, val, True)

   def getProxyMode(self):
       """ The proxy mode setting: System, NoProxy or Manual. """
       val = self.mgr.getService().ISystemProperties_getProxyMode(self.handle)
       return ProxyMode(self.mgr, val)

   def setProxyMode(self, value):
       """ The proxy mode setting: System, NoProxy or Manual. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setProxyMode(_this, _val)

   def getProxyURL(self):
       """
        Proxy server URL for the ::ProxyMode_Manual proxy mode.

        The format is: [{type}"://"][{userid}[@{password}]:]{server}[":"{port}]

        Valid types are: http (default), https, socks4, socks4a, socks5, socks5h and direct.
        Please note that these are proxy types defining how the proxy operates rather than
        how to proxy any similarly named protocol (i.e. don't confuse a http-proxy with
        proxying the http protocol, as a http-proxy usually can proxy https and other protocols too).

        The port number defaults to 80 for http, 443 for https and 1080 for the socks ones.

        
        .. note:: The password is currently stored as plain text!  Use the ::ProxyMode_System
        mode if you consider the proxy password to be sensitive.

        An empty string will cause the behavior to be identical to ::ProxyMode_System.
        For compatibility with libproxy, an URL starting with "direct://" will cause
        ::ProxyMode_NoProxy behavior.
       """
       val = self.mgr.getService().ISystemProperties_getProxyURL(self.handle)
       return String(self.mgr, val)

   def setProxyURL(self, value):
       """
        Proxy server URL for the ::ProxyMode_Manual proxy mode.

        The format is: [{type}"://"][{userid}[@{password}]:]{server}[":"{port}]

        Valid types are: http (default), https, socks4, socks4a, socks5, socks5h and direct.
        Please note that these are proxy types defining how the proxy operates rather than
        how to proxy any similarly named protocol (i.e. don't confuse a http-proxy with
        proxying the http protocol, as a http-proxy usually can proxy https and other protocols too).

        The port number defaults to 80 for http, 443 for https and 1080 for the socks ones.

        
        .. note:: The password is currently stored as plain text!  Use the ::ProxyMode_System
        mode if you consider the proxy password to be sensitive.

        An empty string will cause the behavior to be identical to ::ProxyMode_System.
        For compatibility with libproxy, an URL starting with "direct://" will cause
        ::ProxyMode_NoProxy behavior.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISystemProperties_setProxyURL(_this, _val)

   def getSupportedParavirtProviders(self):
       """
        Returns an array of officially supported values for enum ::ParavirtProvider,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedParavirtProviders(self.handle)
       return ParavirtProvider(self.mgr, val, True)

   def getSupportedClipboardModes(self):
       """
        Returns an array of officially supported values for enum ::ClipboardMode,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedClipboardModes(self.handle)
       return ClipboardMode(self.mgr, val, True)

   def getSupportedDnDModes(self):
       """
        Returns an array of officially supported values for enum ::DnDMode,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedDnDModes(self.handle)
       return DnDMode(self.mgr, val, True)

   def getSupportedFirmwareTypes(self):
       """
        Returns an array of officially supported values for enum ::FirmwareType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedFirmwareTypes(self.handle)
       return FirmwareType(self.mgr, val, True)

   def getSupportedPointingHIDTypes(self):
       """
        Returns an array of officially supported values for enum ::PointingHIDType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedPointingHIDTypes(self.handle)
       return PointingHIDType(self.mgr, val, True)

   def getSupportedKeyboardHIDTypes(self):
       """
        Returns an array of officially supported values for enum ::KeyboardHIDType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedKeyboardHIDTypes(self.handle)
       return KeyboardHIDType(self.mgr, val, True)

   def getSupportedVFSTypes(self):
       """
        Returns an array of officially supported values for enum ::VFSType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedVFSTypes(self.handle)
       return VFSType(self.mgr, val, True)

   def getSupportedImportOptions(self):
       """
        Returns an array of officially supported values for enum ::ImportOptions,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedImportOptions(self.handle)
       return ImportOptions(self.mgr, val, True)

   def getSupportedExportOptions(self):
       """
        Returns an array of officially supported values for enum ::ExportOptions,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedExportOptions(self.handle)
       return ExportOptions(self.mgr, val, True)

   def getSupportedRecordingAudioCodecs(self):
       """
        Returns an array of officially supported values for enum ::RecordingAudioCodec,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedRecordingAudioCodecs(self.handle)
       return RecordingAudioCodec(self.mgr, val, True)

   def getSupportedRecordingVideoCodecs(self):
       """
        Returns an array of officially supported values for enum ::RecordingVideoCodec,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedRecordingVideoCodecs(self.handle)
       return RecordingVideoCodec(self.mgr, val, True)

   def getSupportedRecordingVSMethods(self):
       """
        Returns an array of officially supported values for enum ::RecordingVideoScalingMethod,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedRecordingVSMethods(self.handle)
       return RecordingVideoScalingMethod(self.mgr, val, True)

   def getSupportedRecordingVRCModes(self):
       """
        Returns an array of officially supported values for enum ::RecordingVideoRateControlMode,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedRecordingVRCModes(self.handle)
       return RecordingVideoRateControlMode(self.mgr, val, True)

   def getSupportedGraphicsControllerTypes(self):
       """
        Returns an array of officially supported values for enum ::GraphicsControllerType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedGraphicsControllerTypes(self.handle)
       return GraphicsControllerType(self.mgr, val, True)

   def getSupportedCloneOptions(self):
       """
        Returns an array of officially supported values for enum ::CloneOptions,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedCloneOptions(self.handle)
       return CloneOptions(self.mgr, val, True)

   def getSupportedAutostopTypes(self):
       """
        Returns an array of officially supported values for enum ::AutostopType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedAutostopTypes(self.handle)
       return AutostopType(self.mgr, val, True)

   def getSupportedVMProcPriorities(self):
       """
        Returns an array of officially supported values for enum ::VMProcPriority,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedVMProcPriorities(self.handle)
       return VMProcPriority(self.mgr, val, True)

   def getSupportedNetworkAttachmentTypes(self):
       """
        Returns an array of officially supported values for enum ::NetworkAttachmentType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedNetworkAttachmentTypes(self.handle)
       return NetworkAttachmentType(self.mgr, val, True)

   def getSupportedNetworkAdapterTypes(self):
       """
        Returns an array of officially supported values for enum ::NetworkAdapterType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedNetworkAdapterTypes(self.handle)
       return NetworkAdapterType(self.mgr, val, True)

   def getSupportedPortModes(self):
       """
        Returns an array of officially supported values for enum ::PortMode,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedPortModes(self.handle)
       return PortMode(self.mgr, val, True)

   def getSupportedUartTypes(self):
       """
        Returns an array of officially supported values for enum ::UartType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedUartTypes(self.handle)
       return UartType(self.mgr, val, True)

   def getSupportedUSBControllerTypes(self):
       """
        Returns an array of officially supported values for enum ::USBControllerType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedUSBControllerTypes(self.handle)
       return USBControllerType(self.mgr, val, True)

   def getSupportedAudioDriverTypes(self):
       """
        Returns an array of officially supported values for enum ::AudioDriverType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedAudioDriverTypes(self.handle)
       return AudioDriverType(self.mgr, val, True)

   def getSupportedAudioControllerTypes(self):
       """
        Returns an array of officially supported values for enum ::AudioControllerType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedAudioControllerTypes(self.handle)
       return AudioControllerType(self.mgr, val, True)

   def getSupportedStorageBuses(self):
       """
        Returns an array of officially supported values for enum ::StorageBus,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedStorageBuses(self.handle)
       return StorageBus(self.mgr, val, True)

   def getSupportedStorageControllerTypes(self):
       """
        Returns an array of officially supported values for enum ::StorageControllerType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedStorageControllerTypes(self.handle)
       return StorageControllerType(self.mgr, val, True)

   def getSupportedChipsetTypes(self):
       """
        Returns an array of officially supported values for enum ::ChipsetType,
        in the sense of what is e.g. worth offering in the VirtualBox GUI.
       """
       val = self.mgr.getService().ISystemProperties_getSupportedChipsetTypes(self.handle)
       return ChipsetType(self.mgr, val, True)



   _Attrs_ = {'minGuestRAM':[getMinGuestRAM,None],
              'maxGuestRAM':[getMaxGuestRAM,None],
              'minGuestVRAM':[getMinGuestVRAM,None],
              'maxGuestVRAM':[getMaxGuestVRAM,None],
              'minGuestCPUCount':[getMinGuestCPUCount,None],
              'maxGuestCPUCount':[getMaxGuestCPUCount,None],
              'maxGuestMonitors':[getMaxGuestMonitors,None],
              'infoVDSize':[getInfoVDSize,None],
              'serialPortCount':[getSerialPortCount,None],
              'parallelPortCount':[getParallelPortCount,None],
              'maxBootPosition':[getMaxBootPosition,None],
              'rawModeSupported':[getRawModeSupported,None],
              'exclusiveHwVirt':[getExclusiveHwVirt,setExclusiveHwVirt,],
              'defaultMachineFolder':[getDefaultMachineFolder,setDefaultMachineFolder,],
              'loggingLevel':[getLoggingLevel,setLoggingLevel,],
              'mediumFormats':[getMediumFormats,None],
              'defaultHardDiskFormat':[getDefaultHardDiskFormat,setDefaultHardDiskFormat,],
              'freeDiskSpaceWarning':[getFreeDiskSpaceWarning,setFreeDiskSpaceWarning,],
              'freeDiskSpacePercentWarning':[getFreeDiskSpacePercentWarning,setFreeDiskSpacePercentWarning,],
              'freeDiskSpaceError':[getFreeDiskSpaceError,setFreeDiskSpaceError,],
              'freeDiskSpacePercentError':[getFreeDiskSpacePercentError,setFreeDiskSpacePercentError,],
              'VRDEAuthLibrary':[getVRDEAuthLibrary,setVRDEAuthLibrary,],
              'webServiceAuthLibrary':[getWebServiceAuthLibrary,setWebServiceAuthLibrary,],
              'defaultVRDEExtPack':[getDefaultVRDEExtPack,setDefaultVRDEExtPack,],
              'logHistoryCount':[getLogHistoryCount,setLogHistoryCount,],
              'defaultAudioDriver':[getDefaultAudioDriver,None],
              'autostartDatabasePath':[getAutostartDatabasePath,setAutostartDatabasePath,],
              'defaultAdditionsISO':[getDefaultAdditionsISO,setDefaultAdditionsISO,],
              'defaultFrontend':[getDefaultFrontend,setDefaultFrontend,],
              'screenShotFormats':[getScreenShotFormats,None],
              'proxyMode':[getProxyMode,setProxyMode,],
              'proxyURL':[getProxyURL,setProxyURL,],
              'supportedParavirtProviders':[getSupportedParavirtProviders,None],
              'supportedClipboardModes':[getSupportedClipboardModes,None],
              'supportedDnDModes':[getSupportedDnDModes,None],
              'supportedFirmwareTypes':[getSupportedFirmwareTypes,None],
              'supportedPointingHIDTypes':[getSupportedPointingHIDTypes,None],
              'supportedKeyboardHIDTypes':[getSupportedKeyboardHIDTypes,None],
              'supportedVFSTypes':[getSupportedVFSTypes,None],
              'supportedImportOptions':[getSupportedImportOptions,None],
              'supportedExportOptions':[getSupportedExportOptions,None],
              'supportedRecordingAudioCodecs':[getSupportedRecordingAudioCodecs,None],
              'supportedRecordingVideoCodecs':[getSupportedRecordingVideoCodecs,None],
              'supportedRecordingVSMethods':[getSupportedRecordingVSMethods,None],
              'supportedRecordingVRCModes':[getSupportedRecordingVRCModes,None],
              'supportedGraphicsControllerTypes':[getSupportedGraphicsControllerTypes,None],
              'supportedCloneOptions':[getSupportedCloneOptions,None],
              'supportedAutostopTypes':[getSupportedAutostopTypes,None],
              'supportedVMProcPriorities':[getSupportedVMProcPriorities,None],
              'supportedNetworkAttachmentTypes':[getSupportedNetworkAttachmentTypes,None],
              'supportedNetworkAdapterTypes':[getSupportedNetworkAdapterTypes,None],
              'supportedPortModes':[getSupportedPortModes,None],
              'supportedUartTypes':[getSupportedUartTypes,None],
              'supportedUSBControllerTypes':[getSupportedUSBControllerTypes,None],
              'supportedAudioDriverTypes':[getSupportedAudioDriverTypes,None],
              'supportedAudioControllerTypes':[getSupportedAudioControllerTypes,None],
              'supportedStorageBuses':[getSupportedStorageBuses,None],
              'supportedStorageControllerTypes':[getSupportedStorageControllerTypes,None],
              'supportedChipsetTypes':[getSupportedChipsetTypes,None]}

class IDnDBase(IUnknown):
   """Base abstract interface for drag'n drop.
      Interface ID:
        {4132147B-42F8-CD96-7570-6A8800E3342C}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDnDBase(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDnDBase._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDnDBase._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def isFormatSupported(self, _arg_format):
       """
        Checks if a specific drag'n drop MIME / Content-type format is supported.
      
        :param _arg_format: Format to check for.
        :return: Returns @c true if the specified format is supported, @c false if not.
        :rtype: boolean

       """
   
       req = (self.handle,)
       req += (_arg_format,)
       val = self.mgr.getService().IDnDBase_isFormatSupported(*req)
       
       return Boolean(self.mgr, val)

   def addFormats(self, _arg_formats):
       """
        Adds MIME / Content-type formats to the supported formats.
      
        :param _arg_formats: Collection of formats to add.

       """
   
       req = (self.handle,)
       req += (_arg_formats,)
       val = self.mgr.getService().IDnDBase_addFormats(*req)
       
       return 

   def removeFormats(self, _arg_formats):
       """
        Removes MIME / Content-type formats from the supported formats.
      
        :param _arg_formats: Collection of formats to remove.

       """
   
       req = (self.handle,)
       req += (_arg_formats,)
       val = self.mgr.getService().IDnDBase_removeFormats(*req)
       
       return 

   def getFormats(self):
       """Returns all supported drag'n drop formats. """
       val = self.mgr.getService().IDnDBase_getFormats(self.handle)
       return String(self.mgr, val, True)

   def getProtocolVersion(self):
       """Returns the protocol version which is used to communicate
        with the guest. """
       val = self.mgr.getService().IDnDBase_getProtocolVersion(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'formats':[getFormats,None],
              'protocolVersion':[getProtocolVersion,None]}

class IDnDSource(IDnDBase):
   """Abstract interface for handling drag'n drop sources.
      Interface ID:
        {D23A9CA3-42DA-C94B-8AEC-21968E08355D}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDnDSource(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDnDSource._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IDnDBase.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDnDSource._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def dragIsPending(self, _arg_screenId):
       """
        Ask the source if there is any drag and drop operation pending.
        If no drag and drop operation is pending currently, DnDAction_Ignore is returned.

        
        :param _arg_screenId: The screen ID where the drag and drop event occurred.


        :return: On return the default action to use.
        :rtype: DnDAction

        Expected result codes:
        VBOX_E_VM_ERROR
          VMM device is not available.
        
       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       val = self.mgr.getService().IDnDSource_dragIsPending(*req)
       
       return DnDAction(self.mgr,val["returnval"]), String(self.mgr,val["formats"], True), DnDAction(self.mgr,val["allowedActions"], True)

   def drop(self, _arg_format, _arg_action):
       """
        Informs the source that a drop event occurred for a pending
        drag and drop operation.

        
        :param _arg_format: The mime type the data must be in.
        :param _arg_action: The action to use.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_VM_ERROR
          VMM device is not available.
        
       """
   
       req = (self.handle,)
       req += (_arg_format,)
       req += (_arg_action,)
       val = self.mgr.getService().IDnDSource_drop(*req)
       
       return IProgress(self.mgr, val)

   def receiveData(self):
       """
        Receive the data of a previously drag and drop event from the source.

        
        :return: The actual data.
        :rtype: List[octet]

        Expected result codes:
        VBOX_E_VM_ERROR
          VMM device is not available.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDnDSource_receiveData(*req)
       
       return self.mgr.decodebase64( val)



   _Attrs_ = {}

class IGuestDnDSource(IDnDSource):
   """
      Implementation of the ::IDnDSource object
      for source drag'n drop operations on the guest.
    
      Interface ID:
        {DEDFB5D9-4C1B-EDF7-FDF3-C1BE6827DC28}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestDnDSource(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestDnDSource._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IDnDSource.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestDnDSource._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IGuestDnDSource_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IDnDTarget(IDnDBase):
   """Abstract interface for handling drag'n drop targets.
      Interface ID:
        {FF5BEFC3-4BA3-7903-2AA4-43988BA11554}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDnDTarget(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDnDTarget._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IDnDBase.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDnDTarget._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def enter(self, _arg_screenId, _arg_y, _arg_x, _arg_defaultAction, _arg_allowedActions, _arg_formats):
       """
        Informs the target about a drag and drop enter event.

        
        :param _arg_screenId: The screen ID where the drag and drop event occurred.
        :param _arg_y: Y-position of the event.
        :param _arg_x: X-position of the event.
        :param _arg_defaultAction: The default action to use.
        :param _arg_allowedActions: The actions which are allowed.
        :param _arg_formats: The supported MIME types.
        :return: The resulting action of this event.
        :rtype: DnDAction

        Expected result codes:
        VBOX_E_VM_ERROR
          VMM device is not available.
        
       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_y,)
       req += (_arg_x,)
       req += (_arg_defaultAction,)
       req += (_arg_allowedActions,)
       req += (_arg_formats,)
       val = self.mgr.getService().IDnDTarget_enter(*req)
       
       return DnDAction(self.mgr, val)

   def move(self, _arg_screenId, _arg_x, _arg_y, _arg_defaultAction, _arg_allowedActions, _arg_formats):
       """
        Informs the target about a drag and drop move event.

        
        :param _arg_screenId: The screen ID where the drag and drop event occurred.
        :param _arg_x: X-position of the event.
        :param _arg_y: Y-position of the event.
        :param _arg_defaultAction: The default action to use.
        :param _arg_allowedActions: The actions which are allowed.
        :param _arg_formats: The supported MIME types.
        :return: The resulting action of this event.
        :rtype: DnDAction

        Expected result codes:
        VBOX_E_VM_ERROR
          VMM device is not available.
        
       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_x,)
       req += (_arg_y,)
       req += (_arg_defaultAction,)
       req += (_arg_allowedActions,)
       req += (_arg_formats,)
       val = self.mgr.getService().IDnDTarget_move(*req)
       
       return DnDAction(self.mgr, val)

   def leave(self, _arg_screenId):
       """
        Informs the target about a drag and drop leave event.

        
        :param _arg_screenId: The screen ID where the drag and drop event occurred.

        Expected result codes:
        VBOX_E_VM_ERROR
          VMM device is not available.
        
       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       val = self.mgr.getService().IDnDTarget_leave(*req)
       
       return 

   def drop(self, _arg_screenId, _arg_x, _arg_y, _arg_defaultAction, _arg_allowedActions, _arg_formats):
       """
        Informs the target about a drop event.

        
        :param _arg_screenId: The screen ID where the Drag and Drop event occurred.
        :param _arg_x: X-position of the event.
        :param _arg_y: Y-position of the event.
        :param _arg_defaultAction: The default action to use.
        :param _arg_allowedActions: The actions which are allowed.
        :param _arg_formats: The supported MIME types.

        :return: The resulting action of this event.
        :rtype: DnDAction

        Expected result codes:
        VBOX_E_VM_ERROR
          VMM device is not available.
        
       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_x,)
       req += (_arg_y,)
       req += (_arg_defaultAction,)
       req += (_arg_allowedActions,)
       req += (_arg_formats,)
       val = self.mgr.getService().IDnDTarget_drop(*req)
       
       return DnDAction(self.mgr,val["returnval"]), String(self.mgr,val["format"])

   def sendData(self, _arg_screenId, _arg_format, _arg_data):
       """
        Initiates sending data to the target.

        
        :param _arg_screenId: The screen ID where the drag and drop event occurred.
        :param _arg_format: The MIME type the data is in.
        :param _arg_data: The actual data.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_VM_ERROR
          VMM device is not available.
        
       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_format,)
       req += (self.mgr.encodebase64(_arg_data),)
       val = self.mgr.getService().IDnDTarget_sendData(*req)
       
       return IProgress(self.mgr, val)

   def cancel(self):
       """
        Requests cancelling the current operation. The target can veto
        the request in case the operation is not cancelable at the moment.

        
        :return: Whether the target has vetoed cancelling the operation.
        :rtype: boolean

        Expected result codes:
        VBOX_E_VM_ERROR
          VMM device is not available.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDnDTarget_cancel(*req)
       
       return Boolean(self.mgr, val)



   _Attrs_ = {}

class IGuestDnDTarget(IDnDTarget):
   """
      Implementation of the ::IDnDTarget object
      for target drag'n drop operations on the guest.
    
      Interface ID:
        {50CE4B51-0FF7-46B7-A138-3C6E5AC946B4}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestDnDTarget(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestDnDTarget._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IDnDTarget.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestDnDTarget._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IGuestDnDTarget_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IGuestSession(IUnknown):
   """
      A guest session represents one impersonated user account in the guest, so
      every operation will use the same credentials specified when creating
      the session object via IGuest::createSession.

      There can be a maximum of 32 sessions at once per VM, whereas session 0
      always is reserved for the root session (the root session is part of that
      limit).

      This root session is controlling all other guest sessions and also is
      responsible for actions which require system level privileges.

      Each guest session keeps track of the guest directories and files that
      it opened as well as guest processes it has created.  To work on guest
      files or directories a guest session offers methods to open or create
      such objects (see IGuestSession::fileOpen or
      IGuestSession::directoryOpen for instance).  Similarly,
      there a methods for creating guest processes.

      There can be up to 2048 objects (guest processes, files and directories)
      a time per guest session.  Exceeding the limit will result in an error (see
      the corresponding functions for more).

      When done with either of these objects, including the guest session itself,
      use the appropriate close() method to let the object do its cleanup work.

      Closing a session via IGuestSession::close will try to close
      all the mentioned objects above unless these objects are still used by
      a client.

      A set of environment variables changes is associated with each session
      (IGuestSession::environmentChanges).  These are applied to
      the base environment of the impersonated guest user when creating a new
      guest process.  For additional flexibility the IGuestSession::processCreate
      and IGuestSession::processCreateEx methods allows you to
      specify individual environment changes for each process you create.
      With newer guest addition versions, the base environment is also made
      available via IGuestSession::environmentBase.  (One reason
      for why we record changes to a base environment instead of working
      directly on an environment block is that we need to be compatible
      with older guest additions.  Another reason is that this way it is always
      possible to undo all the changes you've scheduled.)
    
      Interface ID:
        {3E14C189-4A75-437E-B0BB-7E7C90D0DF2A}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestSession(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestSession._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestSession._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def close(self):
       """
        Closes this session. All opened guest directories, files and
        processes which are not referenced by clients anymore will be
        closed. Guest processes which fall into this category and still
        are running in the guest will be terminated automatically.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IGuestSession_close(*req)
       
       return 

   def copyFromGuest(self, _arg_sources, _arg_filters, _arg_flags, _arg_destination):
       """
        Copies directories and/or files from guest to the host.

        This function requires several parallel arrays to be supplied, one
        set for each source.
      
        :param _arg_sources: Paths to directories and/or files on the guest side that should be copied to the host. If the path ends with a path delimiter, only the directory's content is being copied. Guest path style.
        :param _arg_filters: Array of source filters. This uses the DOS/NT style wildcard characters '?' and '*'.
        :param _arg_flags: Array of comma-separated list of source flags. The following flags are available for directory sources: CopyIntoExisting Allow copying into an existing destination directory. The following flags are available for file sources: NoReplace Do not replace any destination object. FollowLinks Follows (and handles) (symbolic) links. Update Only copy when the source file is newer than the destination file or when the destination file is missing.
        :param _arg_destination: Where to put the sources on the host. Host path style.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_sources,)
       req += (_arg_filters,)
       req += (_arg_flags,)
       req += (_arg_destination,)
       val = self.mgr.getService().IGuestSession_copyFromGuest(*req)
       
       return IProgress(self.mgr, val)

   def copyToGuest(self, _arg_sources, _arg_filters, _arg_flags, _arg_destination):
       """
        Copies directories and/or files from host to the guest.

        This function requires several parallel arrays to be supplied, one
        set for each source.
      
        :param _arg_sources: Paths to directories and/or files on the host side that should be copied to the guest. If the path ends with a path delimiter, only the directory's content is being copied. Host path style.
        :param _arg_filters: Array of source filters. This uses the DOS/NT style wildcard characters '?' and '*'.
        :param _arg_flags: Array of comma-separated list of source flags. The following flags are available for directory sources: CopyIntoExisting Allow copying into an existing destination directory. The following flags are available for file sources: NoReplace Do not replace any destination object. FollowLinks Follows (and handles) (symbolic) links. Update Only copy when the source file is newer than the destination file or when the destination file is missing.
        :param _arg_destination: Where to put the sources on the guest. Guest path style.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_sources,)
       req += (_arg_filters,)
       req += (_arg_flags,)
       req += (_arg_destination,)
       val = self.mgr.getService().IGuestSession_copyToGuest(*req)
       
       return IProgress(self.mgr, val)

   def directoryCopy(self, _arg_source, _arg_destination, _arg_flags):
       """
        Recursively copies a directory from one guest location to another.

        
        :param _arg_source: The path to the directory to copy (in the guest). Guest path style.
        :param _arg_destination: The path to the target directory (in the guest). Unless the flag is given, the directory shall not already exist. Guest path style.
        :param _arg_flags: Zero or more values.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

        Expected result codes:
        E_NOTIMPL
          Not yet implemented.
        
       """
   
       req = (self.handle,)
       req += (_arg_source,)
       req += (_arg_destination,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_directoryCopy(*req)
       
       return IProgress(self.mgr, val)

   def directoryCopyFromGuest(self, _arg_source, _arg_destination, _arg_flags):
       """
        Recursively copies a directory from the guest to the host.
      
        :param _arg_source: Path to the directory on the guest side that should be copied to the host. Guest path style.
        :param _arg_destination: Where to put the directory on the host. Unless the flag is given, the directory shall not already exist. Host path style.
        :param _arg_flags: Zero or more values.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_source,)
       req += (_arg_destination,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_directoryCopyFromGuest(*req)
       
       return IProgress(self.mgr, val)

   def directoryCopyToGuest(self, _arg_source, _arg_destination, _arg_flags):
       """
        Recursively copies a directory from the host to the guest.
      
        :param _arg_source: Path to the directory on the host side that should be copied to the guest. Host path style.
        :param _arg_destination: Where to put the file in the guest. Unless the flag is given, the directory shall not already exist. Guest style path.
        :param _arg_flags: Zero or more values.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_source,)
       req += (_arg_destination,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_directoryCopyToGuest(*req)
       
       return IProgress(self.mgr, val)

   def directoryCreate(self, _arg_path, _arg_mode, _arg_flags):
       """
        Creates a directory in the guest.

        
        :param _arg_path: Path to the directory directory to be created. Guest path style.
        :param _arg_mode: The UNIX-style access mode mask to create the directory with. Whether/how all three access groups and associated access rights are realized is guest OS dependent. The API does the best it can on each OS.
        :param _arg_flags: Zero or more flags.

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Error while creating the directory.
        
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_mode,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_directoryCreate(*req)
       
       return 

   def directoryCreateTemp(self, _arg_templateName, _arg_mode, _arg_path, _arg_secure):
       """
        Creates a temporary directory in the guest.

        
        :param _arg_templateName: Template for the name of the directory to create. This must contain at least one 'X' character. The first group of consecutive 'X' characters in the template will be replaced by a random alphanumeric string to produce a unique name.
        :param _arg_mode: The UNIX-style access mode mask to create the directory with. Whether/how all three access groups and associated access rights are realized is guest OS dependent. The API does the best it can on each OS. This parameter is ignore if the @a secure parameter is set to @c true. It is strongly recommended to use 0700.
        :param _arg_path: The path to the directory in which the temporary directory should be created. Guest path style.
        :param _arg_secure: Whether to fail if the directory can not be securely created. Currently this means that another unprivileged user cannot manipulate the path specified or remove the temporary directory after it has been created. Also causes the mode specified to be ignored. May not be supported on all guest types.
        :return: On success this will contain the full path to the created directory. Guest path style.
        :rtype: wstring

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          The operation is not possible as requested on this particular
          guest type.
        E_INVALIDARG
          Invalid argument. This includes an incorrectly formatted template,
          or a non-absolute path.
        VBOX_E_IPRT_ERROR
          The temporary directory could not be created. Possible reasons
          include a non-existing path or an insecure path when the secure
          option was requested.
        
        .. note:: It is strongly recommended to use 0700.
       """
   
       req = (self.handle,)
       req += (_arg_templateName,)
       req += (_arg_mode,)
       req += (_arg_path,)
       req += (_arg_secure,)
       val = self.mgr.getService().IGuestSession_directoryCreateTemp(*req)
       
       return String(self.mgr, val)

   def directoryExists(self, _arg_path, _arg_followSymlinks):
       """
        Checks whether a directory exists in the guest or not.

        
        :param _arg_path: Path to the directory to check if exists. Guest path style.
        :param _arg_followSymlinks: If @c true, symbolic links in the final component will be followed and the existance of the symlink target made the question for this method. If @c false, a symbolic link in the final component will make the method return @c false (because a symlink isn't a directory).
        :return: Returns @c true if the directory exists, @c false if not.
        :rtype: boolean

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Error while checking existence of the directory specified.
        
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_followSymlinks,)
       val = self.mgr.getService().IGuestSession_directoryExists(*req)
       
       return Boolean(self.mgr, val)

   def directoryOpen(self, _arg_path, _arg_filter, _arg_flags):
       """
        Opens a directory in the guest and creates a ::IGuestDirectory
        object that can be used for further operations.

        
        :param _arg_path: Path to the directory to open. Guest path style.
        :param _arg_filter: Optional directory listing filter to apply. This uses the DOS/NT style wildcard characters '?' and '*'.
        :param _arg_flags: Zero or more flags.
        :return: object containing the opened directory.
        :rtype: IGuestDirectory

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Directory to open was not found.
        VBOX_E_IPRT_ERROR
          Error while opening the directory.
        VBOX_E_MAXIMUM_REACHED
          The maximum of concurrent guest directories has been reached.
        
        .. note:: This method follows symbolic links by default at the moment, this
          may change in the future.
        .. note:: One idiosyncrasy of the current implementation is that you will NOT
          get VBOX_E_OBJECT_NOT_FOUND returned here if the directory doesn't exist.
          Instead the read function will fail with VBOX_E_IPRT_ERROR.  This will
          be fixed soon.
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_filter,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_directoryOpen(*req)
       
       return IGuestDirectory(self.mgr, val)

   def directoryRemove(self, _arg_path):
       """
        Removes a guest directory if empty.

        
        :param _arg_path: Path to the directory that should be removed. Guest path style.

        .. note:: Symbolic links in the final component will not be followed,
          instead an not-a-directory error is reported.
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       val = self.mgr.getService().IGuestSession_directoryRemove(*req)
       
       return 

   def directoryRemoveRecursive(self, _arg_path, _arg_flags):
       """
        Removes a guest directory recursively.


        :param _arg_path: Path of the directory that is to be removed recursively. Guest path style.
        :param _arg_flags: Zero or more flags. WARNING! SPECIFYING IS MANDATORY AT THE MOMENT!!
        :return: Progress object to track the operation completion. This is not implemented yet and therefore this method call will block until deletion is completed.
        :rtype: IProgress

        .. note::  WARNING!! THE FLAGS ARE NOT CURRENTLY IMPLEMENTED.  THE IMPLEMENTATION
          WORKS AS IF FLAGS WAS SET TO ::DirectoryRemoveRecFlag_ContentAndDir.
        
        .. note:: If the final path component is a symbolic link, this method will
          fail as it can only be applied to directories.
        .. note:: WARNING! SPECIFYING ::DirectoryRemoveRecFlag_ContentAndDir IS
            MANDATORY AT THE MOMENT!!
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_directoryRemoveRecursive(*req)
       
       return IProgress(self.mgr, val)

   def environmentScheduleSet(self, _arg_name, _arg_value):
       """
        Schedules setting an environment variable when creating the next guest
        process.  This affects the IGuestSession::environmentChanges
        attribute.
      
        :param _arg_name: Name of the environment variable to set. This cannot be empty nor can it contain any equal signs.
        :param _arg_value: Value to set the session environment variable to.

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_value,)
       val = self.mgr.getService().IGuestSession_environmentScheduleSet(*req)
       
       return 

   def environmentScheduleUnset(self, _arg_name):
       """
        Schedules unsetting (removing) an environment variable when creating
        the next guest process.  This affects the
        IGuestSession::environmentChanges attribute.
      
        :param _arg_name: Name of the environment variable to unset. This cannot be empty nor can it contain any equal signs.

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IGuestSession_environmentScheduleUnset(*req)
       
       return 

   def environmentGetBaseVariable(self, _arg_name):
       """
        Gets an environment variable from the session's base environment
        (IGuestSession::environmentBase).

        
        :param _arg_name: Name of the environment variable to get.This cannot be empty nor can it contain any equal signs.
        :return: The value of the variable. Empty if not found. To deal with variables that may have empty values, use .
        :rtype: wstring

        Expected result codes:
        VBOX_E_NOT_SUPPORTEDIf the guest additions does not
          support the session base environment feature.  Support for this was
          introduced with protocol version XXXX.VBOX_E_INVALID_OBJECT_STATEIf the guest additions has
          yet to report the session base environment.
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IGuestSession_environmentGetBaseVariable(*req)
       
       return String(self.mgr, val)

   def environmentDoesBaseVariableExist(self, _arg_name):
       """
        Checks if the given environment variable exists in the session's base
        environment (IGuestSession::environmentBase).

        
        :param _arg_name: Name of the environment variable to look for. This cannot be empty nor can it contain any equal signs.
        :return: TRUE if the variable exists, FALSE if not.
        :rtype: boolean

        Expected result codes:
        VBOX_E_NOT_SUPPORTEDIf the guest additions does not
          support the session base environment feature.  Support for this was
          introduced with protocol version XXXX.VBOX_E_INVALID_OBJECT_STATEIf the guest additions has
          yet to report the session base environment.
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IGuestSession_environmentDoesBaseVariableExist(*req)
       
       return Boolean(self.mgr, val)

   def fileCopy(self, _arg_source, _arg_destination, _arg_flags):
       """
        Copies a file from one guest location to another.

        
        :param _arg_source: The path to the file to copy (in the guest). Guest path style.
        :param _arg_destination: The path to the target file (in the guest). This cannot be a directory. Guest path style.
        :param _arg_flags: Zero or more values.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

        Expected result codes:
        E_NOTIMPL
          Not yet implemented.
        
        .. note:: Will overwrite the destination file unless
          ::FileCopyFlag_NoReplace is specified.
       """
   
       req = (self.handle,)
       req += (_arg_source,)
       req += (_arg_destination,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_fileCopy(*req)
       
       return IProgress(self.mgr, val)

   def fileCopyFromGuest(self, _arg_source, _arg_destination, _arg_flags):
       """
        Copies a file from the guest to the host.

        
        :param _arg_source: Path to the file on the guest side that should be copied to the host. Guest path style.
        :param _arg_destination: Where to put the file on the host (file, not directory). Host path style.
        :param _arg_flags: Zero or more values.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Error starting the copy operation.
        
        .. note:: Will overwrite the destination file unless
          ::FileCopyFlag_NoReplace is specified.
       """
   
       req = (self.handle,)
       req += (_arg_source,)
       req += (_arg_destination,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_fileCopyFromGuest(*req)
       
       return IProgress(self.mgr, val)

   def fileCopyToGuest(self, _arg_source, _arg_destination, _arg_flags):
       """
        Copies a file from the host to the guest.

        
        :param _arg_source: Path to the file on the host side that should be copied to the guest. Host path style.
        :param _arg_destination: Where to put the file in the guest (file, not directory). Guest style path.
        :param _arg_flags: Zero or more values.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Error starting the copy operation.
        
        .. note:: Will overwrite the destination file unless
          ::FileCopyFlag_NoReplace is specified.
       """
   
       req = (self.handle,)
       req += (_arg_source,)
       req += (_arg_destination,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_fileCopyToGuest(*req)
       
       return IProgress(self.mgr, val)

   def fileCreateTemp(self, _arg_templateName, _arg_mode, _arg_path, _arg_secure):
       """
        Creates a temporary file in the guest.

        
        :param _arg_templateName: Template for the name of the file to create. This must contain at least one 'X' character. The first group of consecutive 'X' characters in the template will be replaced by a random alphanumeric string to produce a unique name.
        :param _arg_mode: The UNIX-style access mode mask to create the file with. Whether/how all three access groups and associated access rights are realized is guest OS dependent. The API does the best it can on each OS. This parameter is ignore if the @a secure parameter is set to @c true. It is strongly recommended to use 0600.
        :param _arg_path: The path to the directory in which the temporary file should be created.
        :param _arg_secure: Whether to fail if the file can not be securely created. Currently this means that another unprivileged user cannot manipulate the path specified or remove the temporary file after it has been created. Also causes the mode specified to be ignored. May not be supported on all guest types.
        :return: On success this will contain an open file object for the new temporary file.
        :rtype: IGuestFile

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          The operation is not possible as requested on this particular
          guest OS.
        E_INVALIDARG
          Invalid argument. This includes an incorrectly formatted template,
          or a non-absolute path.
        VBOX_E_IPRT_ERROR
          The temporary file could not be created. Possible reasons include
          a non-existing path or an insecure path when the secure
          option was requested.
        
        .. note:: It is strongly recommended to use 0600.
       """
   
       req = (self.handle,)
       req += (_arg_templateName,)
       req += (_arg_mode,)
       req += (_arg_path,)
       req += (_arg_secure,)
       val = self.mgr.getService().IGuestSession_fileCreateTemp(*req)
       
       return IGuestFile(self.mgr, val)

   def fileExists(self, _arg_path, _arg_followSymlinks):
       """
        Checks whether a regular file exists in the guest or not.

        
        :param _arg_path: Path to the alleged regular file. Guest path style.
        :param _arg_followSymlinks: If @c true, symbolic links in the final component will be followed and the existance of the symlink target made the question for this method. If @c false, a symbolic link in the final component will make the method return @c false (because a symlink isn't a regular file).
        :return: Returns @c true if the file exists, @c false if not. @c false is also return if this @a path does not point to a file object.
        :rtype: boolean

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Error while checking existence of the file specified.
        
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_followSymlinks,)
       val = self.mgr.getService().IGuestSession_fileExists(*req)
       
       return Boolean(self.mgr, val)

   def fileOpen(self, _arg_path, _arg_accessMode, _arg_openAction, _arg_creationMode):
       """
        Opens a file and creates a ::IGuestFile object that
        can be used for further operations.

        
        :param _arg_path: Path to file to open. Guest path style.
        :param _arg_accessMode: The file access mode (read, write and/or append). See for details.
        :param _arg_openAction: What action to take depending on whether the file exists or not. See for details.
        :param _arg_creationMode: The UNIX-style access mode mask to create the file with if @a openAction requested the file to be created (otherwise ignored). Whether/how all three access groups and associated access rights are realized is guest OS dependent. The API does the best it can on each OS.
        :return: object representing the opened file.
        :rtype: IGuestFile

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          File to open was not found.
        VBOX_E_IPRT_ERROR
          Error while opening the file.
        VBOX_E_MAXIMUM_REACHED
          The maximum of concurrent guest files has been reached.
        
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_accessMode,)
       req += (_arg_openAction,)
       req += (_arg_creationMode,)
       val = self.mgr.getService().IGuestSession_fileOpen(*req)
       
       return IGuestFile(self.mgr, val)

   def fileOpenEx(self, _arg_path, _arg_accessMode, _arg_openAction, _arg_sharingMode, _arg_creationMode, _arg_flags):
       """
        Opens a file and creates a ::IGuestFile object that
        can be used for further operations, extended version.

        
        :param _arg_path: Path to file to open. Guest path style.
        :param _arg_accessMode: The file access mode (read, write and/or append). See for details.
        :param _arg_openAction: What action to take depending on whether the file exists or not. See for details.
        :param _arg_sharingMode: The file sharing mode in the guest. This parameter is currently ignore for all guest OSes. It will in the future be implemented for Windows, OS/2 and maybe Solaris guests only, the others will ignore it. Use .
        :param _arg_creationMode: The UNIX-style access mode mask to create the file with if @a openAction requested the file to be created (otherwise ignored). Whether/how all three access groups and associated access rights are realized is guest OS dependent. The API does the best it can on each OS.
        :param _arg_flags: Zero or more values.
        :return: object representing the opened file.
        :rtype: IGuestFile

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          File to open was not found.
        VBOX_E_IPRT_ERROR
          Error while opening the file.
        
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_accessMode,)
       req += (_arg_openAction,)
       req += (_arg_sharingMode,)
       req += (_arg_creationMode,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_fileOpenEx(*req)
       
       return IGuestFile(self.mgr, val)

   def fileQuerySize(self, _arg_path, _arg_followSymlinks):
       """
        Queries the size of a regular file in the guest.

        
        :param _arg_path: Path to the file which size is requested. Guest path style.
        :param _arg_followSymlinks: It @c true, symbolic links in the final path component will be followed to their target, and the size of the target is returned. If @c false, symbolic links in the final path component will make the method call fail (symblink is not a regular file).
        :return: Queried file size.
        :rtype: long long

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          File to was not found.
        VBOX_E_IPRT_ERROR
          Error querying file size.
        
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_followSymlinks,)
       val = self.mgr.getService().IGuestSession_fileQuerySize(*req)
       
       return Long(self.mgr, val)

   def fsObjExists(self, _arg_path, _arg_followSymlinks):
       """
        Checks whether a file system object (file, directory, etc) exists in
        the guest or not.

        
        :param _arg_path: Path to the file system object to check the existance of. Guest path style.
        :param _arg_followSymlinks: If @c true, symbolic links in the final component will be followed and the method will instead check if the target exists. If @c false, symbolic links in the final component will satisfy the method and it will return @c true in @a exists.
        :return: Returns @c true if the file exists, @c false if not.
        :rtype: boolean

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Error while checking existence of the file specified.
        
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_followSymlinks,)
       val = self.mgr.getService().IGuestSession_fsObjExists(*req)
       
       return Boolean(self.mgr, val)

   def fsObjQueryInfo(self, _arg_path, _arg_followSymlinks):
       """
        Queries information about a file system object (file, directory, etc)
        in the guest.

        
        :param _arg_path: Path to the file system object to gather information about. Guest path style.
        :param _arg_followSymlinks: Information about symbolic links is returned if @c false. Otherwise, symbolic links are followed and the returned information concerns itself with the symlink target if @c true.
        :return: object containing the information.
        :rtype: IGuestFsObjInfo

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          The file system object was not found.
        VBOX_E_IPRT_ERROR
          Error while querying information.
        
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_followSymlinks,)
       val = self.mgr.getService().IGuestSession_fsObjQueryInfo(*req)
       
       return IGuestFsObjInfo(self.mgr, val)

   def fsObjRemove(self, _arg_path):
       """
        Removes a file system object (file, symlink, etc) in the guest.  Will
        not work on directories, use IGuestSession::directoryRemove
        to remove directories.

        
        :param _arg_path: Path to the file system object to remove. Guest style path.

        Expected result codes:
        E_NOTIMPL
          The method has not been implemented yet.
        VBOX_E_OBJECT_NOT_FOUND
          The file system object was not found.
        VBOX_E_IPRT_ERROR
          For most other errors. We know this is unhelpful, will fix shortly...
        
        .. note:: This method will remove symbolic links in the final path
          component, not follow them.
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       val = self.mgr.getService().IGuestSession_fsObjRemove(*req)
       
       return 

   def fsObjRemoveArray(self, _arg_path):
       """
        Removes multiple file system objects (files, directories, symlinks, etc)
        in the guest. Use with caution.

        
        :param _arg_path: Array of paths to the file system objects to remove. Guest style path.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

        Expected result codes:
        E_NOTIMPL
          The method has not been implemented yet.
        
        .. note:: This method is not implemented yet and will return E_NOTIMPL.
        .. note:: This method will remove symbolic links in the final path
          component, not follow them.
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       val = self.mgr.getService().IGuestSession_fsObjRemoveArray(*req)
       
       return IProgress(self.mgr, val)

   def fsObjRename(self, _arg_oldPath, _arg_newPath, _arg_flags):
       """
        Renames a file system object (file, directory, symlink, etc) in the
        guest.

        
        :param _arg_oldPath: The current path to the object. Guest path style.
        :param _arg_newPath: The new path to the object. Guest path style.
        :param _arg_flags: Zero or more values.

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          The file system object was not found.
        VBOX_E_IPRT_ERROR
          For most other errors. We know this is unhelpful, will fix shortly...
        
       """
   
       req = (self.handle,)
       req += (_arg_oldPath,)
       req += (_arg_newPath,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_fsObjRename(*req)
       
       return 

   def fsObjMove(self, _arg_source, _arg_destination, _arg_flags):
       """
        Moves a file system object (file, directory, symlink, etc) from one
        guest location to another.

        This differs from IGuestSession::fsObjRename in that it
        can move accross file system boundraries.  In that case it will
        perform a copy and then delete the original.  For directories, this
        can take a while and is subject to races.

        
        :param _arg_source: Path to the file to move. Guest path style.
        :param _arg_destination: Where to move the file to (file, not directory). Guest path style.
        :param _arg_flags: Zero or more values.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

        Expected result codes:
        E_NOTIMPL
          Not yet implemented.
        
       """
   
       req = (self.handle,)
       req += (_arg_source,)
       req += (_arg_destination,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_fsObjMove(*req)
       
       return IProgress(self.mgr, val)

   def fsObjMoveArray(self, _arg_source, _arg_destination, _arg_flags):
       """
        Moves file system objects (files, directories, symlinks, etc) from one
        guest location to another.

        
        :param _arg_source: Array of paths to the file system objects to move. Guest style path.
        :param _arg_destination: Where to move the file system objects to (directory). Guest path style.
        :param _arg_flags: Zero or more values.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

        Expected result codes:
        E_NOTIMPL
          Not yet implemented.
        
       """
   
       req = (self.handle,)
       req += (_arg_source,)
       req += (_arg_destination,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_fsObjMoveArray(*req)
       
       return IProgress(self.mgr, val)

   def fsObjCopyArray(self, _arg_source, _arg_destination, _arg_flags):
       """
        Copies file system objects (files, directories, symlinks, etc) from one
        guest location to another.

        
        :param _arg_source: Array of paths to the file system objects to copy. Guest style path.
        :param _arg_destination: Where to copy the file system objects to (directory). Guest path style.
        :param _arg_flags: Zero or more values.
        :return: Progress object to track the operation to completion.
        :rtype: IProgress

        Expected result codes:
        E_NOTIMPL
          Not yet implemented.
        
       """
   
       req = (self.handle,)
       req += (_arg_source,)
       req += (_arg_destination,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_fsObjCopyArray(*req)
       
       return IProgress(self.mgr, val)

   def fsObjSetACL(self, _arg_path, _arg_followSymlinks, _arg_acl, _arg_mode):
       """
        Sets the access control list (ACL) of a file system object (file,
        directory, etc) in the guest.

        
        :param _arg_path: Full path of the file system object which ACL to set
        :param _arg_followSymlinks: If @c true symbolic links in the final component will be followed, otherwise, if @c false, the method will work directly on a symbolic link in the final component.
        :param _arg_acl: The ACL specification string. To-be-defined.
        :param _arg_mode: UNIX-style mode mask to use if @a acl is empty. As mention in this is realized on a best effort basis and the exact behavior depends on the Guest OS.

        Expected result codes:
        E_NOTIMPL
          The method is not implemented yet.
        
       """
   
       req = (self.handle,)
       req += (_arg_path,)
       req += (_arg_followSymlinks,)
       req += (_arg_acl,)
       req += (_arg_mode,)
       val = self.mgr.getService().IGuestSession_fsObjSetACL(*req)
       
       return 

   def processCreate(self, _arg_executable, _arg_arguments, _arg_environmentChanges, _arg_flags, _arg_timeoutMS):
       """
        Creates a new process running in the guest. The new process will be
        started asynchronously, meaning on return of this function it is not
        be guaranteed that the guest process is in a started state. To wait for
        successful startup, use the IProcess::waitFor call.

        
        :param _arg_executable: Full path to the file to execute in the guest. The file has to exists in the guest VM with executable right to the session user in order to succeed. If empty/null, the first entry in the @a arguments array will be used instead (i.e. argv[0]).
        :param _arg_arguments: Array of arguments passed to the new process. Starting with VirtualBox 5.0 this array starts with argument 0 instead of argument 1 as in previous versions. Whether the zeroth argument can be passed to the guest depends on the VBoxService version running there. If you depend on this, check that the is 3 or higher.
        :param _arg_environmentChanges: Set of environment changes to complement . Takes precedence over the session ones. The changes are in putenv format, i.e. "VAR=VALUE" for setting and "VAR" for unsetting. The changes are applied to the base environment of the impersonated guest user () when creating the process. (This is done on the guest side of things in order to be compatible with older guest additions. That is one of the motivations for not passing in the whole environment here.)
        :param _arg_flags: Process creation flags; see for more information.
        :param _arg_timeoutMS: Timeout (in ms) for limiting the guest process' running time. Pass 0 for an infinite timeout. On timeout the guest process will be killed and its status will be put to an appropriate value. See for more information.
        :return: Guest process object of the newly created process.
        :rtype: IGuestProcess

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Error creating guest process.
        VBOX_E_MAXIMUM_REACHED
          The maximum of concurrent guest processes has been reached.
        
        .. note:: 
          Starting at VirtualBox 4.2 guest process execution by is default limited
          to serve up to 255 guest processes at a time. If all 255 guest processes
          are active and running, creating a new guest process will result in an
          error.

          If ProcessCreateFlag_WaitForStdOut and/or ProcessCreateFlag_WaitForStdErr
          are set, the guest process will not enter the terminated state until
          all data from the specified streams have been read read.
        
        .. note:: 
            Starting with VirtualBox 5.0 this array starts with argument 0
            instead of argument 1 as in previous versions.  Whether the zeroth
            argument can be passed to the guest depends on the VBoxService
            version running there.  If you depend on this, check that the
            IGuestSession::protocolVersion is 3 or higher.
          
       """
   
       req = (self.handle,)
       req += (_arg_executable,)
       req += (_arg_arguments,)
       req += (_arg_environmentChanges,)
       req += (_arg_flags,)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IGuestSession_processCreate(*req)
       
       return IGuestProcess(self.mgr, val)

   def processCreateEx(self, _arg_executable, _arg_arguments, _arg_environmentChanges, _arg_flags, _arg_timeoutMS, _arg_priority, _arg_affinity):
       """
        Creates a new process running in the guest with the extended options
        for setting the process priority and affinity.

        See IGuestSession::processCreate for more information.
      
        :param _arg_executable: Full path to the file to execute in the guest. The file has to exists in the guest VM with executable right to the session user in order to succeed. If empty/null, the first entry in the @a arguments array will be used instead (i.e. argv[0]).
        :param _arg_arguments: Array of arguments passed to the new process. Starting with VirtualBox 5.0 this array starts with argument 0 instead of argument 1 as in previous versions. Whether the zeroth argument can be passed to the guest depends on the VBoxService version running there. If you depend on this, check that the is 3 or higher.
        :param _arg_environmentChanges: Set of environment changes to complement . Takes precedence over the session ones. The changes are in putenv format, i.e. "VAR=VALUE" for setting and "VAR" for unsetting. The changes are applied to the base environment of the impersonated guest user () when creating the process. (This is done on the guest side of things in order to be compatible with older guest additions. That is one of the motivations for not passing in the whole environment here.)
        :param _arg_flags: Process creation flags, see for detailed description of available flags.
        :param _arg_timeoutMS: Timeout (in ms) for limiting the guest process' running time. Pass 0 for an infinite timeout. On timeout the guest process will be killed and its status will be put to an appropriate value. See for more information.
        :param _arg_priority: Process priority to use for execution, see for available priority levels. This is silently ignored if not supported by guest additions.
        :param _arg_affinity: Processor affinity to set for the new process. This is a list of guest CPU numbers the process is allowed to run on. This is silently ignored if the guest does not support setting the affinity of processes, or if the guest additions does not implemet this feature.
        :return: Guest process object of the newly created process.
        :rtype: IGuestProcess

        .. note:: 
            Starting with VirtualBox 5.0 this array starts with argument 0
            instead of argument 1 as in previous versions.  Whether the zeroth
            argument can be passed to the guest depends on the VBoxService
            version running there.  If you depend on this, check that the
            IGuestSession::protocolVersion is 3 or higher.
          
        .. note:: This is silently ignored if not supported by guest additions.
        .. note:: 
            This is silently ignored if the guest does not support setting the
            affinity of processes, or if the guest additions does not implemet
            this feature.
          
       """
   
       req = (self.handle,)
       req += (_arg_executable,)
       req += (_arg_arguments,)
       req += (_arg_environmentChanges,)
       req += (_arg_flags,)
       req += (_arg_timeoutMS,)
       req += (_arg_priority,)
       req += (_arg_affinity,)
       val = self.mgr.getService().IGuestSession_processCreateEx(*req)
       
       return IGuestProcess(self.mgr, val)

   def processGet(self, _arg_pid):
       """
        Gets a certain guest process by its process ID (PID).
      
        :param _arg_pid: Process ID (PID) to get guest process for.
        :return: Guest process of specified process ID (PID).
        :rtype: IGuestProcess

       """
   
       req = (self.handle,)
       req += (_arg_pid,)
       val = self.mgr.getService().IGuestSession_processGet(*req)
       
       return IGuestProcess(self.mgr, val)

   def symlinkCreate(self, _arg_symlink, _arg_target, _arg_type):
       """
        Creates a symbolic link in the guest.

        
        :param _arg_symlink: Path to the symbolic link that should be created. Guest path style.
        :param _arg_target: The path to the symbolic link target. If not an absolute, this will be relative to the @a symlink location at access time. Guest path style.
        :param _arg_type: The symbolic link type (mainly for Windows). See for more information.

        Expected result codes:
        E_NOTIMPL
          The method is not implemented yet.
        
       """
   
       req = (self.handle,)
       req += (_arg_symlink,)
       req += (_arg_target,)
       req += (_arg_type,)
       val = self.mgr.getService().IGuestSession_symlinkCreate(*req)
       
       return 

   def symlinkExists(self, _arg_symlink):
       """
        Checks whether a symbolic link exists in the guest.

        
        :param _arg_symlink: Path to the alleged symbolic link. Guest path style.
        :return: Returns @c true if the symbolic link exists. Returns @c false if it does not exist, if the file system object identified by the path is not a symbolic link, or if the object type is inaccessible to the user, or if the @a symlink argument is empty.
        :rtype: boolean

        Expected result codes:
        E_NOTIMPL
          The method is not implemented yet.
        
       """
   
       req = (self.handle,)
       req += (_arg_symlink,)
       val = self.mgr.getService().IGuestSession_symlinkExists(*req)
       
       return Boolean(self.mgr, val)

   def symlinkRead(self, _arg_symlink, _arg_flags):
       """
        Reads the target value of a symbolic link in the guest.

        
        :param _arg_symlink: Path to the symbolic link to read.
        :param _arg_flags: Zero or more values.
        :return: Target value of the symbolic link. Guest path style.
        :rtype: wstring

        Expected result codes:
        E_NOTIMPL
          The method is not implemented yet.
        
       """
   
       req = (self.handle,)
       req += (_arg_symlink,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuestSession_symlinkRead(*req)
       
       return String(self.mgr, val)

   def waitFor(self, _arg_waitFor, _arg_timeoutMS):
       """
        Waits for one or more events to happen.
      
        :param _arg_waitFor: Specifies what to wait for; see for more information.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: The overall wait result; see for more information.
        :rtype: GuestSessionWaitResult

       """
   
       req = (self.handle,)
       req += (_arg_waitFor,)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IGuestSession_waitFor(*req)
       
       return GuestSessionWaitResult(self.mgr, val)

   def waitForArray(self, _arg_waitFor, _arg_timeoutMS):
       """
        Waits for one or more events to happen.
        Scriptable version of #waitFor.
      
        :param _arg_waitFor: Specifies what to wait for; see for more information.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: The overall wait result; see for more information.
        :rtype: GuestSessionWaitResult

       """
   
       req = (self.handle,)
       req += (_arg_waitFor,)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IGuestSession_waitForArray(*req)
       
       return GuestSessionWaitResult(self.mgr, val)

   def getUser(self):
       """Returns the user name used by this session to impersonate
        users in the guest.
       """
       val = self.mgr.getService().IGuestSession_getUser(self.handle)
       return String(self.mgr, val)

   def getDomain(self):
       """Returns the domain name used by this session to impersonate
        users in the guest.
       """
       val = self.mgr.getService().IGuestSession_getDomain(self.handle)
       return String(self.mgr, val)

   def getName(self):
       """Returns the session's friendly name. """
       val = self.mgr.getService().IGuestSession_getName(self.handle)
       return String(self.mgr, val)

   def getId(self):
       """Returns the internal session ID. """
       val = self.mgr.getService().IGuestSession_getId(self.handle)
       return UnsignedInt(self.mgr, val)

   def getTimeout(self):
       """
        Returns the session timeout (in ms).
         """
       val = self.mgr.getService().IGuestSession_getTimeout(self.handle)
       return UnsignedInt(self.mgr, val)

   def setTimeout(self, value):
       """
        Returns the session timeout (in ms).
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IGuestSession_setTimeout(_this, _val)

   def getProtocolVersion(self):
       """Returns the protocol version which is used by this session to
        communicate with the guest. """
       val = self.mgr.getService().IGuestSession_getProtocolVersion(self.handle)
       return UnsignedInt(self.mgr, val)

   def getStatus(self):
       """Returns the current session status. """
       val = self.mgr.getService().IGuestSession_getStatus(self.handle)
       return GuestSessionStatus(self.mgr, val)

   def getEnvironmentChanges(self):
       """
        The set of scheduled environment changes to the base environment of the
        session.  They are in putenv format, i.e. "VAR=VALUE" for setting and
        "VAR" for unsetting.  One entry per variable (change).  The changes are
        applied when creating new guest processes.

        This is writable, so to undo all the scheduled changes, assign it an
        empty array.
       """
       val = self.mgr.getService().IGuestSession_getEnvironmentChanges(self.handle)
       return String(self.mgr, val, True)

   def setEnvironmentChanges(self, value):
       """
        The set of scheduled environment changes to the base environment of the
        session.  They are in putenv format, i.e. "VAR=VALUE" for setting and
        "VAR" for unsetting.  One entry per variable (change).  The changes are
        applied when creating new guest processes.

        This is writable, so to undo all the scheduled changes, assign it an
        empty array.
       """
       _this=self.handle
       if type(value) in [int, bool, str, tuple, list]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IGuestSession_setEnvironmentChanges(_this, _val)

   def getEnvironmentBase(self):
       """
        The base environment of the session.  They are on the "VAR=VALUE" form,
        one array entry per variable.
        

        Access fails with VBOX_E_NOT_SUPPORTED if the guest additions does not
        support the session base environment feature.  Support for this was
        introduced with protocol version XXXX.

        Access fails with VBOX_E_INVALID_OBJECT_STATE if the guest additions
        has yet to report the session base environment.
       """
       val = self.mgr.getService().IGuestSession_getEnvironmentBase(self.handle)
       return String(self.mgr, val, True)

   def getProcesses(self):
       """
        Returns all current guest processes.
       """
       val = self.mgr.getService().IGuestSession_getProcesses(self.handle)
       return IGuestProcess(self.mgr, val, True)

   def getPathStyle(self):
       """
        The style of paths used by the guest.  Handy for giving the right kind
        of path specifications to IGuestSession::fileOpen and similar methods.
       """
       val = self.mgr.getService().IGuestSession_getPathStyle(self.handle)
       return PathStyle(self.mgr, val)

   def getCurrentDirectory(self):
       """
        Gets or sets the current directory of the session.  Guest path style.
         """
       val = self.mgr.getService().IGuestSession_getCurrentDirectory(self.handle)
       return String(self.mgr, val)

   def setCurrentDirectory(self, value):
       """
        Gets or sets the current directory of the session.  Guest path style.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IGuestSession_setCurrentDirectory(_this, _val)

   def getUserHome(self):
       """
        Returns the user's home / profile directory.  Guest path style.
       """
       val = self.mgr.getService().IGuestSession_getUserHome(self.handle)
       return String(self.mgr, val)

   def getUserDocuments(self):
       """
        Returns the user's documents directory.  Guest path style.
       """
       val = self.mgr.getService().IGuestSession_getUserDocuments(self.handle)
       return String(self.mgr, val)

   def getDirectories(self):
       """
        Returns all currently opened guest directories.
       """
       val = self.mgr.getService().IGuestSession_getDirectories(self.handle)
       return IGuestDirectory(self.mgr, val, True)

   def getFiles(self):
       """
        Returns all currently opened guest files.
       """
       val = self.mgr.getService().IGuestSession_getFiles(self.handle)
       return IGuestFile(self.mgr, val, True)

   def getEventSource(self):
       """
        Event source for guest session events.
       """
       val = self.mgr.getService().IGuestSession_getEventSource(self.handle)
       return IEventSource(self.mgr, val)



   _Attrs_ = {'user':[getUser,None],
              'domain':[getDomain,None],
              'name':[getName,None],
              'id':[getId,None],
              'timeout':[getTimeout,setTimeout,],
              'protocolVersion':[getProtocolVersion,None],
              'status':[getStatus,None],
              'environmentChanges':[getEnvironmentChanges,setEnvironmentChanges,],
              'environmentBase':[getEnvironmentBase,None],
              'processes':[getProcesses,None],
              'pathStyle':[getPathStyle,None],
              'currentDirectory':[getCurrentDirectory,setCurrentDirectory,],
              'userHome':[getUserHome,None],
              'userDocuments':[getUserDocuments,None],
              'directories':[getDirectories,None],
              'files':[getFiles,None],
              'eventSource':[getEventSource,None]}

class IProcess(IUnknown):
   """
      Abstract parent interface for processes handled by VirtualBox.
    
      Interface ID:
        {BC68370C-8A02-45F3-A07D-A67AA72756AA}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IProcess(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IProcess._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IProcess._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def waitFor(self, _arg_waitFor, _arg_timeoutMS):
       """
        Waits for one or more events to happen.
      
        :param _arg_waitFor: Specifies what to wait for; see for more information.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: The overall wait result; see for more information.
        :rtype: ProcessWaitResult

       """
   
       req = (self.handle,)
       req += (_arg_waitFor,)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IProcess_waitFor(*req)
       
       return ProcessWaitResult(self.mgr, val)

   def waitForArray(self, _arg_waitFor, _arg_timeoutMS):
       """
        Waits for one or more events to happen.
        Scriptable version of #waitFor.
      
        :param _arg_waitFor: Specifies what to wait for; see for more information.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: The overall wait result; see for more information.
        :rtype: ProcessWaitResult

       """
   
       req = (self.handle,)
       req += (_arg_waitFor,)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IProcess_waitForArray(*req)
       
       return ProcessWaitResult(self.mgr, val)

   def read(self, _arg_handle, _arg_toRead, _arg_timeoutMS):
       """
        Reads data from a running process.
      
        :param _arg_handle: Handle to read from. Usually 0 is stdin.
        :param _arg_toRead: Number of bytes to read.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: Array of data read.
        :rtype: List[octet]

       """
   
       req = (self.handle,)
       req += (_arg_handle,)
       req += (_arg_toRead,)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IProcess_read(*req)
       
       return self.mgr.decodebase64( val)

   def write(self, _arg_handle, _arg_flags, _arg_data, _arg_timeoutMS):
       """
        Writes data to a running process.
      
        :param _arg_handle: Handle to write to. Usually 0 is stdin, 1 is stdout and 2 is stderr.
        :param _arg_flags: A combination of flags.
        :param _arg_data: Array of bytes to write. The size of the array also specifies how much to write.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: How many bytes were written.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_handle,)
       req += (_arg_flags,)
       req += (self.mgr.encodebase64(_arg_data),)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IProcess_write(*req)
       
       return UnsignedInt(self.mgr, val)

   def writeArray(self, _arg_handle, _arg_flags, _arg_data, _arg_timeoutMS):
       """
        Writes data to a running process.
        Scriptable version of #write.
      
        :param _arg_handle: Handle to write to. Usually 0 is stdin, 1 is stdout and 2 is stderr.
        :param _arg_flags: A combination of flags.
        :param _arg_data: Array of bytes to write. The size of the array also specifies how much to write.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: How may bytes were written.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_handle,)
       req += (_arg_flags,)
       req += (self.mgr.encodebase64(_arg_data),)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IProcess_writeArray(*req)
       
       return UnsignedInt(self.mgr, val)

   def terminate(self):
       """
        Terminates (kills) a running process.
        

        .. note:: It can take up to 30 seconds to get a guest process killed. In
          case a guest process could not be killed an appropriate error is
          returned.
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IProcess_terminate(*req)
       
       return 

   def getArguments(self):
       """
        The arguments this process is using for execution.
       """
       val = self.mgr.getService().IProcess_getArguments(self.handle)
       return String(self.mgr, val, True)

   def getEnvironment(self):
       """
        The initial process environment.  Not yet implemented.
       """
       val = self.mgr.getService().IProcess_getEnvironment(self.handle)
       return String(self.mgr, val, True)

   def getEventSource(self):
       """
        Event source for process events.
       """
       val = self.mgr.getService().IProcess_getEventSource(self.handle)
       return IEventSource(self.mgr, val)

   def getExecutablePath(self):
       """Full path of the actual executable image. """
       val = self.mgr.getService().IProcess_getExecutablePath(self.handle)
       return String(self.mgr, val)

   def getExitCode(self):
       """
        The exit code. Only available when the process has been
        terminated normally.
       """
       val = self.mgr.getService().IProcess_getExitCode(self.handle)
       return Int(self.mgr, val)

   def getName(self):
       """
        The friendly name of this process.
       """
       val = self.mgr.getService().IProcess_getName(self.handle)
       return String(self.mgr, val)

   def getPID(self):
       """
        The process ID (PID).
       """
       val = self.mgr.getService().IProcess_getPID(self.handle)
       return UnsignedInt(self.mgr, val)

   def getStatus(self):
       """
        The current process status; see ::ProcessStatus
        for more information.
       """
       val = self.mgr.getService().IProcess_getStatus(self.handle)
       return ProcessStatus(self.mgr, val)



   _Attrs_ = {'arguments':[getArguments,None],
              'environment':[getEnvironment,None],
              'eventSource':[getEventSource,None],
              'executablePath':[getExecutablePath,None],
              'exitCode':[getExitCode,None],
              'name':[getName,None],
              'PID':[getPID,None],
              'status':[getStatus,None]}

class IGuestProcess(IProcess):
   """
      Implementation of the ::IProcess object
      for processes the host has started in the guest.
    
      Interface ID:
        {35CF4B3F-4453-4F3E-C9B8-5686939C80B6}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestProcess(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestProcess._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IProcess.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestProcess._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IGuestProcess_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IDirectory(IUnknown):
   """
      Abstract parent interface for directories handled by VirtualBox.
    
      Interface ID:
        {758D7EAC-E4B1-486A-8F2E-747AE346C3E9}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDirectory(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDirectory._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDirectory._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def close(self):
       """
        Closes this directory. After closing operations like reading the next
        directory entry will not be possible anymore.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDirectory_close(*req)
       
       return 

   def read(self):
       """
        Reads the next directory entry of this directory.
        
        :return: Object information of the current directory entry read. Also see .
        :rtype: IFsObjInfo

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          No more directory entries to read.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDirectory_read(*req)
       
       return IFsObjInfo(self.mgr, val)

   def getDirectoryName(self):
       """The path specified when opening the directory. """
       val = self.mgr.getService().IDirectory_getDirectoryName(self.handle)
       return String(self.mgr, val)

   def getFilter(self):
       """Directory listing filter to (specified when opening the directory). """
       val = self.mgr.getService().IDirectory_getFilter(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'directoryName':[getDirectoryName,None],
              'filter':[getFilter,None]}

class IGuestDirectory(IDirectory):
   """
      Implementation of the ::IDirectory object
      for directories in the guest.
    
      Interface ID:
        {CC830458-4974-A19C-4DC6-CC98C2269626}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestDirectory(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestDirectory._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IDirectory.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestDirectory._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IGuestDirectory_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IFile(IUnknown):
   """
      Abstract parent interface for files handled by VirtualBox.
    
      Interface ID:
        {59A235AC-2F1A-4D6C-81FC-E3FA843F49AE}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IFile(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IFile._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IFile._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def close(self):
       """
        Closes this file. After closing operations like reading data,
        writing data or querying information will not be possible anymore.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IFile_close(*req)
       
       return 

   def queryInfo(self):
       """
        Queries information about this file.
      
        :return: Object information of this file. Also see .
        :rtype: IFsObjInfo

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IFile_queryInfo(*req)
       
       return IFsObjInfo(self.mgr, val)

   def querySize(self):
       """
        Queries the current file size.
      
        :return: Queried file size.
        :rtype: long long

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IFile_querySize(*req)
       
       return Long(self.mgr, val)

   def read(self, _arg_toRead, _arg_timeoutMS):
       """
        Reads data from this file.

        The file current position (IFile::offset) is updated on success.
      
        :param _arg_toRead: Number of bytes to read.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: Array of data read.
        :rtype: List[octet]

       """
   
       req = (self.handle,)
       req += (_arg_toRead,)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IFile_read(*req)
       
       return self.mgr.decodebase64( val)

   def readAt(self, _arg_offset, _arg_toRead, _arg_timeoutMS):
       """
        Reads data from an offset of this file.

        The file current position (IFile::offset) is updated on success.
      
        :param _arg_offset: Offset in bytes to start reading.
        :param _arg_toRead: Number of bytes to read.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: Array of data read.
        :rtype: List[octet]

       """
   
       req = (self.handle,)
       req += (_arg_offset,)
       req += (_arg_toRead,)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IFile_readAt(*req)
       
       return self.mgr.decodebase64( val)

   def seek(self, _arg_offset, _arg_whence):
       """
        Changes the current file position of this file.

        The file current position always applies to the IFile::read
        method.  Same for the IFile::write method it except when
        the IFile::accessMode is ::FileAccessMode_AppendOnly
        or ::FileAccessMode_AppendRead.
      
        :param _arg_offset: Offset to seek relative to the position specified by @a whence.
        :param _arg_whence: One of the seek starting points.
        :return: The new file offset after the seek operation.
        :rtype: long long

       """
   
       req = (self.handle,)
       req += (_arg_offset,)
       req += (_arg_whence,)
       val = self.mgr.getService().IFile_seek(*req)
       
       return Long(self.mgr, val)

   def setACL(self, _arg_acl, _arg_mode):
       """
        Sets the ACL of this file.

        
        :param _arg_acl: The ACL specification string. To-be-defined.
        :param _arg_mode: UNIX-style mode mask to use if @a acl is empty. As mention in this is realized on a best effort basis and the exact behavior depends on the Guest OS.

        Expected result codes:
        E_NOTIMPL
          The method is not implemented yet.
        
       """
   
       req = (self.handle,)
       req += (_arg_acl,)
       req += (_arg_mode,)
       val = self.mgr.getService().IFile_setACL(*req)
       
       return 

   def setSize(self, _arg_size):
       """
        Changes the file size.
      
        :param _arg_size: The new file size.

       """
   
       req = (self.handle,)
       req += (_arg_size,)
       val = self.mgr.getService().IFile_setSize(*req)
       
       return 

   def write(self, _arg_data, _arg_timeoutMS):
       """
        Writes bytes to this file.

        The file current position (IFile::offset) is updated on success.
      
        :param _arg_data: Array of bytes to write. The size of the array also specifies how much to write.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: How many bytes were written.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (self.mgr.encodebase64(_arg_data),)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IFile_write(*req)
       
       return UnsignedInt(self.mgr, val)

   def writeAt(self, _arg_offset, _arg_data, _arg_timeoutMS):
       """
        Writes bytes at a certain offset to this file.

        The file current position (IFile::offset) is updated on success.
      
        :param _arg_offset: Offset in bytes to start writing. If the file was opened with the set to or , the offset is ignored and the write always goes to the end of the file.
        :param _arg_data: Array of bytes to write. The size of the array also specifies how much to write.
        :param _arg_timeoutMS: Timeout (in ms) to wait for the operation to complete. Pass 0 for an infinite timeout.
        :return: How many bytes were written.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_offset,)
       req += (self.mgr.encodebase64(_arg_data),)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IFile_writeAt(*req)
       
       return UnsignedInt(self.mgr, val)

   def getEventSource(self):
       """
        Event source for file events.
       """
       val = self.mgr.getService().IFile_getEventSource(self.handle)
       return IEventSource(self.mgr, val)

   def getId(self):
       """
        The ID VirtualBox internally assigned to the open file.
       """
       val = self.mgr.getService().IFile_getId(self.handle)
       return UnsignedInt(self.mgr, val)

   def getInitialSize(self):
       """
        The initial size in bytes when opened.
       """
       val = self.mgr.getService().IFile_getInitialSize(self.handle)
       return Long(self.mgr, val)

   def getOffset(self):
       """
        The current file position.

        The file current position always applies to the IFile::read
        method, which updates it upon return.  Same goes for the IFile::write
        method except when IFile::accessMode is ::FileAccessMode_AppendOnly
        or ::FileAccessMode_AppendRead, where it will always write
        to the end of the file and will leave this attribute unchanged.

        The IFile::seek is used to change this attribute without
        transfering any file data like read and write does.

        
        .. note::  This will not always be correct with older guest additions
        (version 5.2.30 and earlier, as well as versions 6.0.0 thru 6.0.8)
        after a calling IFile::readAt or IFile::writeAt,
        or after calling IFile::write on a file in append mode.
        The correct file offset can be obtained using IFile::seek. """
       val = self.mgr.getService().IFile_getOffset(self.handle)
       return Long(self.mgr, val)

   def getStatus(self):
       """
        Current file status.
       """
       val = self.mgr.getService().IFile_getStatus(self.handle)
       return FileStatus(self.mgr, val)

   def getFilename(self):
       """Full path of the actual file name of this file.
         """
       val = self.mgr.getService().IFile_getFilename(self.handle)
       return String(self.mgr, val)

   def getCreationMode(self):
       """The UNIX-style creation mode specified when opening the file. """
       val = self.mgr.getService().IFile_getCreationMode(self.handle)
       return UnsignedInt(self.mgr, val)

   def getOpenAction(self):
       """The opening action specified when opening the file. """
       val = self.mgr.getService().IFile_getOpenAction(self.handle)
       return FileOpenAction(self.mgr, val)

   def getAccessMode(self):
       """The file access mode. """
       val = self.mgr.getService().IFile_getAccessMode(self.handle)
       return FileAccessMode(self.mgr, val)



   _Attrs_ = {'eventSource':[getEventSource,None],
              'id':[getId,None],
              'initialSize':[getInitialSize,None],
              'offset':[getOffset,None],
              'status':[getStatus,None],
              'filename':[getFilename,None],
              'creationMode':[getCreationMode,None],
              'openAction':[getOpenAction,None],
              'accessMode':[getAccessMode,None]}

class IGuestFile(IFile):
   """
      Implementation of the ::IFile object
      for files in the guest.
    
      Interface ID:
        {92F21DC0-44DE-1653-B717-2EBF0CA9B664}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestFile(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestFile._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IFile.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestFile._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IGuestFile_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IFsObjInfo(IUnknown):
   """
      Abstract parent interface for VirtualBox file system object information.
      This can be information about a file or a directory, for example.
    
      Interface ID:
        {081FC833-C6FA-430E-6020-6A505D086387}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IFsObjInfo(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IFsObjInfo._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IFsObjInfo._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getName(self):
       """
        The object's name.
       """
       val = self.mgr.getService().IFsObjInfo_getName(self.handle)
       return String(self.mgr, val)

   def getType(self):
       """
        The object type. See ::FsObjType for more.
       """
       val = self.mgr.getService().IFsObjInfo_getType(self.handle)
       return FsObjType(self.mgr, val)

   def getFileAttributes(self):
       """
        File attributes. Not implemented yet.
       """
       val = self.mgr.getService().IFsObjInfo_getFileAttributes(self.handle)
       return String(self.mgr, val)

   def getObjectSize(self):
       """
        The logical size (st_size). For normal files this is the size of the file.
        For symbolic links, this is the length of the path name contained in the
        symbolic link. For other objects this fields needs to be specified.
       """
       val = self.mgr.getService().IFsObjInfo_getObjectSize(self.handle)
       return Long(self.mgr, val)

   def getAllocatedSize(self):
       """
        Disk allocation size (st_blocks * DEV_BSIZE).
       """
       val = self.mgr.getService().IFsObjInfo_getAllocatedSize(self.handle)
       return Long(self.mgr, val)

   def getAccessTime(self):
       """
        Time of last access (st_atime).
       """
       val = self.mgr.getService().IFsObjInfo_getAccessTime(self.handle)
       return Long(self.mgr, val)

   def getBirthTime(self):
       """
        Time of file birth (st_birthtime).
       """
       val = self.mgr.getService().IFsObjInfo_getBirthTime(self.handle)
       return Long(self.mgr, val)

   def getChangeTime(self):
       """
        Time of last status change (st_ctime).
       """
       val = self.mgr.getService().IFsObjInfo_getChangeTime(self.handle)
       return Long(self.mgr, val)

   def getModificationTime(self):
       """
        Time of last data modification (st_mtime).
       """
       val = self.mgr.getService().IFsObjInfo_getModificationTime(self.handle)
       return Long(self.mgr, val)

   def getUID(self):
       """
        The user owning the filesystem object (st_uid).  This is -1 if not available.
       """
       val = self.mgr.getService().IFsObjInfo_getUID(self.handle)
       return Int(self.mgr, val)

   def getUserName(self):
       """
        The user name.
       """
       val = self.mgr.getService().IFsObjInfo_getUserName(self.handle)
       return String(self.mgr, val)

   def getGID(self):
       """
        The group the filesystem object is assigned (st_gid).  This is -1 if not available.
       """
       val = self.mgr.getService().IFsObjInfo_getGID(self.handle)
       return Int(self.mgr, val)

   def getGroupName(self):
       """
        The group name.
       """
       val = self.mgr.getService().IFsObjInfo_getGroupName(self.handle)
       return String(self.mgr, val)

   def getNodeId(self):
       """
        The unique identifier (within the filesystem) of this filesystem object (st_ino).
        This is zero if not availalbe.
       """
       val = self.mgr.getService().IFsObjInfo_getNodeId(self.handle)
       return Long(self.mgr, val)

   def getNodeIdDevice(self):
       """
        The device number of the device which this filesystem object resides on (st_dev).
       """
       val = self.mgr.getService().IFsObjInfo_getNodeIdDevice(self.handle)
       return UnsignedInt(self.mgr, val)

   def getHardLinks(self):
       """
        Number of hard links to this filesystem object (st_nlink).
       """
       val = self.mgr.getService().IFsObjInfo_getHardLinks(self.handle)
       return UnsignedInt(self.mgr, val)

   def getDeviceNumber(self):
       """
        The device number of a character or block device type object (st_rdev).
       """
       val = self.mgr.getService().IFsObjInfo_getDeviceNumber(self.handle)
       return UnsignedInt(self.mgr, val)

   def getGenerationId(self):
       """
        The current generation number (st_gen).
       """
       val = self.mgr.getService().IFsObjInfo_getGenerationId(self.handle)
       return UnsignedInt(self.mgr, val)

   def getUserFlags(self):
       """
        User flags (st_flags).
       """
       val = self.mgr.getService().IFsObjInfo_getUserFlags(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'name':[getName,None],
              'type':[getType,None],
              'fileAttributes':[getFileAttributes,None],
              'objectSize':[getObjectSize,None],
              'allocatedSize':[getAllocatedSize,None],
              'accessTime':[getAccessTime,None],
              'birthTime':[getBirthTime,None],
              'changeTime':[getChangeTime,None],
              'modificationTime':[getModificationTime,None],
              'UID':[getUID,None],
              'userName':[getUserName,None],
              'GID':[getGID,None],
              'groupName':[getGroupName,None],
              'nodeId':[getNodeId,None],
              'nodeIdDevice':[getNodeIdDevice,None],
              'hardLinks':[getHardLinks,None],
              'deviceNumber':[getDeviceNumber,None],
              'generationId':[getGenerationId,None],
              'userFlags':[getUserFlags,None]}

class IGuestFsObjInfo(IFsObjInfo):
   """
      Represents the guest implementation of the
      ::IFsObjInfo object.
    
      Interface ID:
        {6620DB85-44E0-CA69-E9E0-D4907CECCBE5}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestFsObjInfo(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestFsObjInfo._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IFsObjInfo.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestFsObjInfo._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IGuestFsObjInfo_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IGuest(IUnknown):
   """
      The IGuest interface represents information about the operating system
      running inside the virtual machine. Used in
      IConsole::guest.

      IGuest provides information about the guest operating system, whether
      Guest Additions are installed and other OS-specific virtual machine
      properties.
    
      Interface ID:
        {13A11514-402E-022E-6180-C3944DE3F9C8}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuest(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuest._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuest._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def internalGetStatistics(self):
       """
        Internal method; do not use as it might change at any time.
      














       """
   
       req = (self.handle,)
       val = self.mgr.getService().IGuest_internalGetStatistics(*req)
       
       return UnsignedInt(self.mgr,val["cpuUser"]), UnsignedInt(self.mgr,val["cpuKernel"]), UnsignedInt(self.mgr,val["cpuIdle"]), UnsignedInt(self.mgr,val["memTotal"]), UnsignedInt(self.mgr,val["memFree"]), UnsignedInt(self.mgr,val["memBalloon"]), UnsignedInt(self.mgr,val["memShared"]), UnsignedInt(self.mgr,val["memCache"]), UnsignedInt(self.mgr,val["pagedTotal"]), UnsignedInt(self.mgr,val["memAllocTotal"]), UnsignedInt(self.mgr,val["memFreeTotal"]), UnsignedInt(self.mgr,val["memBalloonTotal"]), UnsignedInt(self.mgr,val["memSharedTotal"])

   def getFacilityStatus(self, _arg_facility):
       """
        Get the current status of a Guest Additions facility.
      
        :param _arg_facility: Facility to check status for.

        :return: The current (latest) facility status.
        :rtype: AdditionsFacilityStatus

       """
   
       req = (self.handle,)
       req += (_arg_facility,)
       val = self.mgr.getService().IGuest_getFacilityStatus(*req)
       
       return AdditionsFacilityStatus(self.mgr,val["returnval"]), Long(self.mgr,val["timestamp"])

   def getAdditionsStatus(self, _arg_level):
       """
        Retrieve the current status of a certain Guest Additions run level.

        
        :param _arg_level: Status level to check
        :return: Flag whether the status level has been reached or not
        :rtype: boolean

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          Wrong status level specified.
        
       """
   
       req = (self.handle,)
       req += (_arg_level,)
       val = self.mgr.getService().IGuest_getAdditionsStatus(*req)
       
       return Boolean(self.mgr, val)

   def setCredentials(self, _arg_userName, _arg_password, _arg_domain, _arg_allowInteractiveLogon):
       """
        Store login credentials that can be queried by guest operating
        systems with Additions installed. The credentials are transient
        to the session and the guest may also choose to erase them. Note
        that the caller cannot determine whether the guest operating system
        has queried or made use of the credentials.

        
        :param _arg_userName: User name string, can be empty
        :param _arg_password: Password string, can be empty
        :param _arg_domain: Domain name (guest logon scheme specific), can be empty
        :param _arg_allowInteractiveLogon: Flag whether the guest should alternatively allow the user to interactively specify different credentials. This flag might not be supported by all versions of the Additions.

        Expected result codes:
        VBOX_E_VM_ERROR
          VMM device is not available.
        
       """
   
       req = (self.handle,)
       req += (_arg_userName,)
       req += (_arg_password,)
       req += (_arg_domain,)
       req += (_arg_allowInteractiveLogon,)
       val = self.mgr.getService().IGuest_setCredentials(*req)
       
       return 

   def createSession(self, _arg_user, _arg_password, _arg_domain, _arg_sessionName):
       """
        Creates a new guest session for controlling the guest. The new session
        will be started asynchronously, meaning on return of this function it is
        not guaranteed that the guest session is in a started and/or usable state.
        To wait for successful startup, use the IGuestSession::waitFor
        call.

        A guest session represents one impersonated user account in the guest, so
        every operation will use the same credentials specified when creating
        the session object via IGuest::createSession. Anonymous
        sessions, that is, sessions without specifying a valid
        user account in the guest are not allowed reasons of security.

        There can be a maximum of 32 sessions at once per VM.  An error will
        be returned if this has been reached.

        For more information please consult ::IGuestSession
        :param _arg_user: User name this session will be using to control the guest; has to exist and have the appropriate rights to execute programs in the VM. Must not be empty.
        :param _arg_password: Password of the user account to be used. Empty passwords are allowed.
        :param _arg_domain: Domain name of the user account to be used if the guest is part of a domain. Optional. This feature is not implemented yet.
        :param _arg_sessionName: The session's friendly name. Optional, can be empty.
        :return: The newly created session object.
        :rtype: IGuestSession

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Error creating guest session.
        VBOX_E_MAXIMUM_REACHED
          The maximum of concurrent guest sessions has been reached.
        
       """
   
       req = (self.handle,)
       req += (_arg_user,)
       req += (_arg_password,)
       req += (_arg_domain,)
       req += (_arg_sessionName,)
       val = self.mgr.getService().IGuest_createSession(*req)
       
       return IGuestSession(self.mgr, val)

   def findSession(self, _arg_sessionName):
       """
        Finds guest sessions by their friendly name and returns an interface
        array with all found guest sessions.
      
        :param _arg_sessionName: The session's friendly name to find. Wildcards like ? and * are allowed.
        :return: Array with all guest sessions found matching the name specified.
        :rtype: List[IGuestSession]

       """
   
       req = (self.handle,)
       req += (_arg_sessionName,)
       val = self.mgr.getService().IGuest_findSession(*req)
       
       return IGuestSession(self.mgr, val, True)

   def updateGuestAdditions(self, _arg_source, _arg_arguments, _arg_flags):
       """
        Automatically updates already installed Guest Additions in a VM.

        At the moment only Windows guests are supported.

        Because the VirtualBox Guest Additions drivers are not WHQL-certified
        yet there might be warning dialogs during the actual Guest Additions
        update. These need to be confirmed manually in order to continue the
        installation process. This applies to Windows 2000 and Windows XP guests
        and therefore these guests can't be updated in a fully automated fashion
        without user interaction. However, to start a Guest Additions update for
        the mentioned Windows versions anyway, the flag
        AdditionsUpdateFlag_WaitForUpdateStartOnly can be specified. See
        ::AdditionsUpdateFlag for more information.

        
        :param _arg_source: Path to the Guest Additions .ISO file to use for the update.
        :param _arg_arguments: Optional command line arguments to use for the Guest Additions installer. Useful for retrofitting features which weren't installed before in the guest.
        :param _arg_flags: flags.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          Guest OS is not supported for automated Guest Additions updates or the
          already installed Guest Additions are not ready yet.
        VBOX_E_IPRT_ERROR
          Error while updating.
        
       """
   
       req = (self.handle,)
       req += (_arg_source,)
       req += (_arg_arguments,)
       req += (_arg_flags,)
       val = self.mgr.getService().IGuest_updateGuestAdditions(*req)
       
       return IProgress(self.mgr, val)

   def getOSTypeId(self):
       """
        Identifier of the Guest OS type as reported by the Guest
        Additions.
        You may use IVirtualBox::getGuestOSType to obtain
        an IGuestOSType object representing details about the given
        Guest OS type.
        
        .. note:: 
          If Guest Additions are not installed, this value will be
          the same as IMachine::OSTypeId.
         """
       val = self.mgr.getService().IGuest_getOSTypeId(self.handle)
       return String(self.mgr, val)

   def getAdditionsRunLevel(self):
       """
        Current run level of the installed Guest Additions.
       """
       val = self.mgr.getService().IGuest_getAdditionsRunLevel(self.handle)
       return AdditionsRunLevelType(self.mgr, val)

   def getAdditionsVersion(self):
       """
        Version of the installed Guest Additions in the same format as
        IVirtualBox::version.
       """
       val = self.mgr.getService().IGuest_getAdditionsVersion(self.handle)
       return String(self.mgr, val)

   def getAdditionsRevision(self):
       """
        The internal build revision number of the installed Guest Additions.

        See also IVirtualBox::revision.
       """
       val = self.mgr.getService().IGuest_getAdditionsRevision(self.handle)
       return UnsignedInt(self.mgr, val)

   def getDnDSource(self):
       """
        Retrieves the drag'n drop source implementation for the guest side, that
        is, handling and retrieving drag'n drop data from the guest.
       """
       val = self.mgr.getService().IGuest_getDnDSource(self.handle)
       return IGuestDnDSource(self.mgr, val)

   def getDnDTarget(self):
       """
        Retrieves the drag'n drop source implementation for the host side. This
        will allow the host to handle and initiate a drag'n drop operation to copy
        data from the host to the guest.
       """
       val = self.mgr.getService().IGuest_getDnDTarget(self.handle)
       return IGuestDnDTarget(self.mgr, val)

   def getEventSource(self):
       """
        Event source for guest events.
       """
       val = self.mgr.getService().IGuest_getEventSource(self.handle)
       return IEventSource(self.mgr, val)

   def getFacilities(self):
       """
        Returns a collection of current known facilities. Only returns facilities where
        a status is known, e.g. facilities with an unknown status will not be returned.
       """
       val = self.mgr.getService().IGuest_getFacilities(self.handle)
       return IAdditionsFacility(self.mgr, val, True)

   def getSessions(self):
       """Returns a collection of all opened guest sessions. """
       val = self.mgr.getService().IGuest_getSessions(self.handle)
       return IGuestSession(self.mgr, val, True)

   def getMemoryBalloonSize(self):
       """Guest system memory balloon size in megabytes (transient property). """
       val = self.mgr.getService().IGuest_getMemoryBalloonSize(self.handle)
       return UnsignedInt(self.mgr, val)

   def setMemoryBalloonSize(self, value):
       """Guest system memory balloon size in megabytes (transient property). """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IGuest_setMemoryBalloonSize(_this, _val)

   def getStatisticsUpdateInterval(self):
       """Interval to update guest statistics in seconds. """
       val = self.mgr.getService().IGuest_getStatisticsUpdateInterval(self.handle)
       return UnsignedInt(self.mgr, val)

   def setStatisticsUpdateInterval(self, value):
       """Interval to update guest statistics in seconds. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IGuest_setStatisticsUpdateInterval(_this, _val)



   _Attrs_ = {'OSTypeId':[getOSTypeId,None],
              'additionsRunLevel':[getAdditionsRunLevel,None],
              'additionsVersion':[getAdditionsVersion,None],
              'additionsRevision':[getAdditionsRevision,None],
              'dnDSource':[getDnDSource,None],
              'dnDTarget':[getDnDTarget,None],
              'eventSource':[getEventSource,None],
              'facilities':[getFacilities,None],
              'sessions':[getSessions,None],
              'memoryBalloonSize':[getMemoryBalloonSize,setMemoryBalloonSize,],
              'statisticsUpdateInterval':[getStatisticsUpdateInterval,setStatisticsUpdateInterval,]}

class IProgress(IUnknown):
   """
        The IProgress interface is used to track and control
        asynchronous tasks within VirtualBox.

        An instance of this is returned every time VirtualBox starts
        an asynchronous task (in other words, a separate thread) which
        continues to run after a method call returns. For example,
        IMachine::saveState, which saves the state of
        a running virtual machine, can take a long time to complete.
        To be able to display a progress bar, a user interface such as
        the VirtualBox graphical user interface can use the IProgress
        object returned by that method.

        Note that IProgress is a "read-only" interface in the sense
        that only the VirtualBox internals behind the Main API can
        create and manipulate progress objects, whereas client code
        can only use the IProgress object to monitor a task's
        progress and, if #cancelable is @c true,
        cancel the task by calling #cancel.

        A task represented by IProgress consists of either one or
        several sub-operations that run sequentially, one by one (see
        #operation and #operationCount).
        Every operation is identified by a number (starting from 0)
        and has a separate description.

        You can find the individual percentage of completion of the current
        operation in #operationPercent and the
        percentage of completion of the task as a whole
        in #percent.

        Similarly, you can wait for the completion of a particular
        operation via #waitForOperationCompletion or
        for the completion of the whole task via
        #waitForCompletion.
    
      Interface ID:
        {D7B98D2B-30E8-447E-99CB-E31BECAE6AE4}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IProgress(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IProgress._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IProgress._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def waitForCompletion(self, _arg_timeout):
       """
          Waits until the task is done (including all sub-operations)
          with a given timeout in milliseconds; specify -1 for an indefinite wait.

          Note that the VirtualBox/XPCOM/COM/native event queues of the calling
          thread are not processed while waiting. Neglecting event queues may
          have dire consequences (degrade performance, resource hogs,
          deadlocks, etc.), this is specially so for the main thread on
          platforms using XPCOM. Callers are advised wait for short periods
          and service their event queues between calls, or to create a worker
          thread to do the waiting.

        
        :param _arg_timeout: Maximum time in milliseconds to wait or -1 to wait indefinitely.

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Failed to wait for task completion.
        
       """
   
       req = (self.handle,)
       req += (_arg_timeout,)
       val = self.mgr.getService().IProgress_waitForCompletion(*req)
       
       return 

   def waitForOperationCompletion(self, _arg_operation, _arg_timeout):
       """
          Waits until the given operation is done with a given timeout in
          milliseconds; specify -1 for an indefinite wait.

          See #waitForCompletion
        :param _arg_operation: Number of the operation to wait for. Must be less than .
        :param _arg_timeout: Maximum time in milliseconds to wait or -1 to wait indefinitely.

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Failed to wait for operation completion.
        
       """
   
       req = (self.handle,)
       req += (_arg_operation,)
       req += (_arg_timeout,)
       val = self.mgr.getService().IProgress_waitForOperationCompletion(*req)
       
       return 

   def cancel(self):
       """
        Cancels the task.
        

        Expected result codes:
        VBOX_E_INVALID_OBJECT_STATE
          Operation cannot be canceled.
        
        .. note:: 
          If #cancelable is @c false, then this method will fail.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IProgress_cancel(*req)
       
       return 

   def getId(self):
       """ID of the task. """
       val = self.mgr.getService().IProgress_getId(self.handle)
       return String(self.mgr, val)

   def getDescription(self):
       """Description of the task. """
       val = self.mgr.getService().IProgress_getDescription(self.handle)
       return String(self.mgr, val)

   def getInitiator(self):
       """Initiator of the task. """
       val = self.mgr.getService().IProgress_getInitiator(self.handle)
       return IUnknown(self.mgr, val)

   def getCancelable(self):
       """Whether the task can be interrupted. """
       val = self.mgr.getService().IProgress_getCancelable(self.handle)
       return Boolean(self.mgr, val)

   def getPercent(self):
       """
        Current progress value of the task as a whole, in percent.
        This value depends on how many operations are already complete.
        Returns 100 if #completed is @c true.
       """
       val = self.mgr.getService().IProgress_getPercent(self.handle)
       return UnsignedInt(self.mgr, val)

   def getTimeRemaining(self):
       """
            Estimated remaining time until the task completes, in
            seconds. Returns 0 once the task has completed; returns -1
            if the remaining time cannot be computed, in particular if
            the current progress is 0.

            Even if a value is returned, the estimate will be unreliable
            for low progress values. It will become more reliable as the
            task progresses; it is not recommended to display an ETA
            before at least 20% of a task have completed.
         """
       val = self.mgr.getService().IProgress_getTimeRemaining(self.handle)
       return Int(self.mgr, val)

   def getCompleted(self):
       """Whether the task has been completed. """
       val = self.mgr.getService().IProgress_getCompleted(self.handle)
       return Boolean(self.mgr, val)

   def getCanceled(self):
       """Whether the task has been canceled. """
       val = self.mgr.getService().IProgress_getCanceled(self.handle)
       return Boolean(self.mgr, val)

   def getResultCode(self):
       """
        Result code of the progress task.
        Valid only if #completed is @c true.
       """
       val = self.mgr.getService().IProgress_getResultCode(self.handle)
       return Int(self.mgr, val)

   def getErrorInfo(self):
       """
        Extended information about the unsuccessful result of the
        progress operation. May be @c null if no extended information
        is available.
        Valid only if #completed is @c true and
        #resultCode indicates a failure.
       """
       val = self.mgr.getService().IProgress_getErrorInfo(self.handle)
       return IVirtualBoxErrorInfo(self.mgr, val)

   def getOperationCount(self):
       """
          Number of sub-operations this task is divided into.
          Every task consists of at least one suboperation.
       """
       val = self.mgr.getService().IProgress_getOperationCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getOperation(self):
       """Number of the sub-operation being currently executed. """
       val = self.mgr.getService().IProgress_getOperation(self.handle)
       return UnsignedInt(self.mgr, val)

   def getOperationDescription(self):
       """
          Description of the sub-operation being currently executed.
       """
       val = self.mgr.getService().IProgress_getOperationDescription(self.handle)
       return String(self.mgr, val)

   def getOperationPercent(self):
       """Progress value of the current sub-operation only, in percent. """
       val = self.mgr.getService().IProgress_getOperationPercent(self.handle)
       return UnsignedInt(self.mgr, val)

   def getOperationWeight(self):
       """Weight value of the current sub-operation only. """
       val = self.mgr.getService().IProgress_getOperationWeight(self.handle)
       return UnsignedInt(self.mgr, val)

   def getTimeout(self):
       """
          When non-zero, this specifies the number of milliseconds after which
          the operation will automatically be canceled. This can only be set on
          cancelable objects.
       """
       val = self.mgr.getService().IProgress_getTimeout(self.handle)
       return UnsignedInt(self.mgr, val)

   def setTimeout(self, value):
       """
          When non-zero, this specifies the number of milliseconds after which
          the operation will automatically be canceled. This can only be set on
          cancelable objects.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IProgress_setTimeout(_this, _val)

   def getEventSource(self):
       """ """
       val = self.mgr.getService().IProgress_getEventSource(self.handle)
       return IEventSource(self.mgr, val)



   _Attrs_ = {'id':[getId,None],
              'description':[getDescription,None],
              'initiator':[getInitiator,None],
              'cancelable':[getCancelable,None],
              'percent':[getPercent,None],
              'timeRemaining':[getTimeRemaining,None],
              'completed':[getCompleted,None],
              'canceled':[getCanceled,None],
              'resultCode':[getResultCode,None],
              'errorInfo':[getErrorInfo,None],
              'operationCount':[getOperationCount,None],
              'operation':[getOperation,None],
              'operationDescription':[getOperationDescription,None],
              'operationPercent':[getOperationPercent,None],
              'operationWeight':[getOperationWeight,None],
              'timeout':[getTimeout,setTimeout,],
              'eventSource':[getEventSource,None]}

class ISnapshot(IUnknown):
   """
      The ISnapshot interface represents a snapshot of the virtual
      machine.

      Together with the differencing media that are created
      when a snapshot is taken, a machine can be brought back to
      the exact state it was in when the snapshot was taken.

      The ISnapshot interface has no methods, only attributes; snapshots
      are controlled through methods of the ::IMachine interface
      which also manage the media associated with the snapshot.
      The following operations exist:

        * IMachine::takeSnapshot creates a new snapshot
              by creating new, empty differencing images for the machine's
              media and saving the VM settings and (if the VM is running)
              the current VM state in the snapshot.

              The differencing images will then receive all data written to
              the machine's media, while their parent (base) images
              remain unmodified after the snapshot has been taken (see
              ::IMedium for details about differencing images).
              This simplifies restoring a machine to the state of a snapshot:
              only the differencing images need to be deleted.

              The current machine state is not changed by taking a snapshot
              except that IMachine::currentSnapshot is set to
              the newly created snapshot, which is also added to the machine's
              snapshots tree.
          
          * IMachine::restoreSnapshot resets a machine to
              the state of a previous snapshot by deleting the differencing
              image of each of the machine's media and setting the machine's
              settings and state to the state that was saved in the snapshot (if any).

              This destroys the machine's current state. After calling this,
              IMachine::currentSnapshot points to the snapshot
              that was restored.
          
          * IMachine::deleteSnapshot deletes a snapshot
              without affecting the current machine state.

              This does not change the current machine state, but instead frees the
              resources allocated when the snapshot was taken: the settings and machine
              state file are deleted (if any), and the snapshot's differencing image for
              each of the machine's media gets merged with its parent image.

              Neither the current machine state nor other snapshots are affected
              by this operation, except that parent media will be modified
              to contain the disk data associated with the snapshot being deleted.

              When deleting the current snapshot, the IMachine::currentSnapshot
              attribute is set to the current snapshot's parent or @c null if it
              has no parent. Otherwise the attribute is unchanged.
          

      Each snapshot contains a copy of virtual machine's settings (hardware
      configuration etc.). This copy is contained in an immutable (read-only)
      instance of ::IMachine which is available from the snapshot's
      #machine attribute. When restoring the snapshot, these
      settings are copied back to the original machine.

      In addition, if the machine was running when the
      snapshot was taken (IMachine::state is ::MachineState_Running),
      the current VM state is saved in the snapshot (similarly to what happens
      when a VM's state is saved). The snapshot is then said to be online
      because when restoring it, the VM will be running.

      If the machine was in ::MachineState_Saved saved,
      the snapshot receives a copy of the execution state file
      (IMachine::stateFilePath).

      Otherwise, if the machine was not running (::MachineState_PoweredOff
      or ::MachineState_Aborted), the snapshot is offline;
      it then contains a so-called "zero execution state", representing a
      machine that is powered off.
    
      Interface ID:
        {6CC49055-DAD4-4496-85CF-3F76BCB3B5FA}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshot(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshot._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshot._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getId(self):
       """UUID of the snapshot. """
       val = self.mgr.getService().ISnapshot_getId(self.handle)
       return String(self.mgr, val)

   def getName(self):
       """Short name of the snapshot.
      
        .. note:: Setting this attribute causes IMachine::saveSettings to
      be called implicitly. """
       val = self.mgr.getService().ISnapshot_getName(self.handle)
       return String(self.mgr, val)

   def setName(self, value):
       """Short name of the snapshot.
      
        .. note:: Setting this attribute causes IMachine::saveSettings to
      be called implicitly. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISnapshot_setName(_this, _val)

   def getDescription(self):
       """Optional description of the snapshot.
      
        .. note:: Setting this attribute causes IMachine::saveSettings to
      be called implicitly. """
       val = self.mgr.getService().ISnapshot_getDescription(self.handle)
       return String(self.mgr, val)

   def setDescription(self, value):
       """Optional description of the snapshot.
      
        .. note:: Setting this attribute causes IMachine::saveSettings to
      be called implicitly. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISnapshot_setDescription(_this, _val)

   def getTimeStamp(self):
       """
        Timestamp of the snapshot, in milliseconds since 1970-01-01 UTC.
       """
       val = self.mgr.getService().ISnapshot_getTimeStamp(self.handle)
       return Long(self.mgr, val)

   def getOnline(self):
       """
        @c true if this snapshot is an online snapshot and @c false otherwise.

          When this attribute is @c true, the
          IMachine::stateFilePath attribute of the
          #machine object associated with this snapshot
          will point to the saved state file. Otherwise, it will be
          an empty string.
       """
       val = self.mgr.getService().ISnapshot_getOnline(self.handle)
       return Boolean(self.mgr, val)

   def getMachine(self):
       """
        Virtual machine this snapshot is taken on. This object
        stores all settings the machine had when taking this snapshot.
        
        .. note:: 
          The returned machine object is immutable, i.e. no
          any settings can be changed.
         """
       val = self.mgr.getService().ISnapshot_getMachine(self.handle)
       return IMachine(self.mgr, val)

   def getParent(self):
       """
        Parent snapshot (a snapshot this one is based on), or
        @c null if the snapshot has no parent (i.e. is the first snapshot).
       """
       val = self.mgr.getService().ISnapshot_getParent(self.handle)
       return ISnapshot(self.mgr, val)

   def getChildren(self):
       """
        Child snapshots (all snapshots having this one as a parent).
        By inspecting this attribute starting with a machine's root snapshot
        (which can be obtained by calling IMachine::findSnapshot
        with a @c null UUID), a machine's snapshots tree can be iterated over.
       """
       val = self.mgr.getService().ISnapshot_getChildren(self.handle)
       return ISnapshot(self.mgr, val, True)

   def getChildrenCount(self):
       """
        Returns the number of direct children of this snapshot.
       """
       val = self.mgr.getService().ISnapshot_getChildrenCount(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'id':[getId,None],
              'name':[getName,setName,],
              'description':[getDescription,setDescription,],
              'timeStamp':[getTimeStamp,None],
              'online':[getOnline,None],
              'machine':[getMachine,None],
              'parent':[getParent,None],
              'children':[getChildren,None],
              'childrenCount':[getChildrenCount,None]}

class IMedium(IUnknown):
   """
      The IMedium interface represents virtual storage for a machine's
      hard disks, CD/DVD or floppy drives. It will typically represent
      a disk image on the host, for example a VDI or VMDK file representing
      a virtual hard disk, or an ISO or RAW file representing virtual
      removable media, but can also point to a network location (e.g.
      for iSCSI targets).

      Instances of IMedium are connected to virtual machines by way of medium
      attachments, which link the storage medium to a particular device slot
      of a storage controller of the virtual machine.
      In the VirtualBox API, virtual storage is therefore always represented
      by the following chain of object links:

        * IMachine::storageControllers contains an array of
          storage controllers (IDE, SATA, SCSI, SAS or a floppy controller;
          these are instances of ::IStorageController).
          * IMachine::mediumAttachments contains an array of
          medium attachments (instances of ::IMediumAttachment
          created by IMachine::attachDevice),
          each containing a storage controller from the above array, a
          port/device specification, and an instance of IMedium representing
          the medium storage (image file).

          For removable media, the storage medium is optional; a medium
          attachment with no medium represents a CD/DVD or floppy drive
          with no medium inserted. By contrast, hard disk attachments
          will always have an IMedium object attached.
          * Each IMedium in turn points to a storage unit (such as a file
          on the host computer or a network resource) that holds actual
          data. This location is represented by the #location
          attribute.

      Existing media are opened using IVirtualBox::openMedium;
      new hard disk media can be created with the VirtualBox API using the
      IVirtualBox::createMedium method. Differencing hard
      disks (see below) are usually implicitly created by VirtualBox as
      needed, but may also be created explicitly using #createDiffStorage.
      VirtualBox cannot create CD/DVD or floppy images (ISO and RAW files); these
      should be created with external tools and then opened from within VirtualBox.

      Only for CD/DVDs and floppies, an IMedium instance can also represent a host
      drive. In that case the #id attribute contains the UUID of
      one of the drives in IHost::DVDDrives or IHost::floppyDrives.

      Media registries

      When a medium has been opened or created using one of the aforementioned
      APIs, it becomes "known" to VirtualBox. Known media can be attached
      to virtual machines and re-found through IVirtualBox::openMedium.
      They also appear in the global
      IVirtualBox::hardDisks,
      IVirtualBox::DVDImages and
      IVirtualBox::floppyImages arrays.

      Prior to VirtualBox 4.0, opening a medium added it to a global media registry
      in the VirtualBox.xml file, which was shared between all machines and made
      transporting machines and their media from one host to another difficult.

      Starting with VirtualBox 4.0, media are only added to a registry when they are
      attached to a machine using IMachine::attachDevice. For
      backwards compatibility, which registry a medium is added to depends on which
      VirtualBox version created a machine:

        * If the medium has first been attached to a machine which was created by
          VirtualBox 4.0 or later, it is added to that machine's media registry in
          the machine XML settings file. This way all information about a machine's
          media attachments is contained in a single file and can be transported
          easily.
          * For older media attachments (i.e. if the medium was first attached to a
          machine which was created with a VirtualBox version before 4.0), media
          continue to be registered in the global VirtualBox settings file, for
          backwards compatibility.

      See IVirtualBox::openMedium for more information.

      Media are removed from media registries by the IMedium::close,
      #deleteStorage and #mergeTo methods.

      Accessibility checks

      VirtualBox defers media accessibility checks until the #refreshState
      method is called explicitly on a medium. This is done to make the VirtualBox object
      ready for serving requests as fast as possible and let the end-user
      application decide if it needs to check media accessibility right away or not.

      As a result, when VirtualBox starts up (e.g. the VirtualBox
      object gets created for the first time), all known media are in the
      "Inaccessible" state, but the value of the #lastAccessError
      attribute is an empty string because no actual accessibility check has
      been made yet.

      After calling #refreshState, a medium is considered
      accessible if its storage unit can be read. In that case, the
      #state attribute has a value of "Created". If the storage
      unit cannot be read (for example, because it is located on a disconnected
      network resource, or was accidentally deleted outside VirtualBox),
      the medium is considered inaccessible, which is indicated by the
      "Inaccessible" state. The exact reason why the medium is inaccessible can be
      obtained by reading the #lastAccessError attribute.

      Medium types

      There are five types of medium behavior which are stored in the
      #type attribute (see ::MediumType) and
      which define the medium's behavior with attachments and snapshots.

      All media can be also divided in two groups: base media and
      differencing media. A base medium contains all sectors of the
      medium data in its own storage and therefore can be used independently.
      In contrast, a differencing medium is a "delta" to some other medium and
      contains only those sectors which differ from that other medium, which is
      then called a parent. The differencing medium is said to be
      linked to that parent. The parent may be itself a differencing
      medium, thus forming a chain of linked media. The last element in that
      chain must always be a base medium. Note that several differencing
      media may be linked to the same parent medium.

      Differencing media can be distinguished from base media by querying the
      #parent attribute: base media do not have parents they would
      depend on, so the value of this attribute is always @c null for them.
      Using this attribute, it is possible to walk up the medium tree (from the
      child medium to its parent). It is also possible to walk down the tree
      using the #children attribute.

      Note that the type of all differencing media is "normal"; all other
      values are meaningless for them. Base media may be of any type.

      Automatic composition of the file name part

      Another extension to the IMedium::location attribute is that
      there is a possibility to cause VirtualBox to compose a unique value for
      the file name part of the location using the UUID of the hard disk. This
      applies only to hard disks in ::MediumState_NotCreated state,
      e.g. before the storage unit is created, and works as follows. You set the
      value of the IMedium::location attribute to a location
      specification which only contains the path specification but not the file
      name part and ends with either a forward slash or a backslash character.
      In response, VirtualBox will generate a new UUID for the hard disk and
      compose the file name using the following pattern:
      
        <path>/{<uuid>}.<ext>
      
      where <path> is the supplied path specification,
      <uuid> is the newly generated UUID and <ext>
      is the default extension for the storage format of this hard disk. After
      that, you may call any of the methods that create a new hard disk storage
      unit and they will use the generated UUID and file name.
    
      Interface ID:
        {AD47AD09-787B-44AB-B343-A082A3F2DFB1}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMedium(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMedium._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMedium._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def setIds(self, _arg_setImageId, _arg_imageId, _arg_setParentId, _arg_parentId):
       """
        Changes the UUID and parent UUID for a hard disk medium.
      
        :param _arg_setImageId: Select whether a new image UUID is set or not.
        :param _arg_imageId: New UUID for the image. If an empty string is passed, then a new UUID is automatically created, provided that @a setImageId is @c true. Specifying a zero UUID is not allowed.
        :param _arg_setParentId: Select whether a new parent UUID is set or not.
        :param _arg_parentId: New parent UUID for the image. If an empty string is passed, then a new UUID is automatically created, provided @a setParentId is @c true. A zero UUID is valid.

       """
   
       req = (self.handle,)
       req += (_arg_setImageId,)
       req += (_arg_imageId,)
       req += (_arg_setParentId,)
       req += (_arg_parentId,)
       val = self.mgr.getService().IMedium_setIds(*req)
       
       return 

   def refreshState(self):
       """
        If the current medium state (see ::MediumState) is one of
        "Created", "Inaccessible" or "LockedRead", then this performs an
        accessibility check on the medium and sets the value of the #state
        attribute accordingly; that value is also returned for convenience.

        For all other state values, this does not perform a refresh but returns
        the state only.

        The refresh, if performed, may take a long time (several seconds or even
        minutes, depending on the storage unit location and format) because it performs an
        accessibility check of the storage unit. This check may cause a significant
        delay if the storage unit of the given medium is, for example, a file located
        on a network share which is not currently accessible due to connectivity
        problems. In that case, the call will not return until a timeout
        interval defined by the host OS for this operation expires. For this reason,
        it is recommended to never read this attribute on the main UI thread to avoid
        making the UI unresponsive.

        If the last known state of the medium is "Created" and the accessibility
        check fails, then the state would be set to "Inaccessible", and
        #lastAccessError may be used to get more details about the
        failure. If the state of the medium is "LockedRead", then it remains the
        same, and a non-empty value of #lastAccessError will
        indicate a failed accessibility check in this case.

        Note that not all medium states are applicable to all medium types.
      
        :return: New medium state.
        :rtype: MediumState

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMedium_refreshState(*req)
       
       return MediumState(self.mgr, val)

   def getSnapshotIds(self, _arg_machineId):
       """
        Returns an array of UUIDs of all snapshots of the given machine where
        this medium is attached to.

        If the medium is attached to the machine in the current state, then the
        first element in the array will always be the ID of the queried machine
        (i.e. the value equal to the @c machineId argument), followed by
        snapshot IDs (if any).

        If the medium is not attached to the machine in the current state, then
        the array will contain only snapshot IDs.

        The returned array may be @c null if this medium is not attached
        to the given machine at all, neither in the current state nor in one of
        the snapshots.
      
        :param _arg_machineId: UUID of the machine to query.
        :return: Array of snapshot UUIDs of the given machine using this medium.
        :rtype: List[uuid]

       """
   
       req = (self.handle,)
       req += (_arg_machineId,)
       val = self.mgr.getService().IMedium_getSnapshotIds(*req)
       
       return String(self.mgr, val, True)

   def lockRead(self):
       """
        Locks this medium for reading.

        A read lock is shared: many clients can simultaneously lock the
        same medium for reading unless it is already locked for writing (see
        #lockWrite) in which case an error is returned.

        When the medium is locked for reading, it cannot be modified
        from within VirtualBox. This means that any method that changes
        the properties of this medium or contents of the storage unit
        will return an error (unless explicitly stated otherwise). That
        includes an attempt to start a virtual machine that wants to
        write to the medium.

        When the virtual machine is started up, it locks for reading all
        media it uses in read-only mode. If some medium cannot be locked
        for reading, the startup procedure will fail.
        A medium is typically locked for reading while it is used by a running
        virtual machine but has a depending differencing image that receives
        the actual write operations. This way one base medium can have
        multiple child differencing images which can be written to
        simultaneously. Read-only media such as DVD and floppy images are
        also locked for reading only (so they can be in use by multiple
        machines simultaneously).

        A medium is also locked for reading when it is the source of a
        write operation such as #cloneTo or #mergeTo.

        The medium locked for reading must be unlocked by abandoning the
        returned token object, see ::IToken. Calls to
        #lockRead can be nested and the lock is actually released
        when all callers have abandoned the token.

        This method sets the medium state (see #state) to
        "LockedRead" on success. The medium's previous state must be
        one of "Created", "Inaccessible" or "LockedRead".

        Locking an inaccessible medium is not an error; this method performs
        a logical lock that prevents modifications of this medium through
        the VirtualBox API, not a physical file-system lock of the underlying
        storage unit.

        This method returns the current state of the medium
        before the operation.

        
        :return: Token object, when this is released (reference count reaches 0) then the lock count is decreased. The lock is released when the lock count reaches 0.
        :rtype: IToken

        Expected result codes:
        VBOX_E_INVALID_OBJECT_STATE
          Invalid medium state (e.g. not created, locked, inaccessible,
          creating, deleting).
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMedium_lockRead(*req)
       
       return IToken(self.mgr, val)

   def lockWrite(self):
       """
        Locks this medium for writing.

        A write lock, as opposed to #lockRead, is
        exclusive: there may be only one client holding a write lock,
        and there may be no read locks while the write lock is held.
        As a result, read-locking fails if a write lock is held, and
        write-locking fails if either a read or another write lock is held.

        When a medium is locked for writing, it cannot be modified
        from within VirtualBox, and it is not guaranteed that the values
        of its properties are up-to-date. Any method that changes the
        properties of this medium or contents of the storage unit will
        return an error (unless explicitly stated otherwise).

        When a virtual machine is started up, it locks for writing all
        media it uses to write data to. If any medium could not be locked
        for writing, the startup procedure will fail. If a medium has
        differencing images, then while the machine is running, only
        the last ("leaf") differencing image is locked for writing,
        whereas its parents are locked for reading only.

        A medium is also locked for writing when it is the target of a
        write operation such as #cloneTo or #mergeTo.

        The medium locked for writing must be unlocked by abandoning the
        returned token object, see ::IToken. Write locks
        cannot be nested.

        This method sets the medium state (see #state) to
        "LockedWrite" on success. The medium's previous state must be
        either "Created" or "Inaccessible".

        Locking an inaccessible medium is not an error; this method performs
        a logical lock that prevents modifications of this medium through
        the VirtualBox API, not a physical file-system lock of the underlying
        storage unit.

        
        :return: Token object, when this is released (reference count reaches 0) then the lock is released.
        :rtype: IToken

        Expected result codes:
        VBOX_E_INVALID_OBJECT_STATE
          Invalid medium state (e.g. not created, locked, inaccessible,
          creating, deleting).
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMedium_lockWrite(*req)
       
       return IToken(self.mgr, val)

   def close(self):
       """
        Closes this medium.

        The medium must not be attached to any known virtual machine
        and must not have any known child media, otherwise the
        operation will fail.

        When the medium is successfully closed, it is removed from
        the list of registered media, but its storage unit is not
        deleted. In particular, this means that this medium can
        later be opened again using the IVirtualBox::openMedium
        call.

        Note that after this method successfully returns, the given medium
        object becomes uninitialized. This means that any attempt
        to call any of its methods or attributes will fail with the
        "Object not ready" (E_ACCESSDENIED) error.

        

        Expected result codes:
        VBOX_E_INVALID_OBJECT_STATE
          Invalid medium state (other than not created, created or
          inaccessible).
        VBOX_E_OBJECT_IN_USE
          Medium attached to virtual machine.
        VBOX_E_FILE_ERROR
          Settings file not accessible.
        VBOX_E_XML_ERROR
          Could not parse the settings file.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMedium_close(*req)
       
       return 

   def getProperty(self, _arg_name):
       """
        Returns the value of the custom medium property with the given name.

        The list of all properties supported by the given medium format can
        be obtained with IMediumFormat::describeProperties.

        
        :param _arg_name: Name of the property to get.
        :return: Current property value.
        :rtype: wstring

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Requested property does not exist (not supported by the format).
        E_INVALIDARG@a name is @c null or empty.
        .. note:: If this method returns an empty string in @a value, the requested
        property is supported but currently not assigned any value.
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMedium_getProperty(*req)
       
       return String(self.mgr, val)

   def setProperty(self, _arg_name, _arg_value):
       """
        Sets the value of the custom medium property with the given name.

        The list of all properties supported by the given medium format can
        be obtained with IMediumFormat::describeProperties.

        
        :param _arg_name: Name of the property to set.
        :param _arg_value: Property value to set.

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Requested property does not exist (not supported by the format).
        E_INVALIDARG@a name is @c null or empty.
        .. note:: Setting the property value to @c null or an empty string is
        equivalent to deleting the existing value. A default value (if it is
        defined for this property) will be used by the format backend in this
        case.
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_value,)
       val = self.mgr.getService().IMedium_setProperty(*req)
       
       return 

   def getProperties(self, _arg_names):
       """
        Returns values for a group of properties in one call.

        The names of the properties to get are specified using the @a names
        argument which is a list of comma-separated property names or
        an empty string if all properties are to be returned.
        

        The list of all properties supported by the given medium format can
        be obtained with IMediumFormat::describeProperties.

        The method returns two arrays, the array of property names corresponding
        to the @a names argument and the current values of these properties.
        Both arrays have the same number of elements with each element at the
        given index in the first array corresponds to an element at the same
        index in the second array.

        For properties that do not have assigned values, an empty string is
        returned at the appropriate index in the @a returnValues array.

      
        :param _arg_names: Names of properties to get.

        :return: Values of returned properties.
        :rtype: List[wstring]

        .. note:: Currently the value of this argument is ignored and the method
        always returns all existing properties.
       """
   
       req = (self.handle,)
       req += (_arg_names,)
       val = self.mgr.getService().IMedium_getProperties(*req)
       
       return String(self.mgr,val["returnval"], True), String(self.mgr,val["returnNames"], True)

   def setProperties(self, _arg_names, _arg_values):
       """
        Sets values for a group of properties in one call.

        The names of the properties to set are passed in the @a names
        array along with the new values for them in the @a values array. Both
        arrays have the same number of elements with each element at the given
        index in the first array corresponding to an element at the same index
        in the second array.

        If there is at least one property name in @a names that is not valid,
        the method will fail before changing the values of any other properties
        from the @a names array.

        Using this method over #setProperty is preferred if you
        need to set several properties at once since it is more efficient.

        The list of all properties supported by the given medium format can
        be obtained with IMediumFormat::describeProperties.

        Setting the property value to @c null or an empty string is equivalent
        to deleting the existing value. A default value (if it is defined for
        this property) will be used by the format backend in this case.
      
        :param _arg_names: Names of properties to set.
        :param _arg_values: Values of properties to set.

       """
   
       req = (self.handle,)
       req += (_arg_names,)
       req += (_arg_values,)
       val = self.mgr.getService().IMedium_setProperties(*req)
       
       return 

   def createBaseStorage(self, _arg_logicalSize, _arg_variant):
       """
        Starts creating a hard disk storage unit (fixed/dynamic, according
        to the variant flags) in the background. The previous storage unit
        created for this object, if any, must first be deleted using
        #deleteStorage, otherwise the operation will fail.

        Before the operation starts, the medium is placed in
        ::MediumState_Creating state. If the create operation
        fails, the medium will be placed back in ::MediumState_NotCreated
        state.

        After the returned progress object reports that the operation has
        successfully completed, the medium state will be set to ::MediumState_Created, the medium will be remembered by this
        VirtualBox installation and may be attached to virtual machines.

        
        :param _arg_logicalSize: Maximum logical size of the medium in bytes.
        :param _arg_variant: Exact image variant which should be created (as a combination of flags).
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          The variant of storage creation operation is not supported. See IMediumFormat::capabilities.
        
       """
   
       req = (self.handle,)
       req += (_arg_logicalSize,)
       req += (_arg_variant,)
       val = self.mgr.getService().IMedium_createBaseStorage(*req)
       
       return IProgress(self.mgr, val)

   def deleteStorage(self):
       """
        Starts deleting the storage unit of this medium.

        The medium must not be attached to any known virtual machine and must
        not have any known child media, otherwise the operation will fail.
        It will also fail if there is no storage unit to delete or if deletion
        is already in progress, or if the medium is being in use (locked for
        read or for write) or inaccessible. Therefore, the only valid state for
        this operation to succeed is ::MediumState_Created.

        Before the operation starts, the medium is placed in
        ::MediumState_Deleting state and gets removed from the list
        of remembered hard disks (media registry). If the delete operation
        fails, the medium will be remembered again and placed back to
        ::MediumState_Created state.

        After the returned progress object reports that the operation is
        complete, the medium state will be set to
        ::MediumState_NotCreated and you will be able to use one of
        the storage creation methods to create it again.

        
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_OBJECT_IN_USE
          Medium is attached to a virtual machine.
        VBOX_E_NOT_SUPPORTED
          Storage deletion is not allowed because neither of storage creation
          operations are supported. See
          IMediumFormat::capabilities.
        
        .. note:: 
          If the deletion operation fails, it is not guaranteed that the storage
          unit still exists. You may check the IMedium::state value
          to answer this question.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMedium_deleteStorage(*req)
       
       return IProgress(self.mgr, val)

   def createDiffStorage(self, _arg_target, _arg_variant):
       """
        Starts creating an empty differencing storage unit based on this
        medium in the format and at the location defined by the @a target
        argument.

        The target medium must be in ::MediumState_NotCreated
        state (i.e. must not have an existing storage unit). Upon successful
        completion, this operation will set the type of the target medium to
        ::MediumType_Normal and create a storage unit necessary to
        represent the differencing medium data in the given format (according
        to the storage format of the target object).

        After the returned progress object reports that the operation is
        successfully complete, the target medium gets remembered by this
        VirtualBox installation and may be attached to virtual machines.

        
        :param _arg_target: Target medium.
        :param _arg_variant: Exact image variant which should be created (as a combination of flags).
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_OBJECT_IN_USE
          Medium not in @c NotCreated state.
        
        .. note:: 
          The medium will be set to ::MediumState_LockedRead
          state for the duration of this operation.
        
       """
   
       req = (self.handle,)
       req += (_arg_target,)
       req += (_arg_variant,)
       val = self.mgr.getService().IMedium_createDiffStorage(*req)
       
       return IProgress(self.mgr, val)

   def mergeTo(self, _arg_target):
       """
        Starts merging the contents of this medium and all intermediate
        differencing media in the chain to the given target medium.

        The target medium must be either a descendant of this medium or
        its ancestor (otherwise this method will immediately return a failure).
        It follows that there are two logical directions of the merge operation:
        from ancestor to descendant (forward merge) and from descendant to
        ancestor (backward merge). Let us consider the following medium
        chain:

        Base <- Diff_1 <- Diff_2

        Here, calling this method on the Base medium object with
        Diff_2 as an argument will be a forward merge; calling it on
        Diff_2 with Base as an argument will be a backward
        merge. Note that in both cases the contents of the resulting medium
        will be the same, the only difference is the medium object that takes
        the result of the merge operation. In case of the forward merge in the
        above example, the result will be written to Diff_2; in case of
        the backward merge, the result will be written to Base. In
        other words, the result of the operation is always stored in the target
        medium.

        Upon successful operation completion, the storage units of all media in
        the chain between this (source) medium and the target medium, including
        the source medium itself, will be automatically deleted and the
        relevant medium objects (including this medium) will become
        uninitialized. This means that any attempt to call any of
        their methods or attributes will fail with the
        "Object not ready" (E_ACCESSDENIED) error. Applied to the above
        example, the forward merge of Base to Diff_2 will
        delete and uninitialize both Base and Diff_1 media.
        Note that Diff_2 in this case will become a base medium
        itself since it will no longer be based on any other medium.

        Considering the above, all of the following conditions must be met in
        order for the merge operation to succeed:
          * 
            Neither this (source) medium nor any intermediate
            differencing medium in the chain between it and the target
            medium is attached to any virtual machine.
          
          * 
            Neither the source medium nor the target medium is an
            ::MediumType_Immutable medium.
          
          * 
            The part of the medium tree from the source medium to the
            target medium is a linear chain, i.e. all medium in this
            chain have exactly one child which is the next medium in this
            chain. The only exception from this rule is the target medium in
            the forward merge operation; it is allowed to have any number of
            child media because the merge operation will not change its
            logical contents (as it is seen by the guest OS or by children).
          
          * 
            None of the involved media are in
            ::MediumState_LockedRead or
            ::MediumState_LockedWrite state.
          
        :param _arg_target: Target medium.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        .. note:: 
          This (source) medium and all intermediates will be placed to ::MediumState_Deleting state and the target medium will be
          placed to ::MediumState_LockedWrite state and for the
          duration of this operation.
        
       """
   
       req = (self.handle,)
       req += (_arg_target,)
       val = self.mgr.getService().IMedium_mergeTo(*req)
       
       return IProgress(self.mgr, val)

   def cloneTo(self, _arg_target, _arg_variant, _arg_parent):
       """
        Starts creating a clone of this medium in the format and at the
        location defined by the @a target argument.

        The target medium must be either in ::MediumState_NotCreated
        state (i.e. must not have an existing storage unit) or in
        ::MediumState_Created state (i.e. created and not locked, and
        big enough to hold the data or else the copy will be partial). Upon
        successful completion, the cloned medium will contain exactly the
        same sector data as the medium being cloned, except that in the
        first case a new UUID for the clone will be randomly generated, and in
        the second case the UUID will remain unchanged.

        The @a parent argument defines which medium will be the parent
        of the clone. Passing a @c null reference indicates that the clone will
        be a base image, i.e. completely independent. It is possible to specify
        an arbitrary medium for this parameter, including the parent of the
        medium which is being cloned. Even cloning to a child of the source
        medium is possible. Note that when cloning to an existing image, the
        @a parent argument is ignored.

        After the returned progress object reports that the operation is
        successfully complete, the target medium gets remembered by this
        VirtualBox installation and may be attached to virtual machines.

        
        :param _arg_target: Target medium.
        :param _arg_variant: Exact image variant which should be created (as a combination of flags).
        :param _arg_parent: Parent of the cloned medium.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        E_NOTIMPL
          The specified cloning variant is not supported at the moment.
        
        .. note:: 
          This medium will be placed to ::MediumState_LockedRead
          state for the duration of this operation.
        
       """
   
       req = (self.handle,)
       req += (_arg_target,)
       req += (_arg_variant,)
       req += (_arg_parent,)
       val = self.mgr.getService().IMedium_cloneTo(*req)
       
       return IProgress(self.mgr, val)

   def cloneToBase(self, _arg_target, _arg_variant):
       """
    Starts creating a clone of this medium in the format and at the
    location defined by the @a target argument.

    The target medium must be either in ::MediumState_NotCreated
    state (i.e. must not have an existing storage unit) or in
    ::MediumState_Created state (i.e. created and not locked, and
    big enough to hold the data or else the copy will be partial). Upon
    successful completion, the cloned medium will contain exactly the
    same sector data as the medium being cloned, except that in the
    first case a new UUID for the clone will be randomly generated, and in
    the second case the UUID will remain unchanged.

    The @a parent argument defines which medium will be the parent
    of the clone. In this case the clone will be a base image, i.e.
    completely independent. It is possible to specify an arbitrary
    medium for this parameter, including the parent of the
    medium which is being cloned. Even cloning to a child of the source
    medium is possible. Note that when cloning to an existing image, the
    @a parent argument is ignored.

    After the returned progress object reports that the operation is
    successfully complete, the target medium gets remembered by this
    VirtualBox installation and may be attached to virtual machines.

    
        :param _arg_target: Target medium.
        :param _arg_variant: flags).
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        E_NOTIMPL
    The specified cloning variant is not supported at the moment.
    
        .. note:: 
    This medium will be placed to ::MediumState_LockedRead
    state for the duration of this operation.
    
       """
   
       req = (self.handle,)
       req += (_arg_target,)
       req += (_arg_variant,)
       val = self.mgr.getService().IMedium_cloneToBase(*req)
       
       return IProgress(self.mgr, val)

   def moveTo(self, _arg_location):
       """
        Changes the location of this medium. Some medium types may support
        changing the storage unit location by simply changing the value of the
        associated property. In this case the operation is performed
        immediately, and @a progress is returning a @c null reference.
        Otherwise on success there is a progress object returned, which
        signals progress and completion of the operation. This distinction is
        necessary because for some formats the operation is very fast, while
        for others it can be very slow (moving the image file by copying all
        data), and in the former case it'd be a waste of resources to create
        a progress object which will immediately signal completion.

        When setting a location for a medium which corresponds to a/several
        regular file(s) in the host's file system, the given file name may be
        either relative to the IVirtualBox::homeFolder or absolute. Note that if the given location
        specification does not contain the file extension part then a proper
        default extension will be automatically appended by the implementation
        depending on the medium type.

        
        :param _arg_location: New location.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        E_NOTIMPL
          The operation is not implemented yet.
        VBOX_E_NOT_SUPPORTED
          Medium format does not support changing the location.
        
       """
   
       req = (self.handle,)
       req += (_arg_location,)
       val = self.mgr.getService().IMedium_moveTo(*req)
       
       return IProgress(self.mgr, val)

   def compact(self):
       """
        Starts compacting of this medium. This means that the medium is
        transformed into a possibly more compact storage representation.
        This potentially creates temporary images, which can require a
        substantial amount of additional disk space.

        This medium will be placed to ::MediumState_LockedWrite
        state and all its parent media (if any) will be placed to
        ::MediumState_LockedRead state for the duration of this
        operation.

        Please note that the results can be either returned straight away,
        or later as the result of the background operation via the object
        returned via the @a progress parameter.

        
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          Medium format does not support compacting (but potentially
          needs it).
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMedium_compact(*req)
       
       return IProgress(self.mgr, val)

   def resize(self, _arg_logicalSize):
       """
        Starts resizing this medium. This means that the nominal size of the
        medium is set to the new value. Both increasing and decreasing the
        size is possible, and there are no safety checks, since VirtualBox
        does not make any assumptions about the medium contents.

        Resizing usually needs additional disk space, and possibly also
        some temporary disk space. Note that resize does not create a full
        temporary copy of the medium, so the additional disk space requirement
        is usually much lower than using the clone operation.

        This medium will be placed to ::MediumState_LockedWrite
        state for the duration of this operation.

        Please note that the results can be either returned straight away,
        or later as the result of the background operation via the object
        returned via the @a progress parameter.

        
        :param _arg_logicalSize: New nominal capacity of the medium in bytes.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          Medium format does not support resizing.
        
       """
   
       req = (self.handle,)
       req += (_arg_logicalSize,)
       val = self.mgr.getService().IMedium_resize(*req)
       
       return IProgress(self.mgr, val)

   def reset(self):
       """
        Starts erasing the contents of this differencing medium.

        This operation will reset the differencing medium to its initial
        state when it does not contain any sector data and any read operation is
        redirected to its parent medium. This automatically gets called
        during VM power-up for every medium whose #autoReset
        attribute is @c true.

        The medium will be write-locked for the duration of this operation (see
        #lockWrite).

        
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          This is not a differencing medium.
        VBOX_E_INVALID_OBJECT_STATE
          Medium is not in ::MediumState_Created or
          ::MediumState_Inaccessible state.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMedium_reset(*req)
       
       return IProgress(self.mgr, val)

   def changeEncryption(self, _arg_currentPassword, _arg_cipher, _arg_newPassword, _arg_newPasswordId):
       """
        Starts encryption of this medium. This means that the stored data in the
        medium is encrypted.

        This medium will be placed to ::MediumState_LockedWrite
        state.

        Please note that the results can be either returned straight away,
        or later as the result of the background operation via the object
        returned via the @a progress parameter.

        
        :param _arg_currentPassword: The current password the medium is protected with. Use an empty string to indicate that the medium isn't encrypted.
        :param _arg_cipher: The cipher to use for encryption. An empty string indicates no encryption for the result.
        :param _arg_newPassword: The new password the medium should be protected with. An empty password and password ID will result in the medium being encrypted with the current password.
        :param _arg_newPasswordId: The ID of the new password when unlocking the medium.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          Encryption is not supported for this medium because it is attached to more than one VM
          or has children.
        
       """
   
       req = (self.handle,)
       req += (_arg_currentPassword,)
       req += (_arg_cipher,)
       req += (_arg_newPassword,)
       req += (_arg_newPasswordId,)
       val = self.mgr.getService().IMedium_changeEncryption(*req)
       
       return IProgress(self.mgr, val)

   def getEncryptionSettings(self):
       """
        Returns the encryption settings for this medium.

        

        :return: The ID of the password when unlocking the medium.
        :rtype: wstring

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          Encryption is not configured for this medium.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMedium_getEncryptionSettings(*req)
       
       return String(self.mgr,val["returnval"]), String(self.mgr,val["cipher"])

   def checkEncryptionPassword(self, _arg_password):
       """
        Checks whether the supplied password is correct for the medium.

        
        :param _arg_password: The password to check.

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          Encryption is not configured for this medium.
        VBOX_E_PASSWORD_INCORRECT
          The given password is incorrect.
        
       """
   
       req = (self.handle,)
       req += (_arg_password,)
       val = self.mgr.getService().IMedium_checkEncryptionPassword(*req)
       
       return 

   def openForIO(self, _arg_writable, _arg_password):
       """
        Open the medium for I/O.
      
        :param _arg_writable: Set this to open the medium for both reading and writing. When not set the medium is opened readonly.
        :param _arg_password: Password for accessing an encrypted medium. Must be empty if not encrypted.
        :return: Medium I/O object.
        :rtype: IMediumIO

       """
   
       req = (self.handle,)
       req += (_arg_writable,)
       req += (_arg_password,)
       val = self.mgr.getService().IMedium_openForIO(*req)
       
       return IMediumIO(self.mgr, val)

   def getId(self):
       """
        UUID of the medium. For a newly created medium, this value is a randomly
        generated UUID.

        
        .. note:: 
          For media in one of MediumState_NotCreated, MediumState_Creating or
          MediumState_Deleting states, the value of this property is undefined
          and will most likely be an empty UUID.
         """
       val = self.mgr.getService().IMedium_getId(self.handle)
       return String(self.mgr, val)

   def getDescription(self):
       """
        Optional description of the medium. For a newly created medium the value
        of this attribute is an empty string.

        Medium types that don't support this attribute will return E_NOTIMPL in
        attempt to get or set this attribute's value.

        
        .. note:: 
          For some storage types, reading this attribute may return an outdated
          (last known) value when #state is ::MediumState_Inaccessible or ::MediumState_LockedWrite because the value of this attribute is
          stored within the storage unit itself. Also note that changing the
          attribute value is not possible in such case, as well as when the
          medium is the ::MediumState_LockedRead state.
         """
       val = self.mgr.getService().IMedium_getDescription(self.handle)
       return String(self.mgr, val)

   def setDescription(self, value):
       """
        Optional description of the medium. For a newly created medium the value
        of this attribute is an empty string.

        Medium types that don't support this attribute will return E_NOTIMPL in
        attempt to get or set this attribute's value.

        
        .. note:: 
          For some storage types, reading this attribute may return an outdated
          (last known) value when #state is ::MediumState_Inaccessible or ::MediumState_LockedWrite because the value of this attribute is
          stored within the storage unit itself. Also note that changing the
          attribute value is not possible in such case, as well as when the
          medium is the ::MediumState_LockedRead state.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMedium_setDescription(_this, _val)

   def getState(self):
       """
        Returns the current medium state, which is the last state set by
        the accessibility check performed by #refreshState.
        If that method has not yet been called on the medium, the state
        is "Inaccessible"; as opposed to truly inaccessible media, the
        value of #lastAccessError will be an empty string in
        that case.

        
        .. note:: As of version 3.1, this no longer performs an accessibility check
          automatically; call #refreshState for that.
         """
       val = self.mgr.getService().IMedium_getState(self.handle)
       return MediumState(self.mgr, val)

   def getVariant(self):
       """
        Returns the storage format variant information for this medium
        as an array of the flags described at ::MediumVariant.
        Before #refreshState is called this method returns
        an undefined value.
       """
       val = self.mgr.getService().IMedium_getVariant(self.handle)
       return MediumVariant(self.mgr, val, True)

   def getLocation(self):
       """
        Location of the storage unit holding medium data.

        The format of the location string is medium type specific. For medium
        types using regular files in a host's file system, the location
        string is the full file name.
       """
       val = self.mgr.getService().IMedium_getLocation(self.handle)
       return String(self.mgr, val)

   def setLocation(self, value):
       """
        Location of the storage unit holding medium data.

        The format of the location string is medium type specific. For medium
        types using regular files in a host's file system, the location
        string is the full file name.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMedium_setLocation(_this, _val)

   def getName(self):
       """
        Name of the storage unit holding medium data.

        The returned string is a short version of the #location
        attribute that is suitable for representing the medium in situations
        where the full location specification is too long (such as lists
        and comboboxes in GUI frontends). This string is also used by frontends
        to sort the media list alphabetically when needed.

        For example, for locations that are regular files in the host's file
        system, the value of this attribute is just the file name (+ extension),
        without the path specification.

        Note that as opposed to the #location attribute, the name
        attribute will not necessary be unique for a list of media of the
        given type and format.
       """
       val = self.mgr.getService().IMedium_getName(self.handle)
       return String(self.mgr, val)

   def getDeviceType(self):
       """Kind of device (DVD/Floppy/HardDisk) which is applicable to this
        medium. """
       val = self.mgr.getService().IMedium_getDeviceType(self.handle)
       return DeviceType(self.mgr, val)

   def getHostDrive(self):
       """True if this corresponds to a drive on the host. """
       val = self.mgr.getService().IMedium_getHostDrive(self.handle)
       return Boolean(self.mgr, val)

   def getSize(self):
       """
        Physical size of the storage unit used to hold medium data (in bytes).

        
        .. note:: 
          For media whose #state is ::MediumState_Inaccessible, the value of this property is the
          last known size. For ::MediumState_NotCreated media,
          the returned value is zero.
         """
       val = self.mgr.getService().IMedium_getSize(self.handle)
       return Long(self.mgr, val)

   def getFormat(self):
       """
        Storage format of this medium.

        The value of this attribute is a string that specifies a backend used
        to store medium data. The storage format is defined when you create a
        new medium or automatically detected when you open an existing medium,
        and cannot be changed later.

        The list of all storage formats supported by this VirtualBox
        installation can be obtained using
        ISystemProperties::mediumFormats.
       """
       val = self.mgr.getService().IMedium_getFormat(self.handle)
       return String(self.mgr, val)

   def getMediumFormat(self):
       """
        Storage medium format object corresponding to this medium.

        The value of this attribute is a reference to the medium format object
        that specifies the backend properties used to store medium data. The
        storage format is defined when you create a new medium or automatically
        detected when you open an existing medium, and cannot be changed later.

        
        .. note:: @c null is returned if there is no associated medium format
        object. This can e.g. happen for medium objects representing host
        drives and other special medium objects. """
       val = self.mgr.getService().IMedium_getMediumFormat(self.handle)
       return IMediumFormat(self.mgr, val)

   def getType(self):
       """
        Type (role) of this medium.

        The following constraints apply when changing the value of this
        attribute:
          * If a medium is attached to a virtual machine (either in the
              current state or in one of the snapshots), its type cannot be
              changed.
          
          * As long as the medium has children, its type cannot be set
              to ::MediumType_Writethrough.
          
          * The type of all differencing media is
              ::MediumType_Normal and cannot be changed.
          

        The type of a newly created or opened medium is set to
        ::MediumType_Normal, except for DVD and floppy media,
        which have a type of ::MediumType_Writethrough.
       """
       val = self.mgr.getService().IMedium_getType(self.handle)
       return MediumType(self.mgr, val)

   def setType(self, value):
       """
        Type (role) of this medium.

        The following constraints apply when changing the value of this
        attribute:
          * If a medium is attached to a virtual machine (either in the
              current state or in one of the snapshots), its type cannot be
              changed.
          
          * As long as the medium has children, its type cannot be set
              to ::MediumType_Writethrough.
          
          * The type of all differencing media is
              ::MediumType_Normal and cannot be changed.
          

        The type of a newly created or opened medium is set to
        ::MediumType_Normal, except for DVD and floppy media,
        which have a type of ::MediumType_Writethrough.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMedium_setType(_this, _val)

   def getAllowedTypes(self):
       """
        Returns which medium types can selected for this medium.

         """
       val = self.mgr.getService().IMedium_getAllowedTypes(self.handle)
       return MediumType(self.mgr, val, True)

   def getParent(self):
       """
        Parent of this medium (the medium this medium is directly based
        on).

        Only differencing media have parents. For base (non-differencing)
        media, @c null is returned.
       """
       val = self.mgr.getService().IMedium_getParent(self.handle)
       return IMedium(self.mgr, val)

   def getChildren(self):
       """
        Children of this medium (all differencing media directly based
        on this medium). A @c null array is returned if this medium
        does not have any children.
       """
       val = self.mgr.getService().IMedium_getChildren(self.handle)
       return IMedium(self.mgr, val, True)

   def getBase(self):
       """
        Base medium of this medium.

        If this is a differencing medium, its base medium is the medium
        the given medium branch starts from. For all other types of media, this
        property returns the medium object itself (i.e. the same object this
        property is read on).
       """
       val = self.mgr.getService().IMedium_getBase(self.handle)
       return IMedium(self.mgr, val)

   def getReadOnly(self):
       """
        Returns @c true if this medium is read-only and @c false otherwise.

        A medium is considered to be read-only when its contents cannot be
        modified without breaking the integrity of other parties that depend on
        this medium such as its child media or snapshots of virtual machines
        where this medium is attached to these machines. If there are no
        children and no such snapshots then there is no dependency and the
        medium is not read-only.

        The value of this attribute can be used to determine the kind of the
        attachment that will take place when attaching this medium to a
        virtual machine. If the value is @c false then the medium will
        be attached directly. If the value is @c true then the medium
        will be attached indirectly by creating a new differencing child
        medium for that. See the interface description for more information.

        Note that all ::MediumType_Immutable media
        are always read-only while all
        ::MediumType_Writethrough media are
        always not.

        
        .. note:: 
          The read-only condition represented by this attribute is related to
          the medium type and usage, not to the current
          IMedium::state and not to the read-only
          state of the storage unit.
         """
       val = self.mgr.getService().IMedium_getReadOnly(self.handle)
       return Boolean(self.mgr, val)

   def getLogicalSize(self):
       """
        Logical size of this medium (in bytes), as reported to the
        guest OS running inside the virtual machine this medium is
        attached to. The logical size is defined when the medium is created
        and cannot be changed later.

        
        .. note:: 
          For media whose state is #state is ::MediumState_Inaccessible, the value of this property is the
          last known logical size. For ::MediumState_NotCreated
          media, the returned value is zero.
         """
       val = self.mgr.getService().IMedium_getLogicalSize(self.handle)
       return Long(self.mgr, val)

   def getAutoReset(self):
       """
        Whether this differencing medium will be automatically reset each
        time a virtual machine it is attached to is powered up. This
        attribute is automatically set to @c true for the last
        differencing image of an "immutable" medium (see
        ::MediumType).

        See #reset for more information about resetting
        differencing media.

        
        .. note:: 
          Reading this property on a base (non-differencing) medium will
          always @c false. Changing the value of this property in this
          case is not supported.
         """
       val = self.mgr.getService().IMedium_getAutoReset(self.handle)
       return Boolean(self.mgr, val)

   def setAutoReset(self, value):
       """
        Whether this differencing medium will be automatically reset each
        time a virtual machine it is attached to is powered up. This
        attribute is automatically set to @c true for the last
        differencing image of an "immutable" medium (see
        ::MediumType).

        See #reset for more information about resetting
        differencing media.

        
        .. note:: 
          Reading this property on a base (non-differencing) medium will
          always @c false. Changing the value of this property in this
          case is not supported.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMedium_setAutoReset(_this, _val)

   def getLastAccessError(self):
       """
        Text message that represents the result of the last accessibility
        check performed by #refreshState.

        An empty string is returned if the last accessibility check
        was successful or has not yet been called. As a result, if
        #state is "Inaccessible" and this attribute is empty,
        then #refreshState has yet to be called; this is the
        default value of media after VirtualBox initialization.
        A non-empty string indicates a failure and should normally describe
        a reason of the failure (for example, a file read error).
       """
       val = self.mgr.getService().IMedium_getLastAccessError(self.handle)
       return String(self.mgr, val)

   def getMachineIds(self):
       """
        Array of UUIDs of all machines this medium is attached to.

        A @c null array is returned if this medium is not attached to any
        machine or to any machine's snapshot.

        
        .. note:: 
          The returned array will include a machine even if this medium is not
          attached to that machine in the current state but attached to it in
          one of the machine's snapshots. See #getSnapshotIds for
          details.
         """
       val = self.mgr.getService().IMedium_getMachineIds(self.handle)
       return String(self.mgr, val, True)



   _Attrs_ = {'id':[getId,None],
              'description':[getDescription,setDescription,],
              'state':[getState,None],
              'variant':[getVariant,None],
              'location':[getLocation,setLocation,],
              'name':[getName,None],
              'deviceType':[getDeviceType,None],
              'hostDrive':[getHostDrive,None],
              'size':[getSize,None],
              'format':[getFormat,None],
              'mediumFormat':[getMediumFormat,None],
              'type':[getType,setType,],
              'allowedTypes':[getAllowedTypes,None],
              'parent':[getParent,None],
              'children':[getChildren,None],
              'base':[getBase,None],
              'readOnly':[getReadOnly,None],
              'logicalSize':[getLogicalSize,None],
              'autoReset':[getAutoReset,setAutoReset,],
              'lastAccessError':[getLastAccessError,None],
              'machineIds':[getMachineIds,None]}

class IMediumFormat(IUnknown):
   """
        The IMediumFormat interface represents a medium format.

        Each medium format has an associated backend which is used to handle
        media stored in this format. This interface provides information
        about the properties of the associated backend.

        Each medium format is identified by a string represented by the
        #id attribute. This string is used in calls like
        IVirtualBox::createMedium to specify the desired
        format.

        The list of all supported medium formats can be obtained using
        ISystemProperties::mediumFormats.

        
        .. sealso:: ::IMedium
      Interface ID:
        {11BE93C7-A862-4DC9-8C89-BF4BA74A886A}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMediumFormat(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMediumFormat._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMediumFormat._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def describeFileExtensions(self):
       """
        Returns two arrays describing the supported file extensions.

        The first array contains the supported extensions and the seconds one
        the type each extension supports. Both have the same size.

        Note that some backends do not work on files, so this array may be
        empty.

        



       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMediumFormat_describeFileExtensions(*req)
       
       return String(self.mgr,val["extensions"], True), DeviceType(self.mgr,val["types"], True)

   def describeProperties(self):
       """
        Returns several arrays describing the properties supported by this
        format.

        An element with the given index in each array describes one
        property. Thus, the number of elements in each returned array is the
        same and corresponds to the number of supported properties.

        The returned arrays are filled in only if the
        ::MediumFormatCapabilities_Properties flag is set.
        All arguments must be non-@c null.

        






       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMediumFormat_describeProperties(*req)
       
       return String(self.mgr,val["names"], True), String(self.mgr,val["descriptions"], True), DataType(self.mgr,val["types"], True), UnsignedInt(self.mgr,val["flags"], True), String(self.mgr,val["defaults"], True)

   def getId(self):
       """
        Identifier of this format.

        The format identifier is a non-@c null non-empty ASCII string. Note that
        this string is case-insensitive. This means that, for example, all of
        the following strings:
        
          "VDI"
          "vdi"
          "VdI"
        refer to the same medium format.

        This string is used in methods of other interfaces where it is necessary
        to specify a medium format, such as
        IVirtualBox::createMedium.
       """
       val = self.mgr.getService().IMediumFormat_getId(self.handle)
       return String(self.mgr, val)

   def getName(self):
       """
        Human readable description of this format.

        Mainly for use in file open dialogs.
       """
       val = self.mgr.getService().IMediumFormat_getName(self.handle)
       return String(self.mgr, val)

   def getCapabilities(self):
       """
        Capabilities of the format as an array of the flags.

        For the meaning of individual capability flags see
        ::MediumFormatCapabilities.
       """
       val = self.mgr.getService().IMediumFormat_getCapabilities(self.handle)
       return MediumFormatCapabilities(self.mgr, val, True)



   _Attrs_ = {'id':[getId,None],
              'name':[getName,None],
              'capabilities':[getCapabilities,None]}

class IDataStream(IUnknown):
   """
      The IDataStream interface is used to retrieve a data stream. It is
      returned by IMediumIO::convertToStream.
    
      Interface ID:
        {A338ED20-58D9-43AE-8B03-C1FD7088EF15}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDataStream(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDataStream._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDataStream._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def read(self, _arg_size, _arg_timeoutMS):
       """
        Read data from the stream.
        
        :param _arg_size: How many bytes to try read.
        :param _arg_timeoutMS: Timeout (in ms) for limiting the wait time for data to be available. Pass 0 for an infinite timeout.
        :return: Array of data read. This may be shorter than the specified size. Returning a zero-sized array indicates the end of the stream, if the status is successful.
        :rtype: List[octet]

        Expected result codes:
        VBOX_E_TIMEOUT
          Waiting time has expired.
        
       """
   
       req = (self.handle,)
       req += (_arg_size,)
       req += (_arg_timeoutMS,)
       val = self.mgr.getService().IDataStream_read(*req)
       
       return self.mgr.decodebase64( val)

   def getReadSize(self):
       """Recommended size of a read. Requesting a larger read may be
        possible in certain situations, but it is not guaranteed. """
       val = self.mgr.getService().IDataStream_getReadSize(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'readSize':[getReadSize,None]}

class IMediumIO(IUnknown):
   """
      The IMediumIO interface is used to access and modify the content of a
      medium.  It is returned by IMedium::openForIO.
    
      Interface ID:
        {E4B301A9-5F86-4D65-AD1B-87CA284FB1C8}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMediumIO(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMediumIO._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMediumIO._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def read(self, _arg_offset, _arg_size):
       """
        Read data from the medium.
      
        :param _arg_offset: The byte offset into the medium to start reading at.
        :param _arg_size: How many bytes to try read.
        :return: Array of data read. This may be shorter than the specified size.
        :rtype: List[octet]

       """
   
       req = (self.handle,)
       req += (_arg_offset,)
       req += (_arg_size,)
       val = self.mgr.getService().IMediumIO_read(*req)
       
       return self.mgr.decodebase64( val)

   def write(self, _arg_offset, _arg_data):
       """
        Write data to the medium.
      
        :param _arg_offset: The byte offset into the medium to start reading at.
        :param _arg_data: Array of data to write.
        :return: How many bytes were actually written.
        :rtype: unsigned long

       """
   
       req = (self.handle,)
       req += (_arg_offset,)
       req += (self.mgr.encodebase64(_arg_data),)
       val = self.mgr.getService().IMediumIO_write(*req)
       
       return UnsignedInt(self.mgr, val)

   def formatFAT(self, _arg_quick):
       """
        Formats the medium as FAT.  Generally only useful for floppy images as
        no partition table will be created.
      
        :param _arg_quick: Quick format it when set.

       """
   
       req = (self.handle,)
       req += (_arg_quick,)
       val = self.mgr.getService().IMediumIO_formatFAT(*req)
       
       return 

   def initializePartitionTable(self, _arg_format, _arg_wholeDiskInOneEntry):
       """
        Writes an empty partition table to the disk.
      
        :param _arg_format: The partition table format.
        :param _arg_wholeDiskInOneEntry: When @c true a partition table entry for the whole disk is created. Otherwise the partition table is empty.

       """
   
       req = (self.handle,)
       req += (_arg_format,)
       req += (_arg_wholeDiskInOneEntry,)
       val = self.mgr.getService().IMediumIO_initializePartitionTable(*req)
       
       return 

   def convertToStream(self, _arg_format, _arg_variant, _arg_bufferSize):
       """
        Converts the currently opened image into a stream of the specified
        image type/variant. It is sufficient to open the image in read-only
        mode. Only few types and variants are supported due to the inherent
        restrictions of the output style.
        
        :param _arg_format: Identifier of the storage format to use for output.
        :param _arg_variant: The partition table format.
        :param _arg_bufferSize: Requested buffer size (in bytes) for efficient conversion. Sizes which are too small or too large are silently truncated to suitable values. Tens to hundreds of Megabytes are a good choice.

        :return: Progress object to track the operation completion.
        :rtype: IProgress

        Expected result codes:
        VBOX_E_NOT_SUPPORTED
          The requested format/variant combination cannot handle stream output.
        VBOX_E_FILE_ERROR
          An error occurred during the conversion.
        
       """
   
       req = (self.handle,)
       req += (_arg_format,)
       req += (_arg_variant,)
       req += (_arg_bufferSize,)
       val = self.mgr.getService().IMediumIO_convertToStream(*req)
       
       return IProgress(self.mgr,val["returnval"]), IDataStream(self.mgr,val["stream"])

   def close(self):
       """
        Explictly close the medium I/O rather than waiting for garbage
        collection and the destructor.

        This will wait for any pending reads and writes to complete and then
        close down the I/O access without regard for open explorer instances or
        anything like that.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMediumIO_close(*req)
       
       return 

   def getMedium(self):
       """The open medium. """
       val = self.mgr.getService().IMediumIO_getMedium(self.handle)
       return IMedium(self.mgr, val)

   def getWritable(self):
       """Whether the medium can be written to. (It can always be read from.) """
       val = self.mgr.getService().IMediumIO_getWritable(self.handle)
       return Boolean(self.mgr, val)

   def getExplorer(self):
       """
        Returns the virtual file system explorer for the medium.

        This will attempt to recognize the format of the medium content and
        present it as a virtual directory structure to the API user.

        A FAT floppy image will be represented will a single root subdir 'fat12'
        that gives access to the file system content.

        A ISO-9660 image will have one subdir in the root for each format present
        in the image, so the API user can select which data view to access (iso9660,
        rockridge, joliet, udf, hfs, ...).

        A partitioned harddisk image will have subdirs for each partition.  The
        the filesystem content of each partition can be accessed thru the subdirs
        if we have a file system interpreter for it.  There will also be raw files
        for each subdirectory, to provide a simple way of accessing raw partition
        data from an API client.

        Please note that the explorer may show inconsistent information if
        the API user modifies the raw image content after it was opened.
       """
       val = self.mgr.getService().IMediumIO_getExplorer(self.handle)
       return IVFSExplorer(self.mgr, val)



   _Attrs_ = {'medium':[getMedium,None],
              'writable':[getWritable,None],
              'explorer':[getExplorer,None]}

class IToken(IUnknown):
   """
      The IToken interface represents a token passed to an API client, which
      triggers cleanup actions when it is explicitly released by calling the
      #abandon method (preferred, as it is accurately defined
      when the release happens), or when the object reference count drops
      to 0. The latter way is implicitly used when an API client crashes,
      however the discovery that there was a crash can take rather long,
      depending on the platform (COM needs 6 minutes). So better don't rely
      on the crash behavior too much.
    
      Interface ID:
        {20479EAF-D8ED-44CF-85AC-C83A26C95A4D}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IToken(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IToken._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IToken._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def abandon(self):
       """Releases this token. Cannot be undone in any way, and makes the
        token object unusable (even the #dummy method will return
        an error), ready for releasing. It is a more defined way than just
        letting the reference count drop to 0, because the latter (depending
        on the platform) can trigger asynchronous cleanup activity.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IToken_abandon(*req)
       
       return 

   def dummy(self):
       """Purely a NOOP. Useful when using proxy type API bindings (e.g. the
        webservice) which manage objects on behalf of the actual client, using
        an object reference expiration time based garbage collector.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IToken_dummy(*req)
       
       return 



   _Attrs_ = {}

class IKeyboard(IUnknown):
   """
      The IKeyboard interface represents the virtual machine's keyboard. Used
      in IConsole::keyboard.

      Use this interface to send keystrokes or the Ctrl-Alt-Del sequence
      to the virtual machine.
    
      Interface ID:
        {755E6BDF-1640-41F9-BD74-3EF5FD653250}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IKeyboard(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IKeyboard._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IKeyboard._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def putScancode(self, _arg_scancode):
       """Sends a scancode to the keyboard.

        
        :param _arg_scancode: 

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Could not send scan code to virtual keyboard.
        
       """
   
       req = (self.handle,)
       req += (_arg_scancode,)
       val = self.mgr.getService().IKeyboard_putScancode(*req)
       
       return 

   def putScancodes(self, _arg_scancodes):
       """Sends an array of scancodes to the keyboard.

        
        :param _arg_scancodes: 
        :return: 
        :rtype: unsigned long

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Could not send all scan codes to virtual keyboard.
        
       """
   
       req = (self.handle,)
       req += (_arg_scancodes,)
       val = self.mgr.getService().IKeyboard_putScancodes(*req)
       
       return UnsignedInt(self.mgr, val)

   def putCAD(self):
       """Sends the Ctrl-Alt-Del sequence to the keyboard. This
      function is nothing special, it is just a convenience function
      calling IKeyboard::putScancodes with the proper scancodes.

        

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Could not send all scan codes to virtual keyboard.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IKeyboard_putCAD(*req)
       
       return 

   def releaseKeys(self):
       """Causes the virtual keyboard to release any keys which are
      currently pressed. Useful when host and guest keyboard may be out
      of sync.

        

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Could not release some or all keys.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IKeyboard_releaseKeys(*req)
       
       return 

   def putUsageCode(self, _arg_usageCode, _arg_usagePage, _arg_keyRelease):
       """Sends a USB HID usage code and page to the keyboard. The
        keyRelease flag is set when the key is being released.

        
        :param _arg_usageCode: 
        :param _arg_usagePage: 
        :param _arg_keyRelease: 

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Could not send usage code to virtual keyboard.
        
       """
   
       req = (self.handle,)
       req += (_arg_usageCode,)
       req += (_arg_usagePage,)
       req += (_arg_keyRelease,)
       val = self.mgr.getService().IKeyboard_putUsageCode(*req)
       
       return 

   def getKeyboardLEDs(self):
       """
        Current status of the guest keyboard LEDs.
       """
       val = self.mgr.getService().IKeyboard_getKeyboardLEDs(self.handle)
       return KeyboardLED(self.mgr, val, True)

   def getEventSource(self):
       """
        Event source for keyboard events.
       """
       val = self.mgr.getService().IKeyboard_getEventSource(self.handle)
       return IEventSource(self.mgr, val)



   _Attrs_ = {'keyboardLEDs':[getKeyboardLEDs,None],
              'eventSource':[getEventSource,None]}

class IMousePointerShape(IUnknown):
   """
      The guest mouse pointer description.
    
      Interface ID:
        {1E775EA3-9070-4F9C-B0D5-53054496DBE0}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMousePointerShape(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMousePointerShape._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMousePointerShape._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getVisible(self):
       """
        Flag whether the pointer is visible.
       """
       val = self.mgr.getService().IMousePointerShape_getVisible(self.handle)
       return Boolean(self.mgr, val)

   def getAlpha(self):
       """
        Flag whether the pointer has an alpha channel.
       """
       val = self.mgr.getService().IMousePointerShape_getAlpha(self.handle)
       return Boolean(self.mgr, val)

   def getHotX(self):
       """
        The pointer hot spot X coordinate.
       """
       val = self.mgr.getService().IMousePointerShape_getHotX(self.handle)
       return UnsignedInt(self.mgr, val)

   def getHotY(self):
       """
        The pointer hot spot Y coordinate.
       """
       val = self.mgr.getService().IMousePointerShape_getHotY(self.handle)
       return UnsignedInt(self.mgr, val)

   def getWidth(self):
       """
        Width of the pointer shape in pixels.
       """
       val = self.mgr.getService().IMousePointerShape_getWidth(self.handle)
       return UnsignedInt(self.mgr, val)

   def getHeight(self):
       """
        Height of the pointer shape in pixels.
       """
       val = self.mgr.getService().IMousePointerShape_getHeight(self.handle)
       return UnsignedInt(self.mgr, val)

   def getShape(self):
       """
        Shape bitmaps.

        The @a shape buffer contains a 1bpp (bits per pixel) AND mask
        followed by a 32bpp XOR (color) mask.

        For pointers without alpha channel the XOR mask pixels are
        32 bit values: (lsb)BGR0(msb). For pointers with alpha channel
        the XOR mask consists of (lsb)BGRA(msb) 32 bit values.

        An AND mask is provided for pointers with alpha channel, so if the
        client does not support alpha, the pointer could be
        displayed as a normal color pointer.

        The AND mask is a 1bpp bitmap with byte aligned scanlines. The
        size of the AND mask therefore is cbAnd = (width + 7) / 8 *
          height. The padding bits at the end of each scanline are
        undefined.

        The XOR mask follows the AND mask on the next 4-byte aligned
        offset: uint8_t *pu8Xor = pu8And + (cbAnd + 3) & ~3.
        Bytes in the gap between the AND and the XOR mask are undefined.
        The XOR mask scanlines have no gap between them and the size of
        the XOR mask is: cbXor = width * 4 * height.

        
        .. note:: 
          If @a shape size is 0, then the shape is not known or did not change.
          This can happen if only the pointer visibility is changed.
         """
       val = self.mgr.getService().IMousePointerShape_getShape(self.handle)
       return self.mgr.decodebase64( val)



   _Attrs_ = {'visible':[getVisible,None],
              'alpha':[getAlpha,None],
              'hotX':[getHotX,None],
              'hotY':[getHotY,None],
              'width':[getWidth,None],
              'height':[getHeight,None],
              'shape':[getShape,None]}

class IMouse(IUnknown):
   """
      The IMouse interface represents the virtual machine's mouse. Used in
      IConsole::mouse.

      Through this interface, the virtual machine's virtual mouse can be
      controlled.
    
      Interface ID:
        {10CD08D0-E8B8-4838-B10C-45BA193734C1}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMouse(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMouse._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMouse._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def putMouseEvent(self, _arg_dx, _arg_dy, _arg_dz, _arg_dw, _arg_buttonState):
       """
        Initiates a mouse event using relative pointer movements
        along x and y axis.

        
        :param _arg_dx: Amount of pixels the mouse should move to the right. Negative values move the mouse to the left.
        :param _arg_dy: Amount of pixels the mouse should move downwards. Negative values move the mouse upwards.
        :param _arg_dz: Amount of mouse wheel moves. Positive values describe clockwise wheel rotations, negative values describe counterclockwise rotations.
        :param _arg_dw: Amount of horizontal mouse wheel moves. Positive values describe a movement to the left, negative values describe a movement to the right.
        :param _arg_buttonState: The current state of mouse buttons. Every bit represents a mouse button as follows: Bit 0 (0x01)left mouse button Bit 1 (0x02)right mouse button Bit 2 (0x04)middle mouse button A value of 1 means the corresponding button is pressed. otherwise it is released.

        Expected result codes:
        E_ACCESSDENIED
          Console not powered up.
        VBOX_E_IPRT_ERROR
          Could not send mouse event to virtual mouse.
        
       """
   
       req = (self.handle,)
       req += (_arg_dx,)
       req += (_arg_dy,)
       req += (_arg_dz,)
       req += (_arg_dw,)
       req += (_arg_buttonState,)
       val = self.mgr.getService().IMouse_putMouseEvent(*req)
       
       return 

   def putMouseEventAbsolute(self, _arg_x, _arg_y, _arg_dz, _arg_dw, _arg_buttonState):
       """
        Positions the mouse pointer using absolute x and y coordinates.
        These coordinates are expressed in pixels and
        start from [1,1] which corresponds to the top left
        corner of the virtual display.  The values [-1,-1] and
        [0x7fffffff,0x7fffffff] have special meanings as
        respectively "no data" (to signal that the host wishes to report
        absolute pointer data in future) and "out of range" (the host
        pointer is outside of all guest windows).

        
        :param _arg_x: X coordinate of the pointer in pixels, starting from @c 1.
        :param _arg_y: Y coordinate of the pointer in pixels, starting from @c 1.
        :param _arg_dz: Amount of mouse wheel moves. Positive values describe clockwise wheel rotations, negative values describe counterclockwise rotations.
        :param _arg_dw: Amount of horizontal mouse wheel moves. Positive values describe a movement to the left, negative values describe a movement to the right.
        :param _arg_buttonState: The current state of mouse buttons. Every bit represents a mouse button as follows: Bit 0 (0x01)left mouse button Bit 1 (0x02)right mouse button Bit 2 (0x04)middle mouse button A value of @c 1 means the corresponding button is pressed. otherwise it is released.

        Expected result codes:
        E_ACCESSDENIED
          Console not powered up.
        VBOX_E_IPRT_ERROR
          Could not send mouse event to virtual mouse.
        
        .. note:: 
          This method will have effect only if absolute mouse
          positioning is supported by the guest OS.
        
       """
   
       req = (self.handle,)
       req += (_arg_x,)
       req += (_arg_y,)
       req += (_arg_dz,)
       req += (_arg_dw,)
       req += (_arg_buttonState,)
       val = self.mgr.getService().IMouse_putMouseEventAbsolute(*req)
       
       return 

   def putEventMultiTouch(self, _arg_count, _arg_contacts, _arg_scanTime):
       """
        Sends a multi-touch pointer event. The coordinates are expressed in
        pixels and start from [1,1] which corresponds to the top left
        corner of the virtual display.

        
        :param _arg_count: Number of contacts in the event.
        :param _arg_contacts: Each array element contains packed information about one contact. Bits 0..15: X coordinate in pixels. Bits 16..31: Y coordinate in pixels. Bits 32..39: contact identifier. Bit 40: "in contact" flag, which indicates that there is a contact with the touch surface. Bit 41: "in range" flag, the contact is close enough to the touch surface. All other bits are reserved for future use and must be set to 0.
        :param _arg_scanTime: Timestamp of the event in milliseconds. Only relative time between events is important.

        Expected result codes:
        E_ACCESSDENIED
          Console not powered up.
        VBOX_E_IPRT_ERROR
          Could not send event to virtual device.
        
        .. note:: 
          The guest may not understand or may choose to ignore this event.
        
       """
   
       req = (self.handle,)
       req += (_arg_count,)
       req += (_arg_contacts,)
       req += (_arg_scanTime,)
       val = self.mgr.getService().IMouse_putEventMultiTouch(*req)
       
       return 

   def putEventMultiTouchString(self, _arg_count, _arg_contacts, _arg_scanTime):
       """
        :param _arg_count: 
        :param _arg_contacts: Contains information about all contacts: "id1,x1,y1,inContact1,inRange1;...;idN,xN,yN,inContactN,inRangeN". For example for two contacts: "0,10,20,1,1;1,30,40,1,1"
        :param _arg_scanTime: 

       """
   
       req = (self.handle,)
       req += (_arg_count,)
       req += (_arg_contacts,)
       req += (_arg_scanTime,)
       val = self.mgr.getService().IMouse_putEventMultiTouchString(*req)
       
       return 

   def getAbsoluteSupported(self):
       """
        Whether the guest OS supports absolute mouse pointer positioning
        or not.
        
        .. note:: 
          You can use the ::IMouseCapabilityChangedEvent
          event to be instantly informed about changes of this attribute
          during virtual machine execution.
        
        .. sealso:: #putMouseEventAbsolute """
       val = self.mgr.getService().IMouse_getAbsoluteSupported(self.handle)
       return Boolean(self.mgr, val)

   def getRelativeSupported(self):
       """
        Whether the guest OS supports relative mouse pointer positioning
        or not.
        
        .. note:: 
          You can use the ::IMouseCapabilityChangedEvent
          event to be instantly informed about changes of this attribute
          during virtual machine execution.
        
        .. sealso:: #putMouseEvent """
       val = self.mgr.getService().IMouse_getRelativeSupported(self.handle)
       return Boolean(self.mgr, val)

   def getMultiTouchSupported(self):
       """
        Whether the guest OS has enabled the multi-touch reporting device.
        
        .. note:: 
          You can use the ::IMouseCapabilityChangedEvent
          event to be instantly informed about changes of this attribute
          during virtual machine execution.
        
        .. sealso:: #putMouseEvent """
       val = self.mgr.getService().IMouse_getMultiTouchSupported(self.handle)
       return Boolean(self.mgr, val)

   def getNeedsHostCursor(self):
       """
        Whether the guest OS can currently switch to drawing it's own mouse
        cursor on demand.
        
        .. note:: 
          You can use the ::IMouseCapabilityChangedEvent
          event to be instantly informed about changes of this attribute
          during virtual machine execution.
        
        .. sealso:: #putMouseEvent """
       val = self.mgr.getService().IMouse_getNeedsHostCursor(self.handle)
       return Boolean(self.mgr, val)

   def getPointerShape(self):
       """
        The current mouse pointer used by the guest.
       """
       val = self.mgr.getService().IMouse_getPointerShape(self.handle)
       return IMousePointerShape(self.mgr, val)

   def getEventSource(self):
       """
        Event source for mouse events.
       """
       val = self.mgr.getService().IMouse_getEventSource(self.handle)
       return IEventSource(self.mgr, val)



   _Attrs_ = {'absoluteSupported':[getAbsoluteSupported,None],
              'relativeSupported':[getRelativeSupported,None],
              'multiTouchSupported':[getMultiTouchSupported,None],
              'needsHostCursor':[getNeedsHostCursor,None],
              'pointerShape':[getPointerShape,None],
              'eventSource':[getEventSource,None]}

class IFramebuffer(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IFramebuffer(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IFramebuffer._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IFramebuffer._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def notifyUpdate(self, _arg_x, _arg_y, _arg_width, _arg_height):
       """
        Informs about an update.
        Gets called by the display object where this buffer is
        registered.
      
        :param _arg_x: X position of update.
        :param _arg_y: Y position of update.
        :param _arg_width: Width of update.
        :param _arg_height: Height of update.

       """
   
       req = (self.handle,)
       req += (_arg_x,)
       req += (_arg_y,)
       req += (_arg_width,)
       req += (_arg_height,)
       val = self.mgr.getService().IFramebuffer_notifyUpdate(*req)
       
       return 

   def notifyUpdateImage(self, _arg_x, _arg_y, _arg_width, _arg_height, _arg_image):
       """
        Informs about an update and provides 32bpp bitmap.
      
        :param _arg_x: X position of update.
        :param _arg_y: Y position of update.
        :param _arg_width: Width of update.
        :param _arg_height: Height of update.
        :param _arg_image: Array with 32BPP image data.

       """
   
       req = (self.handle,)
       req += (_arg_x,)
       req += (_arg_y,)
       req += (_arg_width,)
       req += (_arg_height,)
       req += (self.mgr.encodebase64(_arg_image),)
       val = self.mgr.getService().IFramebuffer_notifyUpdateImage(*req)
       
       return 

   def notifyChange(self, _arg_screenId, _arg_xOrigin, _arg_yOrigin, _arg_width, _arg_height):
       """
        Requests a size change.
      
        :param _arg_screenId: Logical guest screen number.
        :param _arg_xOrigin: Location of the screen in the guest.
        :param _arg_yOrigin: Location of the screen in the guest.
        :param _arg_width: Width of the guest display, in pixels.
        :param _arg_height: Height of the guest display, in pixels.

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_xOrigin,)
       req += (_arg_yOrigin,)
       req += (_arg_width,)
       req += (_arg_height,)
       val = self.mgr.getService().IFramebuffer_notifyChange(*req)
       
       return 

   def videoModeSupported(self, _arg_width, _arg_height, _arg_bpp):
       """
        Returns whether the frame buffer implementation is willing to
        support a given video mode. In case it is not able to render
        the video mode (or for some reason not willing), it should
        return @c false. Usually this method is called when the guest
        asks the VMM device whether a given video mode is supported
        so the information returned is directly exposed to the guest.
        It is important that this method returns very quickly.
      
        :param _arg_width: 
        :param _arg_height: 
        :param _arg_bpp: 
        :return: 
        :rtype: boolean

       """
   
       req = (self.handle,)
       req += (_arg_width,)
       req += (_arg_height,)
       req += (_arg_bpp,)
       val = self.mgr.getService().IFramebuffer_videoModeSupported(*req)
       
       return Boolean(self.mgr, val)

   def getVisibleRegion(self, _arg_rectangles, _arg_count):
       """
        Returns the visible region of this frame buffer.

        If the @a rectangles parameter is @c null then the value of the
        @a count parameter is ignored and the number of elements necessary to
        describe the current visible region is returned in @a countCopied.

        If @a rectangles is not @c null but @a count is less
        than the required number of elements to store region data, the method
        will report a failure. If @a count is equal or greater than the
        required number of elements, then the actual number of elements copied
        to the provided array will be returned in @a countCopied.

        
        :param _arg_rectangles: Pointer to the @c RTRECT array to receive region data.
        :param _arg_count: Number of @c RTRECT elements in the @a rectangles array.
        :return: Number of elements copied to the @a rectangles array.
        :rtype: unsigned long

        .. note:: 
          The address of the provided array must be in the process space of
          this IFramebuffer object.
        
        .. note:: 
          Method not yet implemented.
        
@warning This method is non-scriptable. In particular, this also means that an
attempt to call it from a process other than the process that has created and
owns the object will most likely fail or crash your application.

       """
   
       req = (self.handle,)
       req += (_arg_rectangles,)
       req += (_arg_count,)
       val = self.mgr.getService().IFramebuffer_getVisibleRegion(*req)
       
       return UnsignedInt(self.mgr, val)

   def setVisibleRegion(self, _arg_rectangles, _arg_count):
       """
        Suggests a new visible region to this frame buffer. This region
        represents the area of the VM display which is a union of regions of
        all top-level windows of the guest operating system running inside the
        VM (if the Guest Additions for this system support this
        functionality). This information may be used by the frontends to
        implement the seamless desktop integration feature.

        
        :param _arg_rectangles: Pointer to the @c RTRECT array.
        :param _arg_count: Number of @c RTRECT elements in the @a rectangles array.

        .. note:: 
          The address of the provided array must be in the process space of
          this IFramebuffer object.
        
        .. note:: 
          The IFramebuffer implementation must make a copy of the provided
          array of rectangles.
        
        .. note:: 
          Method not yet implemented.
        
@warning This method is non-scriptable. In particular, this also means that an
attempt to call it from a process other than the process that has created and
owns the object will most likely fail or crash your application.

       """
   
       req = (self.handle,)
       req += (_arg_rectangles,)
       req += (_arg_count,)
       val = self.mgr.getService().IFramebuffer_setVisibleRegion(*req)
       
       return 

   def processVHWACommand(self, _arg_command, _arg_enmCmd, _arg_fromGuest):
       """
        Posts a Video HW Acceleration Command to the frame buffer for processing.
        The commands used for 2D video acceleration (DDraw surface creation/destroying, blitting, scaling, color conversion, overlaying, etc.)
        are posted from quest to the host to be processed by the host hardware.

        
        :param _arg_command: Pointer to VBOXVHWACMD containing the command to execute.
        :param _arg_enmCmd: The validated VBOXVHWACMD::enmCmd value from the command.
        :param _arg_fromGuest: Set when the command origins from the guest, clear if host.

        .. note:: 
          The address of the provided command must be in the process space of
          this IFramebuffer object.
        
@warning This method is non-scriptable. In particular, this also means that an
attempt to call it from a process other than the process that has created and
owns the object will most likely fail or crash your application.

       """
   
       req = (self.handle,)
       req += (_arg_command,)
       req += (_arg_enmCmd,)
       req += (_arg_fromGuest,)
       val = self.mgr.getService().IFramebuffer_processVHWACommand(*req)
       
       return 

   def notify3DEvent(self, _arg_type, _arg_data):
       """
        Notifies framebuffer about 3D backend event.
      
        :param _arg_type: event type. Currently only VBOX3D_NOTIFY_EVENT_TYPE_VISIBLE_3DDATA is supported.
        :param _arg_data: event-specific data, depends on the supplied event type

       """
   
       req = (self.handle,)
       req += (_arg_type,)
       req += (self.mgr.encodebase64(_arg_data),)
       val = self.mgr.getService().IFramebuffer_notify3DEvent(*req)
       
       return 

   def getWidth(self):
       """Frame buffer width, in pixels. """
       val = self.mgr.getService().IFramebuffer_getWidth(self.handle)
       return UnsignedInt(self.mgr, val)

   def getHeight(self):
       """Frame buffer height, in pixels. """
       val = self.mgr.getService().IFramebuffer_getHeight(self.handle)
       return UnsignedInt(self.mgr, val)

   def getBitsPerPixel(self):
       """
        Color depth, in bits per pixel.
       """
       val = self.mgr.getService().IFramebuffer_getBitsPerPixel(self.handle)
       return UnsignedInt(self.mgr, val)

   def getBytesPerLine(self):
       """
        Scan line size, in bytes.
       """
       val = self.mgr.getService().IFramebuffer_getBytesPerLine(self.handle)
       return UnsignedInt(self.mgr, val)

   def getPixelFormat(self):
       """
        Frame buffer pixel format. It's one of the values defined by ::BitmapFormat.
        
        .. note:: 
          This attribute must never (and will never) return ::BitmapFormat_Opaque -- the format of the frame
          buffer must be always known.
         """
       val = self.mgr.getService().IFramebuffer_getPixelFormat(self.handle)
       return BitmapFormat(self.mgr, val)

   def getHeightReduction(self):
       """
        Hint from the frame buffer about how much of the standard
        screen height it wants to use for itself. This information is
        exposed to the guest through the VESA BIOS and VMMDev interface
        so that it can use it for determining its video mode table. It
        is not guaranteed that the guest respects the value.
       """
       val = self.mgr.getService().IFramebuffer_getHeightReduction(self.handle)
       return UnsignedInt(self.mgr, val)

   def getOverlay(self):
       """
        An alpha-blended overlay which is superposed over the frame buffer.
        The initial purpose is to allow the display of icons providing
        information about the VM state, including disk activity, in front
        ends which do not have other means of doing that. The overlay is
        designed to controlled exclusively by IDisplay. It has no locking
        of its own, and any changes made to it are not guaranteed to be
        visible until the affected portion of IFramebuffer is updated. The
        overlay can be created lazily the first time it is requested. This
        attribute can also return @c null to signal that the overlay is not
        implemented.
       """
       val = self.mgr.getService().IFramebuffer_getOverlay(self.handle)
       return IFramebufferOverlay(self.mgr, val)

   def getWinId(self):
       """
        Platform-dependent identifier of the window where context of this
        frame buffer is drawn, or zero if there's no such window.
       """
       val = self.mgr.getService().IFramebuffer_getWinId(self.handle)
       return Long(self.mgr, val)

   def getCapabilities(self):
       """
        Capabilities of the framebuffer instance.

        For the meaning of individual capability flags see
        ::FramebufferCapabilities.
       """
       val = self.mgr.getService().IFramebuffer_getCapabilities(self.handle)
       return FramebufferCapabilities(self.mgr, val, True)



   _Attrs_ = {'width':[getWidth,None],
              'height':[getHeight,None],
              'bitsPerPixel':[getBitsPerPixel,None],
              'bytesPerLine':[getBytesPerLine,None],
              'pixelFormat':[getPixelFormat,None],
              'heightReduction':[getHeightReduction,None],
              'overlay':[getOverlay,None],
              'winId':[getWinId,None],
              'capabilities':[getCapabilities,None]}

class IFramebufferOverlay(IFramebuffer):
   """
      The IFramebufferOverlay interface represents an alpha blended overlay
      for displaying status icons above an IFramebuffer. It is always created
      not visible, so that it must be explicitly shown. It only covers a
      portion of the IFramebuffer, determined by its width, height and
      co-ordinates. It is always in packed pixel little-endian 32bit ARGB (in
      that order) format, and may be written to directly. Do re-read the
      width though, after setting it, as it may be adjusted (increased) to
      make it more suitable for the front end.
    
      Interface ID:
        {AF398A9A-6B76-4805-8FAB-00A9DCF4732B}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IFramebufferOverlay(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IFramebufferOverlay._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IFramebuffer.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IFramebufferOverlay._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def move(self, _arg_x, _arg_y):
       """
        Changes the overlay's position relative to the IFramebuffer.
      
        :param _arg_x: 
        :param _arg_y: 

       """
   
       req = (self.handle,)
       req += (_arg_x,)
       req += (_arg_y,)
       val = self.mgr.getService().IFramebufferOverlay_move(*req)
       
       return 

   def getX(self):
       """X position of the overlay, relative to the frame buffer. """
       val = self.mgr.getService().IFramebufferOverlay_getX(self.handle)
       return UnsignedInt(self.mgr, val)

   def getY(self):
       """Y position of the overlay, relative to the frame buffer. """
       val = self.mgr.getService().IFramebufferOverlay_getY(self.handle)
       return UnsignedInt(self.mgr, val)

   def getVisible(self):
       """
        Whether the overlay is currently visible.
       """
       val = self.mgr.getService().IFramebufferOverlay_getVisible(self.handle)
       return Boolean(self.mgr, val)

   def setVisible(self, value):
       """
        Whether the overlay is currently visible.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IFramebufferOverlay_setVisible(_this, _val)

   def getAlpha(self):
       """
        The global alpha value for the overlay. This may or may not be
        supported by a given front end.
       """
       val = self.mgr.getService().IFramebufferOverlay_getAlpha(self.handle)
       return UnsignedInt(self.mgr, val)

   def setAlpha(self, value):
       """
        The global alpha value for the overlay. This may or may not be
        supported by a given front end.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IFramebufferOverlay_setAlpha(_this, _val)



   _Attrs_ = {'x':[getX,None],
              'y':[getY,None],
              'visible':[getVisible,setVisible,],
              'alpha':[getAlpha,setAlpha,]}

class IGuestScreenInfo(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestScreenInfo(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestScreenInfo._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestScreenInfo._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getScreenId(self):
       """ """
       val = self.mgr.getService().IGuestScreenInfo_getScreenId(self.handle)
       return UnsignedInt(self.mgr, val)

   def getGuestMonitorStatus(self):
       """ """
       val = self.mgr.getService().IGuestScreenInfo_getGuestMonitorStatus(self.handle)
       return GuestMonitorStatus(self.mgr, val)

   def getPrimary(self):
       """ """
       val = self.mgr.getService().IGuestScreenInfo_getPrimary(self.handle)
       return Boolean(self.mgr, val)

   def getOrigin(self):
       """ """
       val = self.mgr.getService().IGuestScreenInfo_getOrigin(self.handle)
       return Boolean(self.mgr, val)

   def getOriginX(self):
       """ """
       val = self.mgr.getService().IGuestScreenInfo_getOriginX(self.handle)
       return Int(self.mgr, val)

   def getOriginY(self):
       """ """
       val = self.mgr.getService().IGuestScreenInfo_getOriginY(self.handle)
       return Int(self.mgr, val)

   def getWidth(self):
       """ """
       val = self.mgr.getService().IGuestScreenInfo_getWidth(self.handle)
       return UnsignedInt(self.mgr, val)

   def getHeight(self):
       """ """
       val = self.mgr.getService().IGuestScreenInfo_getHeight(self.handle)
       return UnsignedInt(self.mgr, val)

   def getBitsPerPixel(self):
       """ """
       val = self.mgr.getService().IGuestScreenInfo_getBitsPerPixel(self.handle)
       return UnsignedInt(self.mgr, val)

   def getExtendedInfo(self):
       """ """
       val = self.mgr.getService().IGuestScreenInfo_getExtendedInfo(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'screenId':[getScreenId,None],
              'guestMonitorStatus':[getGuestMonitorStatus,None],
              'primary':[getPrimary,None],
              'origin':[getOrigin,None],
              'originX':[getOriginX,None],
              'originY':[getOriginY,None],
              'width':[getWidth,None],
              'height':[getHeight,None],
              'bitsPerPixel':[getBitsPerPixel,None],
              'extendedInfo':[getExtendedInfo,None]}

class IDisplay(IUnknown):
   """
      The IDisplay interface represents the virtual machine's display.

      The object implementing this interface is contained in each
      IConsole::display attribute and represents the visual
      output of the virtual machine.

      The virtual display supports pluggable output targets represented by the
      IFramebuffer interface. Examples of the output target are a window on
      the host computer or an RDP session's display on a remote computer.
    
      Interface ID:
        {4680B2DE-8690-11E9-B83D-5719E53CF1DE}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDisplay(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDisplay._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDisplay._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getScreenResolution(self, _arg_screenId):
       """
        Queries certain attributes such as display width, height, color depth
        and the X and Y origin for a given guest screen.

        The parameters @a xOrigin and @a yOrigin return the X and Y
        coordinates of the framebuffer's origin.

        All return parameters are optional.
        :param _arg_screenId: 







       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       val = self.mgr.getService().IDisplay_getScreenResolution(*req)
       
       return UnsignedInt(self.mgr,val["width"]), UnsignedInt(self.mgr,val["height"]), UnsignedInt(self.mgr,val["bitsPerPixel"]), Int(self.mgr,val["xOrigin"]), Int(self.mgr,val["yOrigin"]), GuestMonitorStatus(self.mgr,val["guestMonitorStatus"])

   def attachFramebuffer(self, _arg_screenId, _arg_framebuffer):
       """
        Sets the graphics update target for a screen.
      
        :param _arg_screenId: 
        :param _arg_framebuffer: 
        :return: 
        :rtype: uuid

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_framebuffer,)
       val = self.mgr.getService().IDisplay_attachFramebuffer(*req)
       
       return String(self.mgr, val)

   def detachFramebuffer(self, _arg_screenId, _arg_id):
       """
        Removes the graphics updates target for a screen.
      
        :param _arg_screenId: 
        :param _arg_id: 

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_id,)
       val = self.mgr.getService().IDisplay_detachFramebuffer(*req)
       
       return 

   def queryFramebuffer(self, _arg_screenId):
       """
        Queries the graphics updates targets for a screen.
      
        :param _arg_screenId: 
        :return: 
        :rtype: IFramebuffer

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       val = self.mgr.getService().IDisplay_queryFramebuffer(*req)
       
       return IFramebuffer(self.mgr, val)

   def setVideoModeHint(self, _arg_display, _arg_enabled, _arg_changeOrigin, _arg_originX, _arg_originY, _arg_width, _arg_height, _arg_bitsPerPixel, _arg_notify):
       """
        Changes the monitor information reported by a given output of the guest
        graphics device.  This information can be read by the guest if suitable
        drivers and driver tools are available, including but not limited to
        those in the Guest Additions.  The guest will receive monitor hotplug
        notification when the monitor information is changed, and the
        information itself will be available to the guest until the next change.
        The information should not be resent if the guest does not resize in
        response.  The guest might have chosen to ignore the change, or the
        resize might happen later when a suitable driver is started.

        Specifying @c 0 for either @a width, @a height or @a bitsPerPixel
        parameters means that the corresponding values should be taken from the
        current video mode (i.e. left unchanged).

        @todo Rename this to @a setMonitorInfo for 7.0.

        
        :param _arg_display: The number of the guest output to change.
        :param _arg_enabled: @c True if a monitor is connected, @c False otherwise. For historical reasons the Windows drivers can and do override this setting. Call this a virtual hardware quirk.
        :param _arg_changeOrigin: @c True, if the position of the guest screen is specified, @c False otherwise.
        :param _arg_originX: The X origin of the guest screen.
        :param _arg_originY: The Y origin of the guest screen.
        :param _arg_width: The width of the guest screen.
        :param _arg_height: The height of the guest screen.
        :param _arg_bitsPerPixel: The number of bits per pixel of the guest screen.
        :param _arg_notify: Whether the guest should be notified of the change. Normally this is wished, but it might not be when re-setting monitor information from the last session (no hotplug happened, as it is still the same virtual monitor). Might also be useful if several monitors are to be changed at once, but this would not reflect physical hardware well, and we also have @a setScreenLayout for that.

        Expected result codes:
        E_INVALIDARG
          The @a display value is higher then the number of outputs.
        
       """
   
       req = (self.handle,)
       req += (_arg_display,)
       req += (_arg_enabled,)
       req += (_arg_changeOrigin,)
       req += (_arg_originX,)
       req += (_arg_originY,)
       req += (_arg_width,)
       req += (_arg_height,)
       req += (_arg_bitsPerPixel,)
       req += (_arg_notify,)
       val = self.mgr.getService().IDisplay_setVideoModeHint(*req)
       
       return 

   def getVideoModeHint(self, _arg_display):
       """
        Queries the monitor information for a given guest output.  See
        @a setVideoModeHint.  If no monitor information has been set yet by a
        front-end the preferred mode values returned will be zero.

        @todo Rename this to @a getMonitorInfo for 7.0.

        
        :param _arg_display: The number of the guest output to query.








        Expected result codes:
        E_INVALIDARG
          The @a display value is higher than the number of outputs.
        
       """
   
       req = (self.handle,)
       req += (_arg_display,)
       val = self.mgr.getService().IDisplay_getVideoModeHint(*req)
       
       return Boolean(self.mgr,val["enabled"]), Boolean(self.mgr,val["changeOrigin"]), Int(self.mgr,val["originX"]), Int(self.mgr,val["originY"]), UnsignedInt(self.mgr,val["width"]), UnsignedInt(self.mgr,val["height"]), UnsignedInt(self.mgr,val["bitsPerPixel"])

   def setSeamlessMode(self, _arg_enabled):
       """
        Enables or disables seamless guest display rendering (seamless desktop
        integration) mode.
        
        :param _arg_enabled: 

        .. note:: 
          Calling this method has no effect if IGuest::getFacilityStatus with facility @c Seamless
          does not return @c Active.
        
       """
   
       req = (self.handle,)
       req += (_arg_enabled,)
       val = self.mgr.getService().IDisplay_setSeamlessMode(*req)
       
       return 

   def takeScreenShot(self, _arg_screenId, _arg_address, _arg_width, _arg_height, _arg_bitmapFormat):
       """
        Takes a screen shot of the requested size and format and copies it to the
        buffer allocated by the caller and pointed to by @a address.
        The buffer size must be enough for a 32 bits per pixel bitmap,
        i.e. width * height * 4 bytes.

        
        :param _arg_screenId: 
        :param _arg_address: 
        :param _arg_width: 
        :param _arg_height: 
        :param _arg_bitmapFormat: 

        .. note:: This API can be used only locally by a VM process through the
            COM/XPCOM C++ API as it requires pointer support. It is not
            available for scripting languages, Java or any webservice clients.
            Unless you are writing a new VM frontend use
            #takeScreenShotToArray.
        
@warning This method is non-scriptable. In particular, this also means that an
attempt to call it from a process other than the process that has created and
owns the object will most likely fail or crash your application.

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_address,)
       req += (_arg_width,)
       req += (_arg_height,)
       req += (_arg_bitmapFormat,)
       val = self.mgr.getService().IDisplay_takeScreenShot(*req)
       
       return 

   def takeScreenShotToArray(self, _arg_screenId, _arg_width, _arg_height, _arg_bitmapFormat):
       """
        Takes a guest screen shot of the requested size and format
        and returns it as an array of bytes.
      
        :param _arg_screenId: The guest monitor to take screenshot from.
        :param _arg_width: Desired image width.
        :param _arg_height: Desired image height.
        :param _arg_bitmapFormat: The requested format.
        :return: Array with resulting screen data.
        :rtype: List[octet]

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_width,)
       req += (_arg_height,)
       req += (_arg_bitmapFormat,)
       val = self.mgr.getService().IDisplay_takeScreenShotToArray(*req)
       
       return self.mgr.decodebase64( val)

   def drawToScreen(self, _arg_screenId, _arg_address, _arg_x, _arg_y, _arg_width, _arg_height):
       """
        Draws a 32-bpp image of the specified size from the given buffer
        to the given point on the VM display.

        
        :param _arg_screenId: Monitor to take the screenshot from.
        :param _arg_address: Address to store the screenshot to
        :param _arg_x: Relative to the screen top left corner.
        :param _arg_y: Relative to the screen top left corner.
        :param _arg_width: Desired image width.
        :param _arg_height: Desired image height.

        Expected result codes:
        E_NOTIMPL
          Feature not implemented.
        VBOX_E_IPRT_ERROR
          Could not draw to screen.
        
@warning This method is non-scriptable. In particular, this also means that an
attempt to call it from a process other than the process that has created and
owns the object will most likely fail or crash your application.

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_address,)
       req += (_arg_x,)
       req += (_arg_y,)
       req += (_arg_width,)
       req += (_arg_height,)
       val = self.mgr.getService().IDisplay_drawToScreen(*req)
       
       return 

   def invalidateAndUpdate(self):
       """
        Does a full invalidation of the VM display and instructs the VM
        to update it.

        

        Expected result codes:
        VBOX_E_IPRT_ERROR
          Could not invalidate and update screen.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().IDisplay_invalidateAndUpdate(*req)
       
       return 

   def invalidateAndUpdateScreen(self, _arg_screenId):
       """
        Redraw the specified VM screen.
      
        :param _arg_screenId: The guest screen to redraw.

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       val = self.mgr.getService().IDisplay_invalidateAndUpdateScreen(*req)
       
       return 

   def completeVHWACommand(self, _arg_command):
       """
        Signals that the Video HW Acceleration command has completed.
      
        :param _arg_command: Pointer to VBOXVHWACMD containing the completed command.

@warning This method is non-scriptable. In particular, this also means that an
attempt to call it from a process other than the process that has created and
owns the object will most likely fail or crash your application.

       """
   
       req = (self.handle,)
       req += (_arg_command,)
       val = self.mgr.getService().IDisplay_completeVHWACommand(*req)
       
       return 

   def viewportChanged(self, _arg_screenId, _arg_x, _arg_y, _arg_width, _arg_height):
       """
        Signals that framebuffer window viewport has changed.

      
        :param _arg_screenId: Monitor to take the screenshot from.
        :param _arg_x: Framebuffer x offset.
        :param _arg_y: Framebuffer y offset.
        :param _arg_width: Viewport width.
        :param _arg_height: Viewport height.

        Expected result codes:
        E_INVALIDARG
        The specified viewport data is invalid.
      
       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_x,)
       req += (_arg_y,)
       req += (_arg_width,)
       req += (_arg_height,)
       val = self.mgr.getService().IDisplay_viewportChanged(*req)
       
       return 

   def querySourceBitmap(self, _arg_screenId):
       """
        Obtains the guest screen bitmap parameters.
      
        :param _arg_screenId: 


       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       val = self.mgr.getService().IDisplay_querySourceBitmap(*req)
       
       return IDisplaySourceBitmap(self.mgr,val["displaySourceBitmap"])

   def notifyScaleFactorChange(self, _arg_screenId, _arg_u32ScaleFactorWMultiplied, _arg_u32ScaleFactorHMultiplied):
       """
        Notify OpenGL HGCM host service about graphics content scaling factor change.
      
        :param _arg_screenId: 
        :param _arg_u32ScaleFactorWMultiplied: 
        :param _arg_u32ScaleFactorHMultiplied: 

       """
   
       req = (self.handle,)
       req += (_arg_screenId,)
       req += (_arg_u32ScaleFactorWMultiplied,)
       req += (_arg_u32ScaleFactorHMultiplied,)
       val = self.mgr.getService().IDisplay_notifyScaleFactorChange(*req)
       
       return 

   def notifyHiDPIOutputPolicyChange(self, _arg_fUnscaledHiDPI):
       """
        Notify OpenGL HGCM host service about HiDPI monitor scaling policy change.
      
        :param _arg_fUnscaledHiDPI: 

       """
   
       req = (self.handle,)
       req += (_arg_fUnscaledHiDPI,)
       val = self.mgr.getService().IDisplay_notifyHiDPIOutputPolicyChange(*req)
       
       return 

   def setScreenLayout(self, _arg_screenLayoutMode, _arg_guestScreenInfo):
       """
        Set video modes for the guest screens.
      
        :param _arg_screenLayoutMode: 
        :param _arg_guestScreenInfo: 

       """
   
       req = (self.handle,)
       req += (_arg_screenLayoutMode,)
       req += (_arg_guestScreenInfo,)
       val = self.mgr.getService().IDisplay_setScreenLayout(*req)
       
       return 

   def detachScreens(self, _arg_screenIds):
       """
        Unplugs monitors from the virtual graphics card.
      
        :param _arg_screenIds: 

       """
   
       req = (self.handle,)
       req += (_arg_screenIds,)
       val = self.mgr.getService().IDisplay_detachScreens(*req)
       
       return 

   def createGuestScreenInfo(self, _arg_display, _arg_status, _arg_primary, _arg_changeOrigin, _arg_originX, _arg_originY, _arg_width, _arg_height, _arg_bitsPerPixel):
       """
        Make a IGuestScreenInfo object with the provided parameters.
      
        :param _arg_display: The number of the guest display.
        :param _arg_status: @c True, if this guest screen is enabled, @c False otherwise.
        :param _arg_primary: Whether this guest monitor must be primary.
        :param _arg_changeOrigin: @c True, if the origin of the guest screen should be changed, @c False otherwise.
        :param _arg_originX: The X origin of the guest screen.
        :param _arg_originY: The Y origin of the guest screen.
        :param _arg_width: The width of the guest screen.
        :param _arg_height: The height of the guest screen.
        :param _arg_bitsPerPixel: The number of bits per pixel of the guest screen.
        :return: The created object.
        :rtype: IGuestScreenInfo

       """
   
       req = (self.handle,)
       req += (_arg_display,)
       req += (_arg_status,)
       req += (_arg_primary,)
       req += (_arg_changeOrigin,)
       req += (_arg_originX,)
       req += (_arg_originY,)
       req += (_arg_width,)
       req += (_arg_height,)
       req += (_arg_bitsPerPixel,)
       val = self.mgr.getService().IDisplay_createGuestScreenInfo(*req)
       
       return IGuestScreenInfo(self.mgr, val)

   def getGuestScreenLayout(self):
       """
        Layout of the guest screens.
       """
       val = self.mgr.getService().IDisplay_getGuestScreenLayout(self.handle)
       return IGuestScreenInfo(self.mgr, val, True)



   _Attrs_ = {'guestScreenLayout':[getGuestScreenLayout,None]}

class INetworkAdapter(IUnknown):
   """
        Represents a virtual network adapter that is attached to a virtual machine.
        Each virtual machine has a fixed number of network adapter slots with one
        instance of this attached to each of them. Call
        IMachine::getNetworkAdapter to get the network adapter that
        is attached to a given slot in a given machine.

        Each network adapter can be in one of five attachment modes, which are
        represented by the ::NetworkAttachmentType enumeration;
        see the #attachmentType attribute.
    
      Interface ID:
        {E9A0C183-7071-4894-93D6-DCBEC010FA91}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INetworkAdapter(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INetworkAdapter._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INetworkAdapter._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getProperty(self, _arg_key):
       """
        Returns the value of the network attachment property with the given name.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

        
        :param _arg_key: Name of the property to get.
        :return: Current property value.
        :rtype: wstring

        Expected result codes:
        E_INVALIDARG@a name is @c null or empty.
       """
   
       req = (self.handle,)
       req += (_arg_key,)
       val = self.mgr.getService().INetworkAdapter_getProperty(*req)
       
       return String(self.mgr, val)

   def setProperty(self, _arg_key, _arg_value):
       """
        Sets the value of the network attachment property with the given name.

        Setting the property value to @c null or an empty string is equivalent
        to deleting the existing value.

        
        :param _arg_key: Name of the property to set.
        :param _arg_value: Property value to set.

        Expected result codes:
        E_INVALIDARG@a name is @c null or empty.
       """
   
       req = (self.handle,)
       req += (_arg_key,)
       req += (_arg_value,)
       val = self.mgr.getService().INetworkAdapter_setProperty(*req)
       
       return 

   def getProperties(self, _arg_names):
       """
        Returns values for a group of properties in one call.

        The names of the properties to get are specified using the @a names
        argument which is a list of comma-separated property names or
        an empty string if all properties are to be returned.
        

        The method returns two arrays, the array of property names corresponding
        to the @a names argument and the current values of these properties.
        Both arrays have the same number of elements with each element at the
        given index in the first array corresponds to an element at the same
        index in the second array.
      
        :param _arg_names: Names of properties to get.

        :return: Values of returned properties.
        :rtype: List[wstring]

        .. note:: Currently the value of this argument is ignored and the method
        always returns all existing properties.
       """
   
       req = (self.handle,)
       req += (_arg_names,)
       val = self.mgr.getService().INetworkAdapter_getProperties(*req)
       
       return String(self.mgr,val["returnval"], True), String(self.mgr,val["returnNames"], True)

   def getAdapterType(self):
       """
        Type of the virtual network adapter. Depending on this value,
        VirtualBox will provide a different virtual network hardware
        to the guest.
       """
       val = self.mgr.getService().INetworkAdapter_getAdapterType(self.handle)
       return NetworkAdapterType(self.mgr, val)

   def setAdapterType(self, value):
       """
        Type of the virtual network adapter. Depending on this value,
        VirtualBox will provide a different virtual network hardware
        to the guest.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setAdapterType(_this, _val)

   def getSlot(self):
       """
        Slot number this adapter is plugged into. Corresponds to
        the value you pass to IMachine::getNetworkAdapter
        to obtain this instance.
       """
       val = self.mgr.getService().INetworkAdapter_getSlot(self.handle)
       return UnsignedInt(self.mgr, val)

   def getEnabled(self):
       """
        Flag whether the network adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain this network adapter. Can only be changed when
        the VM is not running.
       """
       val = self.mgr.getService().INetworkAdapter_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEnabled(self, value):
       """
        Flag whether the network adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain this network adapter. Can only be changed when
        the VM is not running.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setEnabled(_this, _val)

   def getMACAddress(self):
       """
        Ethernet MAC address of the adapter, 12 hexadecimal characters. When
        setting it to @c null or an empty string for an enabled adapter,
        VirtualBox will generate a unique MAC address. Disabled adapters can
        have an empty MAC address.
       """
       val = self.mgr.getService().INetworkAdapter_getMACAddress(self.handle)
       return String(self.mgr, val)

   def setMACAddress(self, value):
       """
        Ethernet MAC address of the adapter, 12 hexadecimal characters. When
        setting it to @c null or an empty string for an enabled adapter,
        VirtualBox will generate a unique MAC address. Disabled adapters can
        have an empty MAC address.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setMACAddress(_this, _val)

   def getAttachmentType(self):
       """
        Sets/Gets network attachment type of this network adapter.
       """
       val = self.mgr.getService().INetworkAdapter_getAttachmentType(self.handle)
       return NetworkAttachmentType(self.mgr, val)

   def setAttachmentType(self, value):
       """
        Sets/Gets network attachment type of this network adapter.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setAttachmentType(_this, _val)

   def getBridgedInterface(self):
       """
        Name of the network interface the VM should be bridged to.
       """
       val = self.mgr.getService().INetworkAdapter_getBridgedInterface(self.handle)
       return String(self.mgr, val)

   def setBridgedInterface(self, value):
       """
        Name of the network interface the VM should be bridged to.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setBridgedInterface(_this, _val)

   def getHostOnlyInterface(self):
       """
        Name of the host only network interface the VM is attached to.
       """
       val = self.mgr.getService().INetworkAdapter_getHostOnlyInterface(self.handle)
       return String(self.mgr, val)

   def setHostOnlyInterface(self, value):
       """
        Name of the host only network interface the VM is attached to.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setHostOnlyInterface(_this, _val)

   def getInternalNetwork(self):
       """
        Name of the internal network the VM is attached to.
       """
       val = self.mgr.getService().INetworkAdapter_getInternalNetwork(self.handle)
       return String(self.mgr, val)

   def setInternalNetwork(self, value):
       """
        Name of the internal network the VM is attached to.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setInternalNetwork(_this, _val)

   def getNATNetwork(self):
       """
        Name of the NAT network the VM is attached to.
       """
       val = self.mgr.getService().INetworkAdapter_getNATNetwork(self.handle)
       return String(self.mgr, val)

   def setNATNetwork(self, value):
       """
        Name of the NAT network the VM is attached to.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setNATNetwork(_this, _val)

   def getGenericDriver(self):
       """
        Name of the driver to use for the "Generic" network attachment type.
       """
       val = self.mgr.getService().INetworkAdapter_getGenericDriver(self.handle)
       return String(self.mgr, val)

   def setGenericDriver(self, value):
       """
        Name of the driver to use for the "Generic" network attachment type.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setGenericDriver(_this, _val)

   def getCloudNetwork(self):
       """
        Name of the cloud network the VM is attached to.
       """
       val = self.mgr.getService().INetworkAdapter_getCloudNetwork(self.handle)
       return String(self.mgr, val)

   def setCloudNetwork(self, value):
       """
        Name of the cloud network the VM is attached to.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setCloudNetwork(_this, _val)

   def getCableConnected(self):
       """
        Flag whether the adapter reports the cable as connected or not.
        It can be used to report offline situations to a VM.
       """
       val = self.mgr.getService().INetworkAdapter_getCableConnected(self.handle)
       return Boolean(self.mgr, val)

   def setCableConnected(self, value):
       """
        Flag whether the adapter reports the cable as connected or not.
        It can be used to report offline situations to a VM.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setCableConnected(_this, _val)

   def getLineSpeed(self):
       """
        Line speed reported by custom drivers, in units of 1 kbps.
       """
       val = self.mgr.getService().INetworkAdapter_getLineSpeed(self.handle)
       return UnsignedInt(self.mgr, val)

   def setLineSpeed(self, value):
       """
        Line speed reported by custom drivers, in units of 1 kbps.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setLineSpeed(_this, _val)

   def getPromiscModePolicy(self):
       """
        The promiscuous mode policy of the network adapter when attached to an
        internal network, host only network or a bridge.
       """
       val = self.mgr.getService().INetworkAdapter_getPromiscModePolicy(self.handle)
       return NetworkAdapterPromiscModePolicy(self.mgr, val)

   def setPromiscModePolicy(self, value):
       """
        The promiscuous mode policy of the network adapter when attached to an
        internal network, host only network or a bridge.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setPromiscModePolicy(_this, _val)

   def getTraceEnabled(self):
       """
        Flag whether network traffic from/to the network card should be traced.
        Can only be toggled when the VM is turned off.
       """
       val = self.mgr.getService().INetworkAdapter_getTraceEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setTraceEnabled(self, value):
       """
        Flag whether network traffic from/to the network card should be traced.
        Can only be toggled when the VM is turned off.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setTraceEnabled(_this, _val)

   def getTraceFile(self):
       """
        Filename where a network trace will be stored. If not set, VBox-pid.pcap
        will be used.
       """
       val = self.mgr.getService().INetworkAdapter_getTraceFile(self.handle)
       return String(self.mgr, val)

   def setTraceFile(self, value):
       """
        Filename where a network trace will be stored. If not set, VBox-pid.pcap
        will be used.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setTraceFile(_this, _val)

   def getNATEngine(self):
       """
        Points to the NAT engine which handles the network address translation
        for this interface. This is active only when the interface actually uses
        NAT.
       """
       val = self.mgr.getService().INetworkAdapter_getNATEngine(self.handle)
       return INATEngine(self.mgr, val)

   def getBootPriority(self):
       """
        Network boot priority of the adapter. Priority 1 is highest. If not set,
        the priority is considered to be at the lowest possible setting.
       """
       val = self.mgr.getService().INetworkAdapter_getBootPriority(self.handle)
       return UnsignedInt(self.mgr, val)

   def setBootPriority(self, value):
       """
        Network boot priority of the adapter. Priority 1 is highest. If not set,
        the priority is considered to be at the lowest possible setting.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setBootPriority(_this, _val)

   def getBandwidthGroup(self):
       """The bandwidth group this network adapter is assigned to. """
       val = self.mgr.getService().INetworkAdapter_getBandwidthGroup(self.handle)
       return IBandwidthGroup(self.mgr, val)

   def setBandwidthGroup(self, value):
       """The bandwidth group this network adapter is assigned to. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INetworkAdapter_setBandwidthGroup(_this, _val)



   _Attrs_ = {'adapterType':[getAdapterType,setAdapterType,],
              'slot':[getSlot,None],
              'enabled':[getEnabled,setEnabled,],
              'MACAddress':[getMACAddress,setMACAddress,],
              'attachmentType':[getAttachmentType,setAttachmentType,],
              'bridgedInterface':[getBridgedInterface,setBridgedInterface,],
              'hostOnlyInterface':[getHostOnlyInterface,setHostOnlyInterface,],
              'internalNetwork':[getInternalNetwork,setInternalNetwork,],
              'NATNetwork':[getNATNetwork,setNATNetwork,],
              'genericDriver':[getGenericDriver,setGenericDriver,],
              'cloudNetwork':[getCloudNetwork,setCloudNetwork,],
              'cableConnected':[getCableConnected,setCableConnected,],
              'lineSpeed':[getLineSpeed,setLineSpeed,],
              'promiscModePolicy':[getPromiscModePolicy,setPromiscModePolicy,],
              'traceEnabled':[getTraceEnabled,setTraceEnabled,],
              'traceFile':[getTraceFile,setTraceFile,],
              'NATEngine':[getNATEngine,None],
              'bootPriority':[getBootPriority,setBootPriority,],
              'bandwidthGroup':[getBandwidthGroup,setBandwidthGroup,]}

class ISerialPort(IUnknown):
   """
      The ISerialPort interface represents the virtual serial port device.

      The virtual serial port device acts like an ordinary serial port
      inside the virtual machine. This device communicates to the real
      serial port hardware in one of two modes: host pipe or host device.

      In host pipe mode, the #path attribute specifies the path to the pipe on
      the host computer that represents a serial port. The #server attribute
      determines if this pipe is created by the virtual machine process at
      machine startup or it must already exist before starting machine
      execution.

      In host device mode, the #path attribute specifies the name of the
      serial port device on the host computer.

      There is also a third communication mode: the disconnected mode. In this
      mode, the guest OS running inside the virtual machine will be able to
      detect the serial port, but all port write operations will be discarded
      and all port read operations will return no data.

      
        .. sealso:: IMachine::getSerialPort
      Interface ID:
        {5587D0F6-A227-4F23-8278-2F675EEA1BB2}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISerialPort(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISerialPort._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISerialPort._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getSlot(self):
       """
        Slot number this serial port is plugged into. Corresponds to
        the value you pass to IMachine::getSerialPort
        to obtain this instance.
       """
       val = self.mgr.getService().ISerialPort_getSlot(self.handle)
       return UnsignedInt(self.mgr, val)

   def getEnabled(self):
       """
        Flag whether the serial port is enabled. If disabled,
        the serial port will not be reported to the guest OS.
       """
       val = self.mgr.getService().ISerialPort_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEnabled(self, value):
       """
        Flag whether the serial port is enabled. If disabled,
        the serial port will not be reported to the guest OS.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISerialPort_setEnabled(_this, _val)

   def getIOBase(self):
       """Base I/O address of the serial port. """
       val = self.mgr.getService().ISerialPort_getIOBase(self.handle)
       return UnsignedInt(self.mgr, val)

   def setIOBase(self, value):
       """Base I/O address of the serial port. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISerialPort_setIOBase(_this, _val)

   def getIRQ(self):
       """IRQ number of the serial port. """
       val = self.mgr.getService().ISerialPort_getIRQ(self.handle)
       return UnsignedInt(self.mgr, val)

   def setIRQ(self, value):
       """IRQ number of the serial port. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISerialPort_setIRQ(_this, _val)

   def getHostMode(self):
       """
        How is this port connected to the host.
        
        .. note:: 
          Changing this attribute may fail if the conditions for
          #path are not met.
         """
       val = self.mgr.getService().ISerialPort_getHostMode(self.handle)
       return PortMode(self.mgr, val)

   def setHostMode(self, value):
       """
        How is this port connected to the host.
        
        .. note:: 
          Changing this attribute may fail if the conditions for
          #path are not met.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISerialPort_setHostMode(_this, _val)

   def getServer(self):
       """
        Flag whether this serial port acts as a server (creates a new pipe on
        the host) or as a client (uses the existing pipe). This attribute is
        used only when #hostMode is PortMode_HostPipe or PortMode_TCP.
       """
       val = self.mgr.getService().ISerialPort_getServer(self.handle)
       return Boolean(self.mgr, val)

   def setServer(self, value):
       """
        Flag whether this serial port acts as a server (creates a new pipe on
        the host) or as a client (uses the existing pipe). This attribute is
        used only when #hostMode is PortMode_HostPipe or PortMode_TCP.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISerialPort_setServer(_this, _val)

   def getPath(self):
       """
        Path to the serial port's pipe on the host when ISerialPort::hostMode is
        PortMode_HostPipe, the host serial device name when
        ISerialPort::hostMode is PortMode_HostDevice or the TCP
        port (server) or hostname:port (client) when
        ISerialPort::hostMode is PortMode_TCP.
        For those cases, setting a @c null or empty string as the attribute's
        value is an error. Otherwise, the value of this property is ignored.
       """
       val = self.mgr.getService().ISerialPort_getPath(self.handle)
       return String(self.mgr, val)

   def setPath(self, value):
       """
        Path to the serial port's pipe on the host when ISerialPort::hostMode is
        PortMode_HostPipe, the host serial device name when
        ISerialPort::hostMode is PortMode_HostDevice or the TCP
        port (server) or hostname:port (client) when
        ISerialPort::hostMode is PortMode_TCP.
        For those cases, setting a @c null or empty string as the attribute's
        value is an error. Otherwise, the value of this property is ignored.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISerialPort_setPath(_this, _val)

   def getUartType(self):
       """Selects the emulated UART implementation. """
       val = self.mgr.getService().ISerialPort_getUartType(self.handle)
       return UartType(self.mgr, val)

   def setUartType(self, value):
       """Selects the emulated UART implementation. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISerialPort_setUartType(_this, _val)



   _Attrs_ = {'slot':[getSlot,None],
              'enabled':[getEnabled,setEnabled,],
              'IOBase':[getIOBase,setIOBase,],
              'IRQ':[getIRQ,setIRQ,],
              'hostMode':[getHostMode,setHostMode,],
              'server':[getServer,setServer,],
              'path':[getPath,setPath,],
              'uartType':[getUartType,setUartType,]}

class IParallelPort(IUnknown):
   """
      The IParallelPort interface represents the virtual parallel port device.

      The virtual parallel port device acts like an ordinary parallel port
      inside the virtual machine. This device communicates to the real
      parallel port hardware using the name of the parallel device on the host
      computer specified in the #path attribute.

      Each virtual parallel port device is assigned a base I/O address and an
      IRQ number that will be reported to the guest operating system and used
      to operate the given parallel port from within the virtual machine.

      
        .. sealso:: IMachine::getParallelPort
      Interface ID:
        {788B87DF-7708-444B-9EEF-C116CE423D39}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IParallelPort(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IParallelPort._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IParallelPort._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getSlot(self):
       """
        Slot number this parallel port is plugged into. Corresponds to
        the value you pass to IMachine::getParallelPort
        to obtain this instance.
       """
       val = self.mgr.getService().IParallelPort_getSlot(self.handle)
       return UnsignedInt(self.mgr, val)

   def getEnabled(self):
       """
        Flag whether the parallel port is enabled. If disabled,
        the parallel port will not be reported to the guest OS.
       """
       val = self.mgr.getService().IParallelPort_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEnabled(self, value):
       """
        Flag whether the parallel port is enabled. If disabled,
        the parallel port will not be reported to the guest OS.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IParallelPort_setEnabled(_this, _val)

   def getIOBase(self):
       """Base I/O address of the parallel port. """
       val = self.mgr.getService().IParallelPort_getIOBase(self.handle)
       return UnsignedInt(self.mgr, val)

   def setIOBase(self, value):
       """Base I/O address of the parallel port. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IParallelPort_setIOBase(_this, _val)

   def getIRQ(self):
       """IRQ number of the parallel port. """
       val = self.mgr.getService().IParallelPort_getIRQ(self.handle)
       return UnsignedInt(self.mgr, val)

   def setIRQ(self, value):
       """IRQ number of the parallel port. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IParallelPort_setIRQ(_this, _val)

   def getPath(self):
       """
        Host parallel device name. If this parallel port is enabled, setting a
        @c null or an empty string as this attribute's value will result in
        the parallel port behaving as if not connected to any device.
       """
       val = self.mgr.getService().IParallelPort_getPath(self.handle)
       return String(self.mgr, val)

   def setPath(self, value):
       """
        Host parallel device name. If this parallel port is enabled, setting a
        @c null or an empty string as this attribute's value will result in
        the parallel port behaving as if not connected to any device.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IParallelPort_setPath(_this, _val)



   _Attrs_ = {'slot':[getSlot,None],
              'enabled':[getEnabled,setEnabled,],
              'IOBase':[getIOBase,setIOBase,],
              'IRQ':[getIRQ,setIRQ,],
              'path':[getPath,setPath,]}

class IMachineDebugger(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMachineDebugger(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachineDebugger._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachineDebugger._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def dumpGuestCore(self, _arg_filename, _arg_compression):
       """
        Takes a core dump of the guest.

        See include/VBox/dbgfcorefmt.h for details on the file format.
      
        :param _arg_filename: The name of the output file. The file must not exist.
        :param _arg_compression: Reserved for future compression method indicator.

       """
   
       req = (self.handle,)
       req += (_arg_filename,)
       req += (_arg_compression,)
       val = self.mgr.getService().IMachineDebugger_dumpGuestCore(*req)
       
       return 

   def dumpHostProcessCore(self, _arg_filename, _arg_compression):
       """
        Takes a core dump of the VM process on the host.

        This feature is not implemented in the 4.0.0 release but it may show up
        in a dot release.
      
        :param _arg_filename: The name of the output file. The file must not exist.
        :param _arg_compression: Reserved for future compression method indicator.

       """
   
       req = (self.handle,)
       req += (_arg_filename,)
       req += (_arg_compression,)
       val = self.mgr.getService().IMachineDebugger_dumpHostProcessCore(*req)
       
       return 

   def info(self, _arg_name, _arg_args):
       """
        Interfaces with the info dumpers (DBGFInfo).

        This feature is not implemented in the 4.0.0 release but it may show up
        in a dot release.
      
        :param _arg_name: The name of the info item.
        :param _arg_args: Arguments to the info dumper.
        :return: The into string.
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_args,)
       val = self.mgr.getService().IMachineDebugger_info(*req)
       
       return String(self.mgr, val)

   def injectNMI(self):
       """
        Inject an NMI into a running VT-x/AMD-V VM.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMachineDebugger_injectNMI(*req)
       
       return 

   def modifyLogGroups(self, _arg_settings):
       """
        Modifies the group settings of the debug or release logger.
      
        :param _arg_settings: The group settings string. See iprt/log.h for details. To target the release logger, prefix the string with "release:".

       """
   
       req = (self.handle,)
       req += (_arg_settings,)
       val = self.mgr.getService().IMachineDebugger_modifyLogGroups(*req)
       
       return 

   def modifyLogFlags(self, _arg_settings):
       """
        Modifies the debug or release logger flags.
      
        :param _arg_settings: The flags settings string. See iprt/log.h for details. To target the release logger, prefix the string with "release:".

       """
   
       req = (self.handle,)
       req += (_arg_settings,)
       val = self.mgr.getService().IMachineDebugger_modifyLogFlags(*req)
       
       return 

   def modifyLogDestinations(self, _arg_settings):
       """
        Modifies the debug or release logger destinations.
      
        :param _arg_settings: The destination settings string. See iprt/log.h for details. To target the release logger, prefix the string with "release:".

       """
   
       req = (self.handle,)
       req += (_arg_settings,)
       val = self.mgr.getService().IMachineDebugger_modifyLogDestinations(*req)
       
       return 

   def readPhysicalMemory(self, _arg_address, _arg_size):
       """
        Reads guest physical memory, no side effects (MMIO++).

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      
        :param _arg_address: The guest physical address.
        :param _arg_size: The number of bytes to read.
        :return: The bytes read.
        :rtype: List[octet]

       """
   
       req = (self.handle,)
       req += (_arg_address,)
       req += (_arg_size,)
       val = self.mgr.getService().IMachineDebugger_readPhysicalMemory(*req)
       
       return self.mgr.decodebase64( val)

   def writePhysicalMemory(self, _arg_address, _arg_size, _arg_bytes):
       """
        Writes guest physical memory, access handles (MMIO++) are ignored.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      
        :param _arg_address: The guest physical address.
        :param _arg_size: The number of bytes to read.
        :param _arg_bytes: The bytes to write.

       """
   
       req = (self.handle,)
       req += (_arg_address,)
       req += (_arg_size,)
       req += (self.mgr.encodebase64(_arg_bytes),)
       val = self.mgr.getService().IMachineDebugger_writePhysicalMemory(*req)
       
       return 

   def readVirtualMemory(self, _arg_cpuId, _arg_address, _arg_size):
       """
        Reads guest virtual memory, no side effects (MMIO++).

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      
        :param _arg_cpuId: The identifier of the Virtual CPU.
        :param _arg_address: The guest virtual address.
        :param _arg_size: The number of bytes to read.
        :return: The bytes read.
        :rtype: List[octet]

       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       req += (_arg_address,)
       req += (_arg_size,)
       val = self.mgr.getService().IMachineDebugger_readVirtualMemory(*req)
       
       return self.mgr.decodebase64( val)

   def writeVirtualMemory(self, _arg_cpuId, _arg_address, _arg_size, _arg_bytes):
       """
        Writes guest virtual memory, access handles (MMIO++) are ignored.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      
        :param _arg_cpuId: The identifier of the Virtual CPU.
        :param _arg_address: The guest virtual address.
        :param _arg_size: The number of bytes to read.
        :param _arg_bytes: The bytes to write.

       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       req += (_arg_address,)
       req += (_arg_size,)
       req += (self.mgr.encodebase64(_arg_bytes),)
       val = self.mgr.getService().IMachineDebugger_writeVirtualMemory(*req)
       
       return 

   def loadPlugIn(self, _arg_name):
       """ Loads a DBGF plug-in. 
        :param _arg_name: The plug-in name or DLL. Special name 'all' loads all installed plug-ins.
        :return: The name of the loaded plug-in.
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachineDebugger_loadPlugIn(*req)
       
       return String(self.mgr, val)

   def unloadPlugIn(self, _arg_name):
       """Unloads a DBGF plug-in.
        :param _arg_name: The plug-in name or DLL. Special name 'all' unloads all plug-ins.

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachineDebugger_unloadPlugIn(*req)
       
       return 

   def detectOS(self):
       """
        Tries to (re-)detect the guest OS kernel.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      
        :return: The detected OS kernel on success.
        :rtype: wstring

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IMachineDebugger_detectOS(*req)
       
       return String(self.mgr, val)

   def queryOSKernelLog(self, _arg_maxMessages):
       """
        Tries to get the kernel log (dmesg) of the guest OS.

      
        :param _arg_maxMessages: Max number of messages to return, counting from the end of the log. If 0, there is no limit.
        :return: The kernel log.
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_maxMessages,)
       val = self.mgr.getService().IMachineDebugger_queryOSKernelLog(*req)
       
       return String(self.mgr, val)

   def getRegister(self, _arg_cpuId, _arg_name):
       """
        Gets one register.
      
        :param _arg_cpuId: The identifier of the Virtual CPU.
        :param _arg_name: The register name, case is ignored.
        :return: The register value. This is usually a hex value (always 0x prefixed) but other format may be used for floating point registers (TBD).
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       req += (_arg_name,)
       val = self.mgr.getService().IMachineDebugger_getRegister(*req)
       
       return String(self.mgr, val)

   def getRegisters(self, _arg_cpuId):
       """
        Gets all the registers for the given CPU.
      
        :param _arg_cpuId: The identifier of the Virtual CPU.



       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       val = self.mgr.getService().IMachineDebugger_getRegisters(*req)
       
       return String(self.mgr,val["names"], True), String(self.mgr,val["values"], True)

   def setRegister(self, _arg_cpuId, _arg_name, _arg_value):
       """
        Gets one register.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      
        :param _arg_cpuId: The identifier of the Virtual CPU.
        :param _arg_name: The register name, case is ignored.
        :param _arg_value: The new register value. Hexadecimal, decimal and octal formattings are supported in addition to any special formattings returned by the getters.

       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       req += (_arg_name,)
       req += (_arg_value,)
       val = self.mgr.getService().IMachineDebugger_setRegister(*req)
       
       return 

   def setRegisters(self, _arg_cpuId, _arg_names, _arg_values):
       """
        Sets zero or more registers atomically.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      
        :param _arg_cpuId: The identifier of the Virtual CPU.
        :param _arg_names: Array containing the register names, case ignored.
        :param _arg_values: Array paralell to the names holding the register values. See for formatting guidelines.

       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       req += (_arg_names,)
       req += (_arg_values,)
       val = self.mgr.getService().IMachineDebugger_setRegisters(*req)
       
       return 

   def dumpGuestStack(self, _arg_cpuId):
       """
        Produce a simple stack dump using the current guest state.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
      
        :param _arg_cpuId: The identifier of the Virtual CPU.
        :return: String containing the formatted stack dump.
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       val = self.mgr.getService().IMachineDebugger_dumpGuestStack(*req)
       
       return String(self.mgr, val)

   def resetStats(self, _arg_pattern):
       """
        Reset VM statistics.
      
        :param _arg_pattern: The selection pattern. A bit similar to filename globbing. Wildchars are '*' and '?', where the asterisk matches zero or more characters and question mark matches exactly one character. Multiple pattern can be joined by putting '|' between them.

       """
   
       req = (self.handle,)
       req += (_arg_pattern,)
       val = self.mgr.getService().IMachineDebugger_resetStats(*req)
       
       return 

   def dumpStats(self, _arg_pattern):
       """
        Dumps VM statistics.
      
        :param _arg_pattern: The selection pattern. A bit similar to filename globbing. Wildchars are '*' and '?', where the asterisk matches zero or more characters and question mark matches exactly one character. Multiple pattern can be joined by putting '|' between them.

       """
   
       req = (self.handle,)
       req += (_arg_pattern,)
       val = self.mgr.getService().IMachineDebugger_dumpStats(*req)
       
       return 

   def getStats(self, _arg_pattern, _arg_withDescriptions):
       """
        Get the VM statistics in a XMLish format.
      
        :param _arg_pattern: The selection pattern. A bit similar to filename globbing. Wildchars are '*' and '?', where the asterisk matches zero or more characters and question mark matches exactly one character. Multiple pattern can be joined by putting '|' between them.
        :param _arg_withDescriptions: Whether to include the descriptions.
        :return: The XML document containing the statistics.
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_pattern,)
       req += (_arg_withDescriptions,)
       val = self.mgr.getService().IMachineDebugger_getStats(*req)
       
       return String(self.mgr, val)

   def getCPULoad(self, _arg_cpuId):
       """
        Get the load percentages (as observed by the VMM) for all virtual CPUs
        or a specific one.
      
        :param _arg_cpuId: The ID of the virtual CPU to retrieve stats for, pass 0x7fffffff or higher for the average accross all CPUs.



        :return: The interval the percentage was calculated over in milliseconds
        :rtype: long long

       """
   
       req = (self.handle,)
       req += (_arg_cpuId,)
       val = self.mgr.getService().IMachineDebugger_getCPULoad(*req)
       
       return Long(self.mgr,val["returnval"]), UnsignedInt(self.mgr,val["pctExecuting"]), UnsignedInt(self.mgr,val["pctHalted"]), UnsignedInt(self.mgr,val["pctOther"])

   def getSingleStep(self):
       """Switch for enabling single-stepping. """
       val = self.mgr.getService().IMachineDebugger_getSingleStep(self.handle)
       return Boolean(self.mgr, val)

   def setSingleStep(self, value):
       """Switch for enabling single-stepping. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachineDebugger_setSingleStep(_this, _val)

   def getRecompileUser(self):
       """Switch for forcing code recompilation for user mode code. """
       val = self.mgr.getService().IMachineDebugger_getRecompileUser(self.handle)
       return Boolean(self.mgr, val)

   def setRecompileUser(self, value):
       """Switch for forcing code recompilation for user mode code. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachineDebugger_setRecompileUser(_this, _val)

   def getRecompileSupervisor(self):
       """Switch for forcing code recompilation for supervisor mode code. """
       val = self.mgr.getService().IMachineDebugger_getRecompileSupervisor(self.handle)
       return Boolean(self.mgr, val)

   def setRecompileSupervisor(self, value):
       """Switch for forcing code recompilation for supervisor mode code. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachineDebugger_setRecompileSupervisor(_this, _val)

   def getExecuteAllInIEM(self):
       """
        Whether to execute all the code in the instruction interpreter. This
        is mainly for testing the interpreter and not an execution mode
        intended for general consumption.
       """
       val = self.mgr.getService().IMachineDebugger_getExecuteAllInIEM(self.handle)
       return Boolean(self.mgr, val)

   def setExecuteAllInIEM(self, value):
       """
        Whether to execute all the code in the instruction interpreter. This
        is mainly for testing the interpreter and not an execution mode
        intended for general consumption.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachineDebugger_setExecuteAllInIEM(_this, _val)

   def getPATMEnabled(self):
       """Switch for enabling and disabling the PATM component. """
       val = self.mgr.getService().IMachineDebugger_getPATMEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setPATMEnabled(self, value):
       """Switch for enabling and disabling the PATM component. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachineDebugger_setPATMEnabled(_this, _val)

   def getCSAMEnabled(self):
       """Switch for enabling and disabling the CSAM component. """
       val = self.mgr.getService().IMachineDebugger_getCSAMEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setCSAMEnabled(self, value):
       """Switch for enabling and disabling the CSAM component. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachineDebugger_setCSAMEnabled(_this, _val)

   def getLogEnabled(self):
       """Switch for enabling and disabling the debug logger. """
       val = self.mgr.getService().IMachineDebugger_getLogEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setLogEnabled(self, value):
       """Switch for enabling and disabling the debug logger. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachineDebugger_setLogEnabled(_this, _val)

   def getLogDbgFlags(self):
       """The debug logger flags. """
       val = self.mgr.getService().IMachineDebugger_getLogDbgFlags(self.handle)
       return String(self.mgr, val)

   def getLogDbgGroups(self):
       """The debug logger's group settings. """
       val = self.mgr.getService().IMachineDebugger_getLogDbgGroups(self.handle)
       return String(self.mgr, val)

   def getLogDbgDestinations(self):
       """The debug logger's destination settings. """
       val = self.mgr.getService().IMachineDebugger_getLogDbgDestinations(self.handle)
       return String(self.mgr, val)

   def getLogRelFlags(self):
       """The release logger flags. """
       val = self.mgr.getService().IMachineDebugger_getLogRelFlags(self.handle)
       return String(self.mgr, val)

   def getLogRelGroups(self):
       """The release logger's group settings. """
       val = self.mgr.getService().IMachineDebugger_getLogRelGroups(self.handle)
       return String(self.mgr, val)

   def getLogRelDestinations(self):
       """The relase logger's destination settings. """
       val = self.mgr.getService().IMachineDebugger_getLogRelDestinations(self.handle)
       return String(self.mgr, val)

   def getExecutionEngine(self):
       """Gets the main execution engine of the VM. """
       val = self.mgr.getService().IMachineDebugger_getExecutionEngine(self.handle)
       return VMExecutionEngine(self.mgr, val)

   def getHWVirtExEnabled(self):
       """
        Flag indicating whether the VM is currently making use of CPU hardware
        virtualization extensions.

        Superseeded by mainExecutionMode.
       """
       val = self.mgr.getService().IMachineDebugger_getHWVirtExEnabled(self.handle)
       return Boolean(self.mgr, val)

   def getHWVirtExNestedPagingEnabled(self):
       """
        Flag indicating whether the VM is currently making use of the nested paging
        CPU hardware virtualization extension.
       """
       val = self.mgr.getService().IMachineDebugger_getHWVirtExNestedPagingEnabled(self.handle)
       return Boolean(self.mgr, val)

   def getHWVirtExVPIDEnabled(self):
       """
        Flag indicating whether the VM is currently making use of the VPID
        VT-x extension.
       """
       val = self.mgr.getService().IMachineDebugger_getHWVirtExVPIDEnabled(self.handle)
       return Boolean(self.mgr, val)

   def getHWVirtExUXEnabled(self):
       """
        Flag indicating whether the VM is currently making use of the
        unrestricted execution feature of VT-x.
       """
       val = self.mgr.getService().IMachineDebugger_getHWVirtExUXEnabled(self.handle)
       return Boolean(self.mgr, val)

   def getOSName(self):
       """
        Query the guest OS kernel name as detected by the DBGF.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
       """
       val = self.mgr.getService().IMachineDebugger_getOSName(self.handle)
       return String(self.mgr, val)

   def getOSVersion(self):
       """
        Query the guest OS kernel version string as detected by the DBGF.

        This feature is not implemented in the 4.0.0 release but may show up
        in a dot release.
       """
       val = self.mgr.getService().IMachineDebugger_getOSVersion(self.handle)
       return String(self.mgr, val)

   def getPAEEnabled(self):
       """
        Flag indicating whether the VM is currently making use of the Physical
        Address Extension CPU feature.
       """
       val = self.mgr.getService().IMachineDebugger_getPAEEnabled(self.handle)
       return Boolean(self.mgr, val)

   def getVirtualTimeRate(self):
       """
        The rate at which the virtual time runs expressed as a percentage.
        The accepted range is 2% to 20000%.
       """
       val = self.mgr.getService().IMachineDebugger_getVirtualTimeRate(self.handle)
       return UnsignedInt(self.mgr, val)

   def setVirtualTimeRate(self, value):
       """
        The rate at which the virtual time runs expressed as a percentage.
        The accepted range is 2% to 20000%.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IMachineDebugger_setVirtualTimeRate(_this, _val)

   def getVM(self):
       """
        Gets the user-mode VM handle, with a reference. Must be passed to
        VMR3ReleaseUVM when done. This is only for internal use while we carve
        the details of this interface.
       """
       val = self.mgr.getService().IMachineDebugger_getVM(self.handle)
       return Long(self.mgr, val)

   def getUptime(self):
       """VM uptime in milliseconds, i.e. time in which it could have been
        executing guest code. Excludes the time when the VM was paused. """
       val = self.mgr.getService().IMachineDebugger_getUptime(self.handle)
       return Long(self.mgr, val)



   _Attrs_ = {'singleStep':[getSingleStep,setSingleStep,],
              'recompileUser':[getRecompileUser,setRecompileUser,],
              'recompileSupervisor':[getRecompileSupervisor,setRecompileSupervisor,],
              'executeAllInIEM':[getExecuteAllInIEM,setExecuteAllInIEM,],
              'PATMEnabled':[getPATMEnabled,setPATMEnabled,],
              'CSAMEnabled':[getCSAMEnabled,setCSAMEnabled,],
              'logEnabled':[getLogEnabled,setLogEnabled,],
              'logDbgFlags':[getLogDbgFlags,None],
              'logDbgGroups':[getLogDbgGroups,None],
              'logDbgDestinations':[getLogDbgDestinations,None],
              'logRelFlags':[getLogRelFlags,None],
              'logRelGroups':[getLogRelGroups,None],
              'logRelDestinations':[getLogRelDestinations,None],
              'executionEngine':[getExecutionEngine,None],
              'HWVirtExEnabled':[getHWVirtExEnabled,None],
              'HWVirtExNestedPagingEnabled':[getHWVirtExNestedPagingEnabled,None],
              'HWVirtExVPIDEnabled':[getHWVirtExVPIDEnabled,None],
              'HWVirtExUXEnabled':[getHWVirtExUXEnabled,None],
              'OSName':[getOSName,None],
              'OSVersion':[getOSVersion,None],
              'PAEEnabled':[getPAEEnabled,None],
              'virtualTimeRate':[getVirtualTimeRate,setVirtualTimeRate,],
              'VM':[getVM,None],
              'uptime':[getUptime,None]}

class IUSBDeviceFilters(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IUSBDeviceFilters(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBDeviceFilters._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBDeviceFilters._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def createDeviceFilter(self, _arg_name):
       """
        Creates a new USB device filter. All attributes except
        the filter name are set to empty (any match),
        active is @c false (the filter is not active).

        The created filter can then be added to the list of filters using
        #insertDeviceFilter.

        
        :param _arg_name: Filter name. See for more info.
        :return: Created filter object.
        :rtype: IUSBDeviceFilter

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          The virtual machine is not mutable.
        
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IUSBDeviceFilters_createDeviceFilter(*req)
       
       return IUSBDeviceFilter(self.mgr, val)

   def insertDeviceFilter(self, _arg_position, _arg_filter):
       """
        Inserts the given USB device to the specified position
        in the list of filters.

        Positions are numbered starting from 0. If the specified
        position is equal to or greater than the number of elements in
        the list, the filter is added to the end of the collection.

        
        :param _arg_position: Position to insert the filter to.
        :param _arg_filter: USB device filter to insert.

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine is not mutable.
        E_INVALIDARG
          USB device filter not created within this VirtualBox instance.
        VBOX_E_INVALID_OBJECT_STATE
          USB device filter already in list.
        
        .. note:: 
          Duplicates are not allowed, so an attempt to insert a
          filter that is already in the collection, will return an
          error.
        
       """
   
       req = (self.handle,)
       req += (_arg_position,)
       req += (_arg_filter,)
       val = self.mgr.getService().IUSBDeviceFilters_insertDeviceFilter(*req)
       
       return 

   def removeDeviceFilter(self, _arg_position):
       """
        Removes a USB device filter from the specified position in the
        list of filters.

        Positions are numbered starting from 0. Specifying a
        position equal to or greater than the number of elements in
        the list will produce an error.

        
        :param _arg_position: Position to remove the filter from.
        :return: Removed USB device filter.
        :rtype: IUSBDeviceFilter

        Expected result codes:
        VBOX_E_INVALID_VM_STATE
          Virtual machine is not mutable.
        E_INVALIDARG
          USB device filter list empty or invalid @a position.
        
       """
   
       req = (self.handle,)
       req += (_arg_position,)
       val = self.mgr.getService().IUSBDeviceFilters_removeDeviceFilter(*req)
       
       return IUSBDeviceFilter(self.mgr, val)

   def getDeviceFilters(self):
       """
        List of USB device filters associated with the machine.

        If the machine is currently running, these filters are activated
        every time a new (supported) USB device is attached to the host
        computer that was not ignored by global filters
        (IHost::USBDeviceFilters).

        These filters are also activated when the machine is powered up.
        They are run against a list of all currently available USB
        devices (in states
        ::USBDeviceState_Available,
        ::USBDeviceState_Busy,
        ::USBDeviceState_Held) that were not previously
        ignored by global filters.

        If at least one filter matches the USB device in question, this
        device is automatically captured (attached to) the virtual USB
        controller of this machine.

        
        .. sealso:: ::IUSBDeviceFilter, ::IUSBController """
       val = self.mgr.getService().IUSBDeviceFilters_getDeviceFilters(self.handle)
       return IUSBDeviceFilter(self.mgr, val, True)



   _Attrs_ = {'deviceFilters':[getDeviceFilters,None]}

class IUSBController(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IUSBController(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBController._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBController._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getName(self):
       """
        The USB Controller name.
       """
       val = self.mgr.getService().IUSBController_getName(self.handle)
       return String(self.mgr, val)

   def setName(self, value):
       """
        The USB Controller name.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBController_setName(_this, _val)

   def getType(self):
       """
        The USB Controller type.
       """
       val = self.mgr.getService().IUSBController_getType(self.handle)
       return USBControllerType(self.mgr, val)

   def setType(self, value):
       """
        The USB Controller type.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBController_setType(_this, _val)

   def getUSBStandard(self):
       """
        USB standard version which the controller implements.
        This is a BCD which means that the major version is in the
        high byte and minor version is in the low byte.
       """
       val = self.mgr.getService().IUSBController_getUSBStandard(self.handle)
       return UnsignedShort(self.mgr, val)



   _Attrs_ = {'name':[getName,setName,],
              'type':[getType,setType,],
              'USBStandard':[getUSBStandard,None]}

class IUSBDevice(IUnknown):
   """
      The IUSBDevice interface represents a virtual USB device attached to the
      virtual machine.

      A collection of objects implementing this interface is stored in the
      IConsole::USBDevices attribute which lists all USB devices
      attached to a running virtual machine's USB controller.
    
      Interface ID:
        {6DC83C2C-81A9-4005-9D52-FC45A78BF3F5}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IUSBDevice(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBDevice._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBDevice._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getId(self):
       """
        Unique USB device ID. This ID is built from #vendorId,
        #productId, #revision and #serialNumber.
       """
       val = self.mgr.getService().IUSBDevice_getId(self.handle)
       return String(self.mgr, val)

   def getVendorId(self):
       """Vendor ID. """
       val = self.mgr.getService().IUSBDevice_getVendorId(self.handle)
       return UnsignedShort(self.mgr, val)

   def getProductId(self):
       """Product ID. """
       val = self.mgr.getService().IUSBDevice_getProductId(self.handle)
       return UnsignedShort(self.mgr, val)

   def getRevision(self):
       """
        Product revision number. This is a packed BCD represented as
        unsigned short. The high byte is the integer part and the low
        byte is the decimal.
       """
       val = self.mgr.getService().IUSBDevice_getRevision(self.handle)
       return UnsignedShort(self.mgr, val)

   def getManufacturer(self):
       """Manufacturer string. """
       val = self.mgr.getService().IUSBDevice_getManufacturer(self.handle)
       return String(self.mgr, val)

   def getProduct(self):
       """Product string. """
       val = self.mgr.getService().IUSBDevice_getProduct(self.handle)
       return String(self.mgr, val)

   def getSerialNumber(self):
       """Serial number string. """
       val = self.mgr.getService().IUSBDevice_getSerialNumber(self.handle)
       return String(self.mgr, val)

   def getAddress(self):
       """
        Host-specific address of the device, uniquely
        identifying a physically connected device in the system.
        Note that the address of a USB device may change across
        device re-plugs and host suspend/resume cycles or reboots.
       """
       val = self.mgr.getService().IUSBDevice_getAddress(self.handle)
       return String(self.mgr, val)

   def getPort(self):
       """
        Host USB port number on the hub the device is physically
        connected to.
       """
       val = self.mgr.getService().IUSBDevice_getPort(self.handle)
       return UnsignedShort(self.mgr, val)

   def getPortPath(self):
       """
        Host-specific identifier of the port (including hub) the USB
        device is physically connected to. Note that hubs may be
        dynamically added and removed, and that hub enumeration may not
        be consistent across host reboots.
       """
       val = self.mgr.getService().IUSBDevice_getPortPath(self.handle)
       return String(self.mgr, val)

   def getVersion(self):
       """
        The major USB version of the device - 1, 2 or 3.
       """
       val = self.mgr.getService().IUSBDevice_getVersion(self.handle)
       return UnsignedShort(self.mgr, val)

   def getSpeed(self):
       """
        The speed at which the device is currently communicating.
       """
       val = self.mgr.getService().IUSBDevice_getSpeed(self.handle)
       return USBConnectionSpeed(self.mgr, val)

   def getRemote(self):
       """
        Whether the device is physically connected to a remote VRDE
        client or to a local host machine.
       """
       val = self.mgr.getService().IUSBDevice_getRemote(self.handle)
       return Boolean(self.mgr, val)

   def getDeviceInfo(self):
       """
        Array of device attributes as single strings.

        So far the following are used:
          0: The manufacturer string, if the device doesn't expose the ID one is taken
             from an internal database or an empty string if none is found.
          1: The product string, if the device doesn't expose the ID one is taken
             from an internal database or an empty string if none is found.
       """
       val = self.mgr.getService().IUSBDevice_getDeviceInfo(self.handle)
       return String(self.mgr, val, True)

   def getBackend(self):
       """
        The backend which will be used to communicate with this device.
       """
       val = self.mgr.getService().IUSBDevice_getBackend(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'id':[getId,None],
              'vendorId':[getVendorId,None],
              'productId':[getProductId,None],
              'revision':[getRevision,None],
              'manufacturer':[getManufacturer,None],
              'product':[getProduct,None],
              'serialNumber':[getSerialNumber,None],
              'address':[getAddress,None],
              'port':[getPort,None],
              'portPath':[getPortPath,None],
              'version':[getVersion,None],
              'speed':[getSpeed,None],
              'remote':[getRemote,None],
              'deviceInfo':[getDeviceInfo,None],
              'backend':[getBackend,None]}

class IUSBDeviceFilter(IUnknown):
   """
      The IUSBDeviceFilter interface represents an USB device filter used
      to perform actions on a group of USB devices.

      This type of filters is used by running virtual machines to
      automatically capture selected USB devices once they are physically
      attached to the host computer.

      A USB device is matched to the given device filter if and only if all
      attributes of the device match the corresponding attributes of the
      filter (that is, attributes are joined together using the logical AND
      operation). On the other hand, all together, filters in the list of
      filters carry the semantics of the logical OR operation. So if it is
      desirable to create a match like "this vendor id OR this product id",
      one needs to create two filters and specify "any match" (see below)
      for unused attributes.

      All filter attributes used for matching are strings. Each string
      is an expression representing a set of values of the corresponding
      device attribute, that will match the given filter. Currently, the
      following filtering expressions are supported:

        * Interval filters. Used to specify valid intervals for
          integer device attributes (Vendor ID, Product ID and Revision).
          The format of the string is:

          int:((m)|([m]-[n]))(,(m)|([m]-[n]))*

          where m and n are integer numbers, either in octal
          (starting from 0), hexadecimal (starting from 0x)
          or decimal (otherwise) form, so that m < n. If m
          is omitted before a dash (-), the minimum possible integer
          is assumed; if n is omitted after a dash, the maximum
          possible integer is assumed.
        
          * Boolean filters. Used to specify acceptable values for
          boolean device attributes. The format of the string is:

          true|false|yes|no|0|1
          * Exact match. Used to specify a single value for the given
          device attribute. Any string that doesn't start with int:
          represents the exact match. String device attributes are compared to
          this string including case of symbols. Integer attributes are first
          converted to a string (see individual filter attributes) and then
          compared ignoring case.

        
          * Any match. Any value of the corresponding device attribute
          will match the given filter. An empty or @c null string is
          used to construct this type of filtering expressions.

        
        .. note:: 
        On the Windows host platform, interval filters are not currently
        available. Also all string filter attributes
        (#manufacturer, #product,
        #serialNumber) are ignored, so they behave as
        any match no matter what string expression is specified.
      
        .. sealso:: IUSBDeviceFilters::deviceFilters,
        ::IHostUSBDeviceFilter
      Interface ID:
        {45587218-4289-EF4E-8E6A-E5B07816B631}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IUSBDeviceFilter(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBDeviceFilter._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBDeviceFilter._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getName(self):
       """
        Visible name for this filter.
        This name is used to visually distinguish one filter from another,
        so it can neither be @c null nor an empty string.
       """
       val = self.mgr.getService().IUSBDeviceFilter_getName(self.handle)
       return String(self.mgr, val)

   def setName(self, value):
       """
        Visible name for this filter.
        This name is used to visually distinguish one filter from another,
        so it can neither be @c null nor an empty string.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setName(_this, _val)

   def getActive(self):
       """Whether this filter active or has been temporarily disabled. """
       val = self.mgr.getService().IUSBDeviceFilter_getActive(self.handle)
       return Boolean(self.mgr, val)

   def setActive(self, value):
       """Whether this filter active or has been temporarily disabled. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setActive(_this, _val)

   def getVendorId(self):
       """IUSBDevice::vendorId filter.
        The string representation for the exact matching
        has the form XXXX, where X is the hex digit
        (including leading zeroes).
       """
       val = self.mgr.getService().IUSBDeviceFilter_getVendorId(self.handle)
       return String(self.mgr, val)

   def setVendorId(self, value):
       """IUSBDevice::vendorId filter.
        The string representation for the exact matching
        has the form XXXX, where X is the hex digit
        (including leading zeroes).
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setVendorId(_this, _val)

   def getProductId(self):
       """IUSBDevice::productId filter.
        The string representation for the exact matching
        has the form XXXX, where X is the hex digit
        (including leading zeroes).
       """
       val = self.mgr.getService().IUSBDeviceFilter_getProductId(self.handle)
       return String(self.mgr, val)

   def setProductId(self, value):
       """IUSBDevice::productId filter.
        The string representation for the exact matching
        has the form XXXX, where X is the hex digit
        (including leading zeroes).
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setProductId(_this, _val)

   def getRevision(self):
       """IUSBDevice::productId
        filter. The string representation for the exact matching
        has the form IIFF, where I is the decimal digit
        of the integer part of the revision, and F is the
        decimal digit of its fractional part (including leading and
        trailing zeros).
        Note that for interval filters, it's best to use the hexadecimal
        form, because the revision is stored as a 16 bit packed BCD value;
        so the expression int:0x0100-0x0199 will match any
        revision from 1.0 to 1.99.
       """
       val = self.mgr.getService().IUSBDeviceFilter_getRevision(self.handle)
       return String(self.mgr, val)

   def setRevision(self, value):
       """IUSBDevice::productId
        filter. The string representation for the exact matching
        has the form IIFF, where I is the decimal digit
        of the integer part of the revision, and F is the
        decimal digit of its fractional part (including leading and
        trailing zeros).
        Note that for interval filters, it's best to use the hexadecimal
        form, because the revision is stored as a 16 bit packed BCD value;
        so the expression int:0x0100-0x0199 will match any
        revision from 1.0 to 1.99.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setRevision(_this, _val)

   def getManufacturer(self):
       """IUSBDevice::manufacturer filter.
       """
       val = self.mgr.getService().IUSBDeviceFilter_getManufacturer(self.handle)
       return String(self.mgr, val)

   def setManufacturer(self, value):
       """IUSBDevice::manufacturer filter.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setManufacturer(_this, _val)

   def getProduct(self):
       """IUSBDevice::product filter.
       """
       val = self.mgr.getService().IUSBDeviceFilter_getProduct(self.handle)
       return String(self.mgr, val)

   def setProduct(self, value):
       """IUSBDevice::product filter.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setProduct(_this, _val)

   def getSerialNumber(self):
       """IUSBDevice::serialNumber filter.
       """
       val = self.mgr.getService().IUSBDeviceFilter_getSerialNumber(self.handle)
       return String(self.mgr, val)

   def setSerialNumber(self, value):
       """IUSBDevice::serialNumber filter.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setSerialNumber(_this, _val)

   def getPort(self):
       """IUSBDevice::port filter.
       """
       val = self.mgr.getService().IUSBDeviceFilter_getPort(self.handle)
       return String(self.mgr, val)

   def setPort(self, value):
       """IUSBDevice::port filter.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setPort(_this, _val)

   def getRemote(self):
       """IUSBDevice::remote filter.
        
        .. note:: 
          This filter makes sense only for machine USB filters,
          i.e. it is ignored by IHostUSBDeviceFilter objects.
         """
       val = self.mgr.getService().IUSBDeviceFilter_getRemote(self.handle)
       return String(self.mgr, val)

   def setRemote(self, value):
       """IUSBDevice::remote filter.
        
        .. note:: 
          This filter makes sense only for machine USB filters,
          i.e. it is ignored by IHostUSBDeviceFilter objects.
         """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setRemote(_this, _val)

   def getMaskedInterfaces(self):
       """
        This is an advanced option for hiding one or more USB interfaces
        from the guest. The value is a bit mask where the bits that are set
        means the corresponding USB interface should be hidden, masked off
        if you like.
        This feature only works on Linux hosts.
       """
       val = self.mgr.getService().IUSBDeviceFilter_getMaskedInterfaces(self.handle)
       return UnsignedInt(self.mgr, val)

   def setMaskedInterfaces(self, value):
       """
        This is an advanced option for hiding one or more USB interfaces
        from the guest. The value is a bit mask where the bits that are set
        means the corresponding USB interface should be hidden, masked off
        if you like.
        This feature only works on Linux hosts.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IUSBDeviceFilter_setMaskedInterfaces(_this, _val)



   _Attrs_ = {'name':[getName,setName,],
              'active':[getActive,setActive,],
              'vendorId':[getVendorId,setVendorId,],
              'productId':[getProductId,setProductId,],
              'revision':[getRevision,setRevision,],
              'manufacturer':[getManufacturer,setManufacturer,],
              'product':[getProduct,setProduct,],
              'serialNumber':[getSerialNumber,setSerialNumber,],
              'port':[getPort,setPort,],
              'remote':[getRemote,setRemote,],
              'maskedInterfaces':[getMaskedInterfaces,setMaskedInterfaces,]}

class IHostUSBDevice(IUSBDevice):
   """
      The IHostUSBDevice interface represents a physical USB device attached
      to the host computer.

      Besides properties inherited from IUSBDevice, this interface adds the
      #state property that holds the current state of the USB
      device.

      
        .. sealso:: IHost::USBDevices,
        IHost::USBDeviceFilters
      Interface ID:
        {C19073DD-CC7B-431B-98B2-951FDA8EAB89}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IHostUSBDevice(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostUSBDevice._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUSBDevice.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostUSBDevice._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getState(self):
       """
        Current state of the device.
       """
       val = self.mgr.getService().IHostUSBDevice_getState(self.handle)
       return USBDeviceState(self.mgr, val)



   _Attrs_ = {'state':[getState,None]}

class IHostUSBDeviceFilter(IUSBDeviceFilter):
   """
      The IHostUSBDeviceFilter interface represents a global filter for a
      physical USB device used by the host computer. Used indirectly in
      IHost::USBDeviceFilters.

      Using filters of this type, the host computer determines the initial
      state of the USB device after it is physically attached to the
      host's USB controller.

      
        .. note:: 
        The IUSBDeviceFilter::remote attribute is ignored by this type of
        filters, because it makes sense only for
        IUSBDeviceFilters::deviceFilters.
      
        .. sealso:: IHost::USBDeviceFilters
      Interface ID:
        {01ADB2D6-AEDF-461C-BE2C-99E91BDAD8A1}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IHostUSBDeviceFilter(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostUSBDeviceFilter._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUSBDeviceFilter.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostUSBDeviceFilter._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getAction(self):
       """
        Action performed by the host when an attached USB device
        matches this filter.
       """
       val = self.mgr.getService().IHostUSBDeviceFilter_getAction(self.handle)
       return USBDeviceFilterAction(self.mgr, val)

   def setAction(self, value):
       """
        Action performed by the host when an attached USB device
        matches this filter.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IHostUSBDeviceFilter_setAction(_this, _val)



   _Attrs_ = {'action':[getAction,setAction,]}

class IUSBProxyBackend(IUnknown):
   """
      The USBProxyBackend interface represents a source for USB devices available
      to the host for attaching to the VM.
    
      Interface ID:
        {DFE56449-6989-4002-80CF-3607F377D40C}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IUSBProxyBackend(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBProxyBackend._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBProxyBackend._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getName(self):
       """
        The unique name of the proxy backend.
       """
       val = self.mgr.getService().IUSBProxyBackend_getName(self.handle)
       return String(self.mgr, val)

   def getType(self):
       """
        The type of the backend.
       """
       val = self.mgr.getService().IUSBProxyBackend_getType(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'name':[getName,None],
              'type':[getType,None]}

class IAudioAdapter(IUnknown):
   """
        The IAudioAdapter interface represents the virtual audio adapter of
        the virtual machine. Used in IMachine::audioAdapter.
    
      Interface ID:
        {5155BFD3-7BA7-45A8-B26D-C91AE3754E37}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IAudioAdapter(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IAudioAdapter._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IAudioAdapter._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def setProperty(self, _arg_key, _arg_value):
       """
        Sets an audio specific property string.

        If you pass @c null or empty string as a key @a value, the given @a key
        will be deleted.

      
        :param _arg_key: Name of the key to set.
        :param _arg_value: Value to assign to the key.

       """
   
       req = (self.handle,)
       req += (_arg_key,)
       req += (_arg_value,)
       val = self.mgr.getService().IAudioAdapter_setProperty(*req)
       
       return 

   def getProperty(self, _arg_key):
       """
        Returns an audio specific property string.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

      
        :param _arg_key: Name of the key to get.
        :return: Value of the requested key.
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_key,)
       val = self.mgr.getService().IAudioAdapter_getProperty(*req)
       
       return String(self.mgr, val)

   def getEnabled(self):
       """
        Flag whether the audio adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any audio adapter. Can only be changed when
        the VM is not running.
       """
       val = self.mgr.getService().IAudioAdapter_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEnabled(self, value):
       """
        Flag whether the audio adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any audio adapter. Can only be changed when
        the VM is not running.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IAudioAdapter_setEnabled(_this, _val)

   def getEnabledIn(self):
       """
        Flag whether the audio adapter is enabled for audio
        input. Only relevant if the adapter is enabled.
       """
       val = self.mgr.getService().IAudioAdapter_getEnabledIn(self.handle)
       return Boolean(self.mgr, val)

   def setEnabledIn(self, value):
       """
        Flag whether the audio adapter is enabled for audio
        input. Only relevant if the adapter is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IAudioAdapter_setEnabledIn(_this, _val)

   def getEnabledOut(self):
       """
        Flag whether the audio adapter is enabled for audio
        output. Only relevant if the adapter is enabled.
       """
       val = self.mgr.getService().IAudioAdapter_getEnabledOut(self.handle)
       return Boolean(self.mgr, val)

   def setEnabledOut(self, value):
       """
        Flag whether the audio adapter is enabled for audio
        output. Only relevant if the adapter is enabled.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IAudioAdapter_setEnabledOut(_this, _val)

   def getAudioController(self):
       """
        The emulated audio controller.
       """
       val = self.mgr.getService().IAudioAdapter_getAudioController(self.handle)
       return AudioControllerType(self.mgr, val)

   def setAudioController(self, value):
       """
        The emulated audio controller.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IAudioAdapter_setAudioController(_this, _val)

   def getAudioCodec(self):
       """
        The exact variant of audio codec hardware presented
        to the guest.
        For HDA and SB16, only one variant is available, but for AC'97,
        there are several.
       """
       val = self.mgr.getService().IAudioAdapter_getAudioCodec(self.handle)
       return AudioCodecType(self.mgr, val)

   def setAudioCodec(self, value):
       """
        The exact variant of audio codec hardware presented
        to the guest.
        For HDA and SB16, only one variant is available, but for AC'97,
        there are several.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IAudioAdapter_setAudioCodec(_this, _val)

   def getAudioDriver(self):
       """
        Audio driver the adapter is connected to. This setting
        can only be changed when the VM is not running.
       """
       val = self.mgr.getService().IAudioAdapter_getAudioDriver(self.handle)
       return AudioDriverType(self.mgr, val)

   def setAudioDriver(self, value):
       """
        Audio driver the adapter is connected to. This setting
        can only be changed when the VM is not running.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IAudioAdapter_setAudioDriver(_this, _val)

   def getPropertiesList(self):
       """
        Array of names of tunable properties, which can be supported by audio driver.
       """
       val = self.mgr.getService().IAudioAdapter_getPropertiesList(self.handle)
       return String(self.mgr, val, True)



   _Attrs_ = {'enabled':[getEnabled,setEnabled,],
              'enabledIn':[getEnabledIn,setEnabledIn,],
              'enabledOut':[getEnabledOut,setEnabledOut,],
              'audioController':[getAudioController,setAudioController,],
              'audioCodec':[getAudioCodec,setAudioCodec,],
              'audioDriver':[getAudioDriver,setAudioDriver,],
              'propertiesList':[getPropertiesList,None]}

class IVRDEServer(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IVRDEServer(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVRDEServer._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVRDEServer._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def setVRDEProperty(self, _arg_key, _arg_value):
       """
        Sets a VRDE specific property string.

        If you pass @c null or empty string as a key @a value, the given @a key
        will be deleted.

      
        :param _arg_key: Name of the key to set.
        :param _arg_value: Value to assign to the key.

       """
   
       req = (self.handle,)
       req += (_arg_key,)
       req += (_arg_value,)
       val = self.mgr.getService().IVRDEServer_setVRDEProperty(*req)
       
       return 

   def getVRDEProperty(self, _arg_key):
       """
        Returns a VRDE specific property string.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

      
        :param _arg_key: Name of the key to get.
        :return: Value of the requested key.
        :rtype: wstring

       """
   
       req = (self.handle,)
       req += (_arg_key,)
       val = self.mgr.getService().IVRDEServer_getVRDEProperty(*req)
       
       return String(self.mgr, val)

   def getEnabled(self):
       """Flag if VRDE server is enabled. """
       val = self.mgr.getService().IVRDEServer_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def setEnabled(self, value):
       """Flag if VRDE server is enabled. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IVRDEServer_setEnabled(_this, _val)

   def getAuthType(self):
       """VRDE authentication method. """
       val = self.mgr.getService().IVRDEServer_getAuthType(self.handle)
       return AuthType(self.mgr, val)

   def setAuthType(self, value):
       """VRDE authentication method. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IVRDEServer_setAuthType(_this, _val)

   def getAuthTimeout(self):
       """Timeout for guest authentication. Milliseconds. """
       val = self.mgr.getService().IVRDEServer_getAuthTimeout(self.handle)
       return UnsignedInt(self.mgr, val)

   def setAuthTimeout(self, value):
       """Timeout for guest authentication. Milliseconds. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IVRDEServer_setAuthTimeout(_this, _val)

   def getAllowMultiConnection(self):
       """
        Flag whether multiple simultaneous connections to the VM are permitted.
        Note that this will be replaced by a more powerful mechanism in the future.
       """
       val = self.mgr.getService().IVRDEServer_getAllowMultiConnection(self.handle)
       return Boolean(self.mgr, val)

   def setAllowMultiConnection(self, value):
       """
        Flag whether multiple simultaneous connections to the VM are permitted.
        Note that this will be replaced by a more powerful mechanism in the future.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IVRDEServer_setAllowMultiConnection(_this, _val)

   def getReuseSingleConnection(self):
       """
        Flag whether the existing connection must be dropped and a new connection
        must be established by the VRDE server, when a new client connects in single
        connection mode.
       """
       val = self.mgr.getService().IVRDEServer_getReuseSingleConnection(self.handle)
       return Boolean(self.mgr, val)

   def setReuseSingleConnection(self, value):
       """
        Flag whether the existing connection must be dropped and a new connection
        must be established by the VRDE server, when a new client connects in single
        connection mode.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IVRDEServer_setReuseSingleConnection(_this, _val)

   def getVRDEExtPack(self):
       """
        The name of Extension Pack providing VRDE for this VM. Overrides
        ISystemProperties::defaultVRDEExtPack.
       """
       val = self.mgr.getService().IVRDEServer_getVRDEExtPack(self.handle)
       return String(self.mgr, val)

   def setVRDEExtPack(self, value):
       """
        The name of Extension Pack providing VRDE for this VM. Overrides
        ISystemProperties::defaultVRDEExtPack.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IVRDEServer_setVRDEExtPack(_this, _val)

   def getAuthLibrary(self):
       """
        Library used for authentication of RDP clients by this VM. Overrides
        ISystemProperties::VRDEAuthLibrary.
       """
       val = self.mgr.getService().IVRDEServer_getAuthLibrary(self.handle)
       return String(self.mgr, val)

   def setAuthLibrary(self, value):
       """
        Library used for authentication of RDP clients by this VM. Overrides
        ISystemProperties::VRDEAuthLibrary.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IVRDEServer_setAuthLibrary(_this, _val)

   def getVRDEProperties(self):
       """
        Array of names of properties, which are supported by this VRDE server.
       """
       val = self.mgr.getService().IVRDEServer_getVRDEProperties(self.handle)
       return String(self.mgr, val, True)



   _Attrs_ = {'enabled':[getEnabled,setEnabled,],
              'authType':[getAuthType,setAuthType,],
              'authTimeout':[getAuthTimeout,setAuthTimeout,],
              'allowMultiConnection':[getAllowMultiConnection,setAllowMultiConnection,],
              'reuseSingleConnection':[getReuseSingleConnection,setReuseSingleConnection,],
              'VRDEExtPack':[getVRDEExtPack,setVRDEExtPack,],
              'authLibrary':[getAuthLibrary,setAuthLibrary,],
              'VRDEProperties':[getVRDEProperties,None]}

class ISharedFolder(IUnknown):
   """
      The ISharedFolder interface represents a folder in the host computer's
      file system accessible from the guest OS running inside a virtual
      machine using an associated logical name.

      There are three types of shared folders:
        * Global (IVirtualBox::sharedFolders), shared
        folders available to all virtual machines.
          * Permanent (IMachine::sharedFolders),
        VM-specific shared folders available to the given virtual machine at
        startup.
          * Transient (IConsole::sharedFolders),
        VM-specific shared folders created in the session context (for
        example, when the virtual machine is running) and automatically
        discarded when the session is closed (the VM is powered off).

      Logical names of shared folders must be unique within the given scope
      (global, permanent or transient). However, they do not need to be unique
      across scopes. In this case, the definition of the shared folder in a
      more specific scope takes precedence over definitions in all other
      scopes. The order of precedence is (more specific to more general):
        * Transient definitions
          * Permanent definitions
          * Global definitions

        

      For example, if MyMachine has a shared folder named
      C_DRIVE (that points to C:\\), then creating a
      transient shared folder named C_DRIVE (that points
      to C:\\\\WINDOWS) will change the definition
      of C_DRIVE in the guest OS so
      that \\\\VBOXSVR\\C_DRIVE will give access
      to C:\\WINDOWS instead of C:\\ on the host
      PC. Removing the transient shared folder C_DRIVE will restore
      the previous (permanent) definition of C_DRIVE that points
      to C:\\ if it still exists.

      Note that permanent and transient shared folders of different machines
      are in different name spaces, so they don't overlap and don't need to
      have unique logical names.

      
        .. note:: 
        Global shared folders are not implemented in the current version of the
        product.
      
      Interface ID:
        {9622225A-5409-414B-BD16-77DF7BA3451E}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISharedFolder(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISharedFolder._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISharedFolder._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getName(self):
       """Logical name of the shared folder. """
       val = self.mgr.getService().ISharedFolder_getName(self.handle)
       return String(self.mgr, val)

   def getHostPath(self):
       """Full path to the shared folder in the host file system. """
       val = self.mgr.getService().ISharedFolder_getHostPath(self.handle)
       return String(self.mgr, val)

   def getAccessible(self):
       """
        Whether the folder defined by the host path is currently
        accessible or not.

        For example, the folder can be inaccessible if it is placed
        on the network share that is not available by the time
        this property is read.
       """
       val = self.mgr.getService().ISharedFolder_getAccessible(self.handle)
       return Boolean(self.mgr, val)

   def getWritable(self):
       """
        Whether the folder defined by the host path is writable or
        not.
       """
       val = self.mgr.getService().ISharedFolder_getWritable(self.handle)
       return Boolean(self.mgr, val)

   def setWritable(self, value):
       """
        Whether the folder defined by the host path is writable or
        not.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISharedFolder_setWritable(_this, _val)

   def getAutoMount(self):
       """
        Whether the folder gets automatically mounted by the guest or not.
       """
       val = self.mgr.getService().ISharedFolder_getAutoMount(self.handle)
       return Boolean(self.mgr, val)

   def setAutoMount(self, value):
       """
        Whether the folder gets automatically mounted by the guest or not.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISharedFolder_setAutoMount(_this, _val)

   def getAutoMountPoint(self):
       """
        Desired mount point in the guest for automatically mounting the folder
        when ISharedFolder::autoMount is set.  For Windows and
        OS/2 guests this should be a drive letter, while other guests it should
        be a absolute directory.  It is possible to combine the two, e.g.
        "T:/mnt/testrsrc" will be attached to "T:" by windows and OS/2 while
        the unixy guests will mount it at "/mnt/testrsrc".

        When empty the guest will choose a mount point.  The guest may do so
        too should the specified mount point be in use or otherwise unusable.
       """
       val = self.mgr.getService().ISharedFolder_getAutoMountPoint(self.handle)
       return String(self.mgr, val)

   def setAutoMountPoint(self, value):
       """
        Desired mount point in the guest for automatically mounting the folder
        when ISharedFolder::autoMount is set.  For Windows and
        OS/2 guests this should be a drive letter, while other guests it should
        be a absolute directory.  It is possible to combine the two, e.g.
        "T:/mnt/testrsrc" will be attached to "T:" by windows and OS/2 while
        the unixy guests will mount it at "/mnt/testrsrc".

        When empty the guest will choose a mount point.  The guest may do so
        too should the specified mount point be in use or otherwise unusable.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISharedFolder_setAutoMountPoint(_this, _val)

   def getLastAccessError(self):
       """
        Text message that represents the result of the last accessibility
        check.

        Accessibility checks are performed each time the #accessible
        attribute is read. An empty string is returned if the last
        accessibility check was successful. A non-empty string indicates a
        failure and should normally describe a reason of the failure (for
        example, a file read error).
       """
       val = self.mgr.getService().ISharedFolder_getLastAccessError(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'name':[getName,None],
              'hostPath':[getHostPath,None],
              'accessible':[getAccessible,None],
              'writable':[getWritable,setWritable,],
              'autoMount':[getAutoMount,setAutoMount,],
              'autoMountPoint':[getAutoMountPoint,setAutoMountPoint,],
              'lastAccessError':[getLastAccessError,None]}

class ISession(IUnknown):
   """
      The ISession interface represents a client process and allows for locking
      virtual machines (represented by IMachine objects) to prevent conflicting
      changes to the machine.

      Any caller wishing to manipulate a virtual machine needs to create a session
      object first, which lives in its own process space. Such session objects are
      then associated with ::IMachine objects living in the VirtualBox
      server process to coordinate such changes.

      There are two typical scenarios in which sessions are used:

        * To alter machine settings or control a running virtual machine, one
          needs to lock a machine for a given session (client process) by calling
          IMachine::lockMachine.

          Whereas multiple sessions may control a running virtual machine, only
          one process can obtain a write lock on the machine to prevent conflicting
          changes. A write lock is also needed if a process wants to actually run a
          virtual machine in its own context, such as the VirtualBox GUI or
          VBoxHeadless front-ends. They must also lock a machine for their own
          sessions before they are allowed to power up the virtual machine.

          As a result, no machine settings can be altered while another process is
          already using it, either because that process is modifying machine settings
          or because the machine is running.
        
          * 
          To start a VM using one of the existing VirtualBox front-ends (e.g. the
          VirtualBox GUI or VBoxHeadless), one would use
          IMachine::launchVMProcess, which also takes a session object
          as its first parameter. This session then identifies the caller and lets the
          caller control the started machine (for example, pause machine execution or
          power it down) as well as be notified about machine execution state changes.
        

      How sessions objects are created in a client process depends on whether you use
      the Main API via COM or via the webservice:

        * When using the COM API directly, an object of the Session class from the
          VirtualBox type library needs to be created. In regular COM C++ client code,
          this can be done by calling createLocalObject(), a standard COM API.
          This object will then act as a local session object in further calls to open
          a session.
        
          * In the webservice, the session manager (IWebsessionManager) instead creates
          a session object automatically whenever IWebsessionManager::logon
          is called. A managed object reference to that session object can be retrieved by
          calling IWebsessionManager::getSessionObject.
        
      Interface ID:
        {C0447716-FF5A-4795-B57A-ECD5FFFA18A4}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISession(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISession._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISession._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def unlockMachine(self):
       """
        Unlocks a machine that was previously locked for the current session.

        Calling this method is required every time a machine has been locked
        for a particular session using the IMachine::launchVMProcess
        or IMachine::lockMachine calls. Otherwise the state of
        the machine will be set to ::MachineState_Aborted on the
        server, and changes made to the machine settings will be lost.

        Generally, it is recommended to unlock all machines explicitly
        before terminating the application (regardless of the reason for
        the termination).

        

        Expected result codes:
        E_UNEXPECTED
          Session is not locked.
        
        .. note:: 
          Do not expect the session state (ISession::state
          to return to "Unlocked" immediately after you invoke this method,
          particularly if you have started a new VM process. The session
          state will automatically return to "Unlocked" once the VM is no
          longer executing, which can of course take a very long time.
        
       """
   
       req = (self.handle,)
       val = self.mgr.getService().ISession_unlockMachine(*req)
       
       return 

   def getState(self):
       """Current state of this session. """
       val = self.mgr.getService().ISession_getState(self.handle)
       return SessionState(self.mgr, val)

   def getType(self):
       """
        Type of this session. The value of this attribute is valid only
        if the session currently has a machine locked (i.e. its
        #state is Locked), otherwise an error will be returned.
       """
       val = self.mgr.getService().ISession_getType(self.handle)
       return SessionType(self.mgr, val)

   def getName(self):
       """
        Name of this session. Important only for VM sessions, otherwise it
        it will be remembered, but not used for anything significant (and can
        be left at the empty string which is the default). The value can only
        be changed when the session state is SessionState_Unlocked. Make sure
        that you use a descriptive name which does not conflict with the VM
        process session names: "GUI/Qt", "GUI/SDL" and "headless".
       """
       val = self.mgr.getService().ISession_getName(self.handle)
       return String(self.mgr, val)

   def setName(self, value):
       """
        Name of this session. Important only for VM sessions, otherwise it
        it will be remembered, but not used for anything significant (and can
        be left at the empty string which is the default). The value can only
        be changed when the session state is SessionState_Unlocked. Make sure
        that you use a descriptive name which does not conflict with the VM
        process session names: "GUI/Qt", "GUI/SDL" and "headless".
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ISession_setName(_this, _val)

   def getMachine(self):
       """Machine object associated with this session. """
       val = self.mgr.getService().ISession_getMachine(self.handle)
       return IMachine(self.mgr, val)

   def getConsole(self):
       """Console object associated with this session. Only sessions
      which locked the machine for a VM process have a non-null console. """
       val = self.mgr.getService().ISession_getConsole(self.handle)
       return IConsole(self.mgr, val)



   _Attrs_ = {'state':[getState,None],
              'type':[getType,None],
              'name':[getName,setName,],
              'machine':[getMachine,None],
              'console':[getConsole,None]}

class IStorageController(IUnknown):
   """
        Represents a storage controller that is attached to a virtual machine
        (::IMachine). Just as drives (hard disks, DVDs, FDs) are
        attached to storage controllers in a real computer, virtual drives
        (represented by ::IMediumAttachment) are attached to virtual
        storage controllers, represented by this interface.

        As opposed to physical hardware, VirtualBox has a very generic concept
        of a storage controller, and for purposes of the Main API, all virtual
        storage is attached to virtual machines via instances of this interface.
        There are five types of such virtual storage controllers: IDE, SCSI, SATA,
        SAS and Floppy (see #bus). Depending on which of these four
        is used, certain sub-types may be available and can be selected in
        #controllerType.

        Depending on these settings, the guest operating system might see
        significantly different virtual hardware.
    
      Interface ID:
        {DDCA7247-BF98-47FB-AB2F-B5177533F493}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IStorageController(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IStorageController._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IStorageController._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getName(self):
       """
        Name of the storage controller, as originally specified with
        IMachine::addStorageController. This then uniquely
        identifies this controller with other method calls such as
        IMachine::attachDevice and IMachine::mountMedium.
       """
       val = self.mgr.getService().IStorageController_getName(self.handle)
       return String(self.mgr, val)

   def setName(self, value):
       """
        Name of the storage controller, as originally specified with
        IMachine::addStorageController. This then uniquely
        identifies this controller with other method calls such as
        IMachine::attachDevice and IMachine::mountMedium.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IStorageController_setName(_this, _val)

   def getMaxDevicesPerPortCount(self):
       """
        Maximum number of devices which can be attached to one port.
       """
       val = self.mgr.getService().IStorageController_getMaxDevicesPerPortCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMinPortCount(self):
       """
        Minimum number of ports that IStorageController::portCount can be set to.
       """
       val = self.mgr.getService().IStorageController_getMinPortCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMaxPortCount(self):
       """
        Maximum number of ports that IStorageController::portCount can be set to.
       """
       val = self.mgr.getService().IStorageController_getMaxPortCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getInstance(self):
       """
        The instance number of the device in the running VM.
       """
       val = self.mgr.getService().IStorageController_getInstance(self.handle)
       return UnsignedInt(self.mgr, val)

   def setInstance(self, value):
       """
        The instance number of the device in the running VM.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IStorageController_setInstance(_this, _val)

   def getPortCount(self):
       """
        The number of currently usable ports on the controller.
        The minimum and maximum number of ports for one controller are
        stored in IStorageController::minPortCount
        and IStorageController::maxPortCount.
       """
       val = self.mgr.getService().IStorageController_getPortCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def setPortCount(self, value):
       """
        The number of currently usable ports on the controller.
        The minimum and maximum number of ports for one controller are
        stored in IStorageController::minPortCount
        and IStorageController::maxPortCount.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IStorageController_setPortCount(_this, _val)

   def getBus(self):
       """
        The bus type of the storage controller (IDE, SATA, SCSI, SAS or Floppy).
       """
       val = self.mgr.getService().IStorageController_getBus(self.handle)
       return StorageBus(self.mgr, val)

   def getControllerType(self):
       """
        The exact variant of storage controller hardware presented
        to the guest.
        Depending on this value, VirtualBox will provide a different
        virtual storage controller hardware to the guest.
        For SATA, SAS and floppy controllers, only one variant is
        available, but for IDE and SCSI, there are several.

        For SCSI controllers, the default type is LsiLogic.
       """
       val = self.mgr.getService().IStorageController_getControllerType(self.handle)
       return StorageControllerType(self.mgr, val)

   def setControllerType(self, value):
       """
        The exact variant of storage controller hardware presented
        to the guest.
        Depending on this value, VirtualBox will provide a different
        virtual storage controller hardware to the guest.
        For SATA, SAS and floppy controllers, only one variant is
        available, but for IDE and SCSI, there are several.

        For SCSI controllers, the default type is LsiLogic.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IStorageController_setControllerType(_this, _val)

   def getUseHostIOCache(self):
       """
        If true, the storage controller emulation will use a dedicated I/O thread, enable the host I/O
        caches and use synchronous file APIs on the host. This was the only option in the API before
        VirtualBox 3.2 and is still the default for IDE controllers.

        If false, the host I/O cache will be disabled for image files attached to this storage controller.
        Instead, the storage controller emulation will use asynchronous I/O APIs on the host. This makes
        it possible to turn off the host I/O caches because the emulation can handle unaligned access to
        the file. This should be used on OS X and Linux hosts if a high I/O load is expected or many
        virtual machines are running at the same time to prevent I/O cache related hangs.
        This option new with the API of VirtualBox 3.2 and is now the default for non-IDE storage controllers.
       """
       val = self.mgr.getService().IStorageController_getUseHostIOCache(self.handle)
       return Boolean(self.mgr, val)

   def setUseHostIOCache(self, value):
       """
        If true, the storage controller emulation will use a dedicated I/O thread, enable the host I/O
        caches and use synchronous file APIs on the host. This was the only option in the API before
        VirtualBox 3.2 and is still the default for IDE controllers.

        If false, the host I/O cache will be disabled for image files attached to this storage controller.
        Instead, the storage controller emulation will use asynchronous I/O APIs on the host. This makes
        it possible to turn off the host I/O caches because the emulation can handle unaligned access to
        the file. This should be used on OS X and Linux hosts if a high I/O load is expected or many
        virtual machines are running at the same time to prevent I/O cache related hangs.
        This option new with the API of VirtualBox 3.2 and is now the default for non-IDE storage controllers.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IStorageController_setUseHostIOCache(_this, _val)

   def getBootable(self):
       """
        Returns whether it is possible to boot from disks attached to this controller.
       """
       val = self.mgr.getService().IStorageController_getBootable(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'name':[getName,setName,],
              'maxDevicesPerPortCount':[getMaxDevicesPerPortCount,None],
              'minPortCount':[getMinPortCount,None],
              'maxPortCount':[getMaxPortCount,None],
              'instance':[getInstance,setInstance,],
              'portCount':[getPortCount,setPortCount,],
              'bus':[getBus,None],
              'controllerType':[getControllerType,setControllerType,],
              'useHostIOCache':[getUseHostIOCache,setUseHostIOCache,],
              'bootable':[getBootable,None]}

class IManagedObjectRef(IUnknown):
   """
      Managed object reference.

      Only within the webservice, a managed object reference (which is really
      an opaque number) allows a webservice client to address an object
      that lives in the address space of the webservice server.

      Behind each managed object reference, there is a COM object that lives
      in the webservice server's address space. The COM object is not freed
      until the managed object reference is released, either by an explicit
      call to IManagedObjectRef::release or by logging off from
      the webservice (IWebsessionManager::logoff), which releases
      all objects created during the webservice session.

      Whenever a method call of the VirtualBox API returns a COM object, the
      webservice representation of that method will instead return a
      managed object reference, which can then be used to invoke methods
      on that object.
    
      Interface ID:
        {9474D09D-2313-46DE-B568-A42B8718E8ED}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IManagedObjectRef(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IManagedObjectRef._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IManagedObjectRef._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getInterfaceName(self):
       """
        Returns the name of the interface that this managed object represents,
        for example, "IMachine", as a string.
      
        :return: 
        :rtype: wstring

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IManagedObjectRef_getInterfaceName(*req)
       
       return String(self.mgr, val)

   def release(self):
       """
        Releases this managed object reference and frees the resources that
        were allocated for it in the webservice server process. After calling
        this method, the identifier of the reference can no longer be used.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IManagedObjectRef_release(*req)
       
       return 



   _Attrs_ = {}

class IWebsessionManager(IUnknown):
   """
      Websession manager. This provides essential services
      to webservice clients.
    
      Interface ID:
        {930C8FEA-453A-4A65-ACA9-19ED9A872F88}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IWebsessionManager(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IWebsessionManager._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IWebsessionManager._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def logon(self, _arg_username, _arg_password):
       """
        Logs a new client onto the webservice and returns a managed object reference to
        the IVirtualBox instance, which the client can then use as a basis to further
        queries, since all calls to the VirtualBox API are based on the IVirtualBox
        interface, in one way or the other.
      
        :param _arg_username: 
        :param _arg_password: 
        :return: 
        :rtype: IVirtualBox

       """
   
       req = ()
       req += (_arg_username,)
       req += (_arg_password,)
       val = self.mgr.getService().IWebsessionManager_logon(*req)
       
       return IVirtualBox(self.mgr, val)

   def getSessionObject(self, _arg_refIVirtualBox):
       """
        Returns a managed object reference to a new ISession object for every
        call to this method.

        
        :param _arg_refIVirtualBox: 
        :return: 
        :rtype: ISession

       """
   
       req = ()
       req += (_arg_refIVirtualBox,)
       val = self.mgr.getService().IWebsessionManager_getSessionObject(*req)
       
       return ISession(self.mgr, val)

   def logoff(self, _arg_refIVirtualBox):
       """
        Logs off the client who has previously logged on with IWebsessionManager::logon
        and destroys all resources associated with the websession (most
        importantly, all managed objects created in the server while the
        websession was active).
      
        :param _arg_refIVirtualBox: 

       """
   
       req = ()
       req += (_arg_refIVirtualBox,)
       val = self.mgr.getService().IWebsessionManager_logoff(*req)
       
       return 



   _Attrs_ = {}

class IPerformanceMetric(IUnknown):
   """
      The IPerformanceMetric interface represents parameters of the given
      performance metric.
    
      Interface ID:
        {81314D14-FD1C-411A-95C5-E9BB1414E632}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IPerformanceMetric(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IPerformanceMetric._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IPerformanceMetric._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMetricName(self):
       """
        Name of the metric.
       """
       val = self.mgr.getService().IPerformanceMetric_getMetricName(self.handle)
       return String(self.mgr, val)

   def getObject(self):
       """
        Object this metric belongs to.
       """
       val = self.mgr.getService().IPerformanceMetric_getObject(self.handle)
       return IUnknown(self.mgr, val)

   def getDescription(self):
       """
        Textual description of the metric.
       """
       val = self.mgr.getService().IPerformanceMetric_getDescription(self.handle)
       return String(self.mgr, val)

   def getPeriod(self):
       """
        Time interval between samples, measured in seconds.
       """
       val = self.mgr.getService().IPerformanceMetric_getPeriod(self.handle)
       return UnsignedInt(self.mgr, val)

   def getCount(self):
       """
        Number of recent samples retained by the performance collector for this
        metric.

        When the collected sample count exceeds this number, older samples
        are discarded.
       """
       val = self.mgr.getService().IPerformanceMetric_getCount(self.handle)
       return UnsignedInt(self.mgr, val)

   def getUnit(self):
       """
        Unit of measurement.
       """
       val = self.mgr.getService().IPerformanceMetric_getUnit(self.handle)
       return String(self.mgr, val)

   def getMinimumValue(self):
       """
        Minimum possible value of this metric.
       """
       val = self.mgr.getService().IPerformanceMetric_getMinimumValue(self.handle)
       return Int(self.mgr, val)

   def getMaximumValue(self):
       """
        Maximum possible value of this metric.
       """
       val = self.mgr.getService().IPerformanceMetric_getMaximumValue(self.handle)
       return Int(self.mgr, val)



   _Attrs_ = {'metricName':[getMetricName,None],
              'object':[getObject,None],
              'description':[getDescription,None],
              'period':[getPeriod,None],
              'count':[getCount,None],
              'unit':[getUnit,None],
              'minimumValue':[getMinimumValue,None],
              'maximumValue':[getMaximumValue,None]}

class IPerformanceCollector(IUnknown):
   """
      The IPerformanceCollector interface represents a service that collects
      and stores performance metrics data.

      Performance metrics are associated with objects of interfaces like IHost
      and IMachine. Each object has a distinct set of performance metrics. The
      set can be obtained with IPerformanceCollector::getMetrics.

      Metric data is collected at the specified intervals and is retained
      internally. The interval and the number of retained samples can be set
      with IPerformanceCollector::setupMetrics. Both metric data
      and collection settings are not persistent, they are discarded as soon as
      VBoxSVC process terminates. Moreover, metric settings and data associated
      with a particular VM only exist while VM is running. They disappear as
      soon as VM shuts down. It is not possible to set up metrics for machines
      that are powered off. One needs to start VM first, then set up metric
      collection parameters.

      Metrics are organized hierarchically, with each level separated by a
      slash (/) character. Generally, the scheme for metric names is like this:

      Category/Metric[/SubMetric][:aggregation]

      "Category/Metric" together form the base metric name. A base metric is
      the smallest unit for which a sampling interval and the number of
      retained samples can be set. Only base metrics can be enabled and
      disabled. All sub-metrics are collected when their base metric is
      collected. Collected values for any set of sub-metrics can be queried
      with IPerformanceCollector::queryMetricsData.

      For example "CPU/Load/User:avg" metric name stands for the "CPU"
      category, "Load" metric, "User" submetric, "average" aggregate. An
      aggregate function is computed over all retained data. Valid aggregate
      functions are:

        * avg -- average
          * min -- minimum
          * max -- maximum

      When setting up metric parameters, querying metric data, enabling or
      disabling metrics wildcards can be used in metric names to specify a
      subset of metrics. For example, to select all CPU-related metrics
      use CPU/*, all averages can be queried using *:avg and
      so on. To query metric values without aggregates *: can be used.

      The valid names for base metrics are:

        * CPU/Load
          * CPU/MHz
          * RAM/Usage
          * RAM/VMM

      The general sequence for collecting and retrieving the metrics is:
        * 
          Obtain an instance of IPerformanceCollector with
          IVirtualBox::performanceCollector
          * 
          Allocate and populate an array with references to objects the metrics
          will be collected for. Use references to IHost and IMachine objects.
        
          * 
          Allocate and populate an array with base metric names the data will
          be collected for.
        
          * 
          Call IPerformanceCollector::setupMetrics. From now on
          the metric data will be collected and stored.
        
          * 
          Wait for the data to get collected.
        
          * 
          Allocate and populate an array with references to objects the metric
          values will be queried for. You can re-use the object array used for
          setting base metrics.
        
          * 
          Allocate and populate an array with metric names the data will be
          collected for. Note that metric names differ from base metric names.
        
          * 
          Call IPerformanceCollector::queryMetricsData. The data
          that have been collected so far are returned. Note that the values
          are still retained internally and data collection continues.
        

      For an example of usage refer to the following files in VirtualBox SDK:
        * 
          Java: bindings/webservice/java/jax-ws/samples/metrictest.java
          * 
          Python: bindings/xpcom/python/sample/shellcommon.py
      Interface ID:
        {B14290AD-CD54-400C-B858-797BCB82570E}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IPerformanceCollector(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IPerformanceCollector._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IPerformanceCollector._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMetrics(self, _arg_metricNames, _arg_objects):
       """
        Returns parameters of specified metrics for a set of objects.
        
        :param _arg_metricNames: Metric name filter. Currently, only a comma-separated list of metrics is supported.
        :param _arg_objects: Set of objects to return metric parameters for.
        :return: Array of returned metric parameters.
        :rtype: List[IPerformanceMetric]

        .. note:: 
          @c Null metrics array means all metrics. @c Null object array means
          all existing objects.
        
       """
   
       req = (self.handle,)
       req += (_arg_metricNames,)
       req += (_arg_objects,)
       val = self.mgr.getService().IPerformanceCollector_getMetrics(*req)
       
       return IPerformanceMetric(self.mgr, val, True)

   def setupMetrics(self, _arg_metricNames, _arg_objects, _arg_period, _arg_count):
       """
        Sets parameters of specified base metrics for a set of objects. Returns
        an array of ::IPerformanceMetric describing the metrics
        have been affected.
        
        :param _arg_metricNames: Metric name filter. Comma-separated list of metrics with wildcard support.
        :param _arg_objects: Set of objects to setup metric parameters for.
        :param _arg_period: Time interval in seconds between two consecutive samples of performance data.
        :param _arg_count: Number of samples to retain in performance data history. Older samples get discarded.
        :return: Array of metrics that have been modified by the call to this method.
        :rtype: List[IPerformanceMetric]

        .. note:: 
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        
       """
   
       req = (self.handle,)
       req += (_arg_metricNames,)
       req += (_arg_objects,)
       req += (_arg_period,)
       req += (_arg_count,)
       val = self.mgr.getService().IPerformanceCollector_setupMetrics(*req)
       
       return IPerformanceMetric(self.mgr, val, True)

   def enableMetrics(self, _arg_metricNames, _arg_objects):
       """
        Turns on collecting specified base metrics. Returns an array of
        ::IPerformanceMetric describing the metrics have been
        affected.
        
        :param _arg_metricNames: Metric name filter. Comma-separated list of metrics with wildcard support.
        :param _arg_objects: Set of objects to enable metrics for.
        :return: Array of metrics that have been modified by the call to this method.
        :rtype: List[IPerformanceMetric]

        .. note:: 
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        
       """
   
       req = (self.handle,)
       req += (_arg_metricNames,)
       req += (_arg_objects,)
       val = self.mgr.getService().IPerformanceCollector_enableMetrics(*req)
       
       return IPerformanceMetric(self.mgr, val, True)

   def disableMetrics(self, _arg_metricNames, _arg_objects):
       """
        Turns off collecting specified base metrics. Returns an array of
        ::IPerformanceMetric describing the metrics have been
        affected.
        
        :param _arg_metricNames: Metric name filter. Comma-separated list of metrics with wildcard support.
        :param _arg_objects: Set of objects to disable metrics for.
        :return: Array of metrics that have been modified by the call to this method.
        :rtype: List[IPerformanceMetric]

        .. note:: 
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        
       """
   
       req = (self.handle,)
       req += (_arg_metricNames,)
       req += (_arg_objects,)
       val = self.mgr.getService().IPerformanceCollector_disableMetrics(*req)
       
       return IPerformanceMetric(self.mgr, val, True)

   def queryMetricsData(self, _arg_metricNames, _arg_objects):
       """
        Queries collected metrics data for a set of objects.

        The data itself and related metric information are returned in seven
        parallel and one flattened array of arrays. Elements of
        returnMetricNames, returnObjects, returnUnits, returnScales,
        returnSequenceNumbers, returnDataIndices and returnDataLengths with
        the same index describe one set of values corresponding to a single
        metric.

        The returnData parameter is a flattened array of arrays. Each
        start and length of a sub-array is indicated by
        returnDataIndices and returnDataLengths. The first
        value for metric metricNames[i] is at
        returnData[returnIndices[i]].

        
        :param _arg_metricNames: Metric name filter. Comma-separated list of metrics with wildcard support.
        :param _arg_objects: Set of objects to query metrics for.







        :return: Flattened array of all metric data containing sequences of values for each metric.
        :rtype: List[long]

        .. note:: 
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        
        .. note:: 
          Data collection continues behind the scenes after call to
          @c queryMetricsData. The return data can be seen as the snapshot of
          the current state at the time of @c queryMetricsData call. The
          internally kept metric values are not cleared by the call. This
          allows querying different subsets of metrics or aggregates with
          subsequent calls. If periodic querying is needed it is highly
          suggested to query the values with @c interval*count period to avoid
          confusion. This way a completely new set of data values will be
          provided by each query.
        
       """
   
       req = (self.handle,)
       req += (_arg_metricNames,)
       req += (_arg_objects,)
       val = self.mgr.getService().IPerformanceCollector_queryMetricsData(*req)
       
       return Int(self.mgr,val["returnval"], True), String(self.mgr,val["returnMetricNames"], True), IUnknown(self.mgr,val["returnObjects"], True), String(self.mgr,val["returnUnits"], True), UnsignedInt(self.mgr,val["returnScales"], True), UnsignedInt(self.mgr,val["returnSequenceNumbers"], True), UnsignedInt(self.mgr,val["returnDataIndices"], True), UnsignedInt(self.mgr,val["returnDataLengths"], True)

   def getMetricNames(self):
       """
        Array of unique names of metrics.

        This array represents all metrics supported by the performance
        collector. Individual objects do not necessarily support all of them.
        IPerformanceCollector::getMetrics can be used to get the
        list of supported metrics for a particular object.
       """
       val = self.mgr.getService().IPerformanceCollector_getMetricNames(self.handle)
       return String(self.mgr, val, True)



   _Attrs_ = {'metricNames':[getMetricNames,None]}

class INATEngine(IUnknown):
   """Interface for managing a NAT engine which is used with a virtual machine. This
      allows for changing NAT behavior such as port-forwarding rules. This interface is
      used in the INetworkAdapter::NATEngine attribute.
      Interface ID:
        {8FAEF61E-6E15-4F71-A6A5-94E707FAFBCC}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INATEngine(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATEngine._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATEngine._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def setNetworkSettings(self, _arg_mtu, _arg_sockSnd, _arg_sockRcv, _arg_TcpWndSnd, _arg_TcpWndRcv):
       """Sets network configuration of the NAT engine.
        :param _arg_mtu: MTU (maximum transmission unit) of the NAT engine in bytes.
        :param _arg_sockSnd: Capacity of the socket send buffer in bytes when creating a new socket.
        :param _arg_sockRcv: Capacity of the socket receive buffer in bytes when creating a new socket.
        :param _arg_TcpWndSnd: Initial size of the NAT engine's sending TCP window in bytes when establishing a new TCP connection.
        :param _arg_TcpWndRcv: Initial size of the NAT engine's receiving TCP window in bytes when establishing a new TCP connection.

       """
   
       req = (self.handle,)
       req += (_arg_mtu,)
       req += (_arg_sockSnd,)
       req += (_arg_sockRcv,)
       req += (_arg_TcpWndSnd,)
       req += (_arg_TcpWndRcv,)
       val = self.mgr.getService().INATEngine_setNetworkSettings(*req)
       
       return 

   def getNetworkSettings(self):
       """Returns network configuration of NAT engine. See #setNetworkSettings
        for parameter descriptions.






       """
   
       req = (self.handle,)
       val = self.mgr.getService().INATEngine_getNetworkSettings(*req)
       
       return UnsignedInt(self.mgr,val["mtu"]), UnsignedInt(self.mgr,val["sockSnd"]), UnsignedInt(self.mgr,val["sockRcv"]), UnsignedInt(self.mgr,val["TcpWndSnd"]), UnsignedInt(self.mgr,val["TcpWndRcv"])

   def addRedirect(self, _arg_name, _arg_proto, _arg_hostIP, _arg_hostPort, _arg_guestIP, _arg_guestPort):
       """Adds a new NAT port-forwarding rule.
        :param _arg_name: The name of the rule. An empty name is acceptable, in which case the NAT engine auto-generates one using the other parameters.
        :param _arg_proto: Protocol handled with the rule.
        :param _arg_hostIP: IP of the host interface to which the rule should apply. An empty ip address is acceptable, in which case the NAT engine binds the handling socket to any interface.
        :param _arg_hostPort: The port number to listen on.
        :param _arg_guestIP: The IP address of the guest which the NAT engine will forward matching packets to. An empty IP address is acceptable, in which case the NAT engine will forward packets to the first DHCP lease (x.x.x.15).
        :param _arg_guestPort: The port number to forward.

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_proto,)
       req += (_arg_hostIP,)
       req += (_arg_hostPort,)
       req += (_arg_guestIP,)
       req += (_arg_guestPort,)
       val = self.mgr.getService().INATEngine_addRedirect(*req)
       
       return 

   def removeRedirect(self, _arg_name):
       """Removes a port-forwarding rule that was previously registered.
        :param _arg_name: The name of the rule to delete.

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().INATEngine_removeRedirect(*req)
       
       return 

   def getNetwork(self):
       """The network attribute of the NAT engine (the same value is used with built-in
        DHCP server to fill corresponding fields of DHCP leases). """
       val = self.mgr.getService().INATEngine_getNetwork(self.handle)
       return String(self.mgr, val)

   def setNetwork(self, value):
       """The network attribute of the NAT engine (the same value is used with built-in
        DHCP server to fill corresponding fields of DHCP leases). """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATEngine_setNetwork(_this, _val)

   def getHostIP(self):
       """IP of host interface to bind all opened sockets to.
          
        .. note:: Changing this does not change binding of port forwarding. """
       val = self.mgr.getService().INATEngine_getHostIP(self.handle)
       return String(self.mgr, val)

   def setHostIP(self, value):
       """IP of host interface to bind all opened sockets to.
          
        .. note:: Changing this does not change binding of port forwarding. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATEngine_setHostIP(_this, _val)

   def getTFTPPrefix(self):
       """TFTP prefix attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases. """
       val = self.mgr.getService().INATEngine_getTFTPPrefix(self.handle)
       return String(self.mgr, val)

   def setTFTPPrefix(self, value):
       """TFTP prefix attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATEngine_setTFTPPrefix(_this, _val)

   def getTFTPBootFile(self):
       """TFTP boot file attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases. """
       val = self.mgr.getService().INATEngine_getTFTPBootFile(self.handle)
       return String(self.mgr, val)

   def setTFTPBootFile(self, value):
       """TFTP boot file attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATEngine_setTFTPBootFile(_this, _val)

   def getTFTPNextServer(self):
       """TFTP server attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases.
        
        .. note:: The preferred form is IPv4 addresses. """
       val = self.mgr.getService().INATEngine_getTFTPNextServer(self.handle)
       return String(self.mgr, val)

   def setTFTPNextServer(self, value):
       """TFTP server attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases.
        
        .. note:: The preferred form is IPv4 addresses. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATEngine_setTFTPNextServer(_this, _val)

   def getAliasMode(self):
       """ """
       val = self.mgr.getService().INATEngine_getAliasMode(self.handle)
       return UnsignedInt(self.mgr, val)

   def setAliasMode(self, value):
       """ """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATEngine_setAliasMode(_this, _val)

   def getDNSPassDomain(self):
       """Whether the DHCP server should pass the DNS domain used by the host. """
       val = self.mgr.getService().INATEngine_getDNSPassDomain(self.handle)
       return Boolean(self.mgr, val)

   def setDNSPassDomain(self, value):
       """Whether the DHCP server should pass the DNS domain used by the host. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATEngine_setDNSPassDomain(_this, _val)

   def getDNSProxy(self):
       """Whether the DHCP server (and the DNS traffic by NAT) should pass the address
        of the DNS proxy and process traffic using DNS servers registered on the host. """
       val = self.mgr.getService().INATEngine_getDNSProxy(self.handle)
       return Boolean(self.mgr, val)

   def setDNSProxy(self, value):
       """Whether the DHCP server (and the DNS traffic by NAT) should pass the address
        of the DNS proxy and process traffic using DNS servers registered on the host. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATEngine_setDNSProxy(_this, _val)

   def getDNSUseHostResolver(self):
       """Whether the DHCP server (and the DNS traffic by NAT) should pass the address
        of the DNS proxy and process traffic using the host resolver mechanism. """
       val = self.mgr.getService().INATEngine_getDNSUseHostResolver(self.handle)
       return Boolean(self.mgr, val)

   def setDNSUseHostResolver(self, value):
       """Whether the DHCP server (and the DNS traffic by NAT) should pass the address
        of the DNS proxy and process traffic using the host resolver mechanism. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().INATEngine_setDNSUseHostResolver(_this, _val)

   def getRedirects(self):
       """Array of NAT port-forwarding rules in string representation, in the following
        format: "name,protocol id,host ip,host port,guest ip,guest port". """
       val = self.mgr.getService().INATEngine_getRedirects(self.handle)
       return String(self.mgr, val, True)



   _Attrs_ = {'network':[getNetwork,setNetwork,],
              'hostIP':[getHostIP,setHostIP,],
              'TFTPPrefix':[getTFTPPrefix,setTFTPPrefix,],
              'TFTPBootFile':[getTFTPBootFile,setTFTPBootFile,],
              'TFTPNextServer':[getTFTPNextServer,setTFTPNextServer,],
              'aliasMode':[getAliasMode,setAliasMode,],
              'DNSPassDomain':[getDNSPassDomain,setDNSPassDomain,],
              'DNSProxy':[getDNSProxy,setDNSProxy,],
              'DNSUseHostResolver':[getDNSUseHostResolver,setDNSUseHostResolver,],
              'redirects':[getRedirects,None]}

class IBandwidthGroup(IUnknown):
   """Represents one bandwidth group.
      Interface ID:
        {31587F93-2D12-4D7C-BA6D-CE51D0D5B265}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IBandwidthGroup(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IBandwidthGroup._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IBandwidthGroup._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getName(self):
       """Name of the group. """
       val = self.mgr.getService().IBandwidthGroup_getName(self.handle)
       return String(self.mgr, val)

   def getType(self):
       """Type of the group. """
       val = self.mgr.getService().IBandwidthGroup_getType(self.handle)
       return BandwidthGroupType(self.mgr, val)

   def getReference(self):
       """How many devices/medium attachments use this group. """
       val = self.mgr.getService().IBandwidthGroup_getReference(self.handle)
       return UnsignedInt(self.mgr, val)

   def getMaxBytesPerSec(self):
       """The maximum number of bytes which can be transfered by all
        entities attached to this group during one second. """
       val = self.mgr.getService().IBandwidthGroup_getMaxBytesPerSec(self.handle)
       return Long(self.mgr, val)

   def setMaxBytesPerSec(self, value):
       """The maximum number of bytes which can be transfered by all
        entities attached to this group during one second. """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IBandwidthGroup_setMaxBytesPerSec(_this, _val)



   _Attrs_ = {'name':[getName,None],
              'type':[getType,None],
              'reference':[getReference,None],
              'maxBytesPerSec':[getMaxBytesPerSec,setMaxBytesPerSec,]}

class IBandwidthControl(IUnknown):
   """
      Controls the bandwidth groups of one machine used to cap I/O done by a VM.
      This includes network and disk I/O.
    
      Interface ID:
        {48C7F4C0-C9D6-4742-957C-A6FD52E8C4AE}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IBandwidthControl(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IBandwidthControl._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IBandwidthControl._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def createBandwidthGroup(self, _arg_name, _arg_type, _arg_maxBytesPerSec):
       """
        Creates a new bandwidth group.
      
        :param _arg_name: Name of the bandwidth group.
        :param _arg_type: The type of the bandwidth group (network or disk).
        :param _arg_maxBytesPerSec: The maximum number of bytes which can be transfered by all entities attached to this group during one second.

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_type,)
       req += (_arg_maxBytesPerSec,)
       val = self.mgr.getService().IBandwidthControl_createBandwidthGroup(*req)
       
       return 

   def deleteBandwidthGroup(self, _arg_name):
       """
        Deletes a new bandwidth group.
      
        :param _arg_name: Name of the bandwidth group to delete.

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IBandwidthControl_deleteBandwidthGroup(*req)
       
       return 

   def getBandwidthGroup(self, _arg_name):
       """
        Get a bandwidth group by name.
      
        :param _arg_name: Name of the bandwidth group to get.
        :return: Where to store the bandwidth group on success.
        :rtype: IBandwidthGroup

       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().IBandwidthControl_getBandwidthGroup(*req)
       
       return IBandwidthGroup(self.mgr, val)

   def getAllBandwidthGroups(self):
       """
        Get all managed bandwidth groups.
      
        :return: The array of managed bandwidth groups.
        :rtype: List[IBandwidthGroup]

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IBandwidthControl_getAllBandwidthGroups(*req)
       
       return IBandwidthGroup(self.mgr, val, True)

   def getNumGroups(self):
       """
        The current number of existing bandwidth groups managed.
       """
       val = self.mgr.getService().IBandwidthControl_getNumGroups(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'numGroups':[getNumGroups,None]}

class IEventSource(IUnknown):
   """
      Event source. Generally, any object which could generate events can be an event source,
      or aggregate one. To simplify using one-way protocols such as webservices running on top of HTTP(S),
      an event source can work with listeners in either active or passive mode. In active mode it is up to
      the IEventSource implementation to call IEventListener::handleEvent, in passive mode the
      event source keeps track of pending events for each listener and returns available events on demand.

      See ::IEvent for an introduction to VirtualBox event handling.
    
      Interface ID:
        {9B6E1AEE-35F3-4F4D-B5BB-ED0ECEFD8538}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IEventSource(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IEventSource._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IEventSource._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def createListener(self):
       """
        Creates a new listener object, useful for passive mode.
      
        :return: 
        :rtype: IEventListener

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IEventSource_createListener(*req)
       
       return IEventListener(self.mgr, val)

   def createAggregator(self, _arg_subordinates):
       """
        Creates an aggregator event source, collecting events from multiple sources.
        This way a single listener can listen for events coming from multiple sources,
        using a single blocking #getEvent on the returned aggregator.
      
        :param _arg_subordinates: Subordinate event source this one aggregates.
        :return: Event source aggregating passed sources.
        :rtype: IEventSource

       """
   
       req = (self.handle,)
       req += (_arg_subordinates,)
       val = self.mgr.getService().IEventSource_createAggregator(*req)
       
       return IEventSource(self.mgr, val)

   def registerListener(self, _arg_listener, _arg_interesting, _arg_active):
       """
        Register an event listener.

        
        :param _arg_listener: Listener to register.
        :param _arg_interesting: Event types listener is interested in. One can use wildcards like - to specify wildcards, matching more than one event.
        :param _arg_active: Which mode this listener is operating in. In active mode, is called directly. In passive mode, an internal event queue is created for this this IEventListener. For each event coming in, it is added to queues for all interested registered passive listeners. It is then up to the external code to call the listener's method. When done with an event, the external code must call .

        .. note:: 
          To avoid system overload, the VirtualBox server process checks if passive event
          listeners call IEventSource::getEvent frequently enough. In the
          current implementation, if more than 500 pending events are detected for a passive
          event listener, it is forcefully unregistered by the system, and further
          #getEvent calls will return @c VBOX_E_OBJECT_NOT_FOUND.
        
       """
   
       req = (self.handle,)
       req += (_arg_listener,)
       req += (_arg_interesting,)
       req += (_arg_active,)
       val = self.mgr.getService().IEventSource_registerListener(*req)
       
       return 

   def unregisterListener(self, _arg_listener):
       """
        Unregister an event listener. If listener is passive, and some waitable events are still
        in queue they are marked as processed automatically.
      
        :param _arg_listener: Listener to unregister.

       """
   
       req = (self.handle,)
       req += (_arg_listener,)
       val = self.mgr.getService().IEventSource_unregisterListener(*req)
       
       return 

   def fireEvent(self, _arg_event, _arg_timeout):
       """
        Fire an event for this source.
      
        :param _arg_event: Event to deliver.
        :param _arg_timeout: Maximum time to wait for event processing (if event is waitable), in ms; 0 = no wait, -1 = indefinite wait.
        :return: true if an event was delivered to all targets, or is non-waitable.
        :rtype: boolean

       """
   
       req = (self.handle,)
       req += (_arg_event,)
       req += (_arg_timeout,)
       val = self.mgr.getService().IEventSource_fireEvent(*req)
       
       return Boolean(self.mgr, val)

   def getEvent(self, _arg_listener, _arg_timeout):
       """
        Get events from this peer's event queue (for passive mode). Calling this method
        regularly is required for passive event listeners to avoid system overload;
        see IEventSource::registerListener for details.

        
        :param _arg_listener: Which listener to get data for.
        :param _arg_timeout: Maximum time to wait for events, in ms; 0 = no wait, -1 = indefinite wait.
        :return: Event retrieved, or null if none available.
        :rtype: IEvent

        Expected result codes:
        VBOX_E_OBJECT_NOT_FOUND
          Listener is not registered, or autounregistered.
        
       """
   
       req = (self.handle,)
       req += (_arg_listener,)
       req += (_arg_timeout,)
       val = self.mgr.getService().IEventSource_getEvent(*req)
       
       return IEvent(self.mgr, val)

   def eventProcessed(self, _arg_listener, _arg_event):
       """
        Must be called for waitable events after a particular listener finished its
        event processing. When all listeners of a particular event have called this
        method, the system will then call IEvent::setProcessed.
      
        :param _arg_listener: Which listener processed event.
        :param _arg_event: Which event.

       """
   
       req = (self.handle,)
       req += (_arg_listener,)
       req += (_arg_event,)
       val = self.mgr.getService().IEventSource_eventProcessed(*req)
       
       return 



   _Attrs_ = {}

class IEventListener(IUnknown):
   """
      Event listener. An event listener can work in either active or passive mode, depending on the way
      it was registered.
      See ::IEvent for an introduction to VirtualBox event handling.
    
      Interface ID:
        {67099191-32E7-4F6C-85EE-422304C71B90}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IEventListener(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IEventListener._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IEventListener._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def handleEvent(self, _arg_event):
       """
        Handle event callback for active listeners. It is not called for
        passive listeners. After calling #handleEvent on all active listeners
        and having received acknowledgement from all passive listeners via
        IEventSource::eventProcessed, the event is marked as
        processed and IEvent::waitProcessed will return
        immediately.
      
        :param _arg_event: Event available.

       """
   
       req = (self.handle,)
       req += (_arg_event,)
       val = self.mgr.getService().IEventListener_handleEvent(*req)
       
       return 



   _Attrs_ = {}

class IEvent(IUnknown):
   """
      Abstract parent interface for VirtualBox events. Actual events will typically implement
      a more specific interface which derives from this (see below).

      Introduction to VirtualBox events

      Generally speaking, an event (represented by this interface) signals that something
      happened, while an event listener (see ::IEventListener) represents an
      entity that is interested in certain events. In order for this to work with
      unidirectional protocols (i.e. web services), the concepts of passive and active
      listener are used.

      Event consumers can register themselves as listeners, providing an array of
      events they are interested in (see IEventSource::registerListener).
      When an event triggers, the listener is notified about the event. The exact
      mechanism of the notification depends on whether the listener was registered as
      an active or passive listener:

        * An active listener is very similar to a callback: it is a function invoked
          by the API. As opposed to the callbacks that were used in the API before
          VirtualBox 4.0 however, events are now objects with an interface hierarchy.
        
          * Passive listeners are somewhat trickier to implement, but do not require
          a client function to be callable, which is not an option with scripting
          languages or web service clients. Internally the ::IEventSource
          implementation maintains an event queue for each passive listener, and
          newly arrived events are put in this queue. When the listener calls
          IEventSource::getEvent, first element from its internal event
          queue is returned. When the client completes processing of an event,
          the IEventSource::eventProcessed function must be called,
          acknowledging that the event was processed. It supports implementing
          waitable events. On passive listener unregistration, all events from its
          queue are auto-acknowledged.
        

      Waitable events are useful in situations where the event generator wants to track
      delivery or a party wants to wait until all listeners have completed the event. A
      typical example would be a vetoable event (see ::IVetoEvent) where a
      listeners might veto a certain action, and thus the event producer has to make
      sure that all listeners have processed the event and not vetoed before taking
      the action.

      A given event may have both passive and active listeners at the same time.

      Using events

      Any VirtualBox object capable of producing externally visible events provides an
      @c eventSource read-only attribute, which is of the type ::IEventSource.
      This event source object is notified by VirtualBox once something has happened, so
      consumers may register event listeners with this event source. To register a listener,
      an object implementing the ::IEventListener interface must be provided.
      For active listeners, such an object is typically created by the consumer, while for
      passive listeners IEventSource::createListener should be used. Please
      note that a listener created with IEventSource::createListener must not be used as an active listener.

      Once created, the listener must be registered to listen for the desired events
      (see IEventSource::registerListener), providing an array of
      ::VBoxEventType enums. Those elements can either be the individual
      event IDs or wildcards matching multiple event IDs.

      After registration, the callback's IEventListener::handleEvent method is
      called automatically when the event is triggered, while passive listeners have to call
      IEventSource::getEvent and IEventSource::eventProcessed in
      an event processing loop.

      The IEvent interface is an abstract parent interface for all such VirtualBox events
      coming in. As a result, the standard use pattern inside IEventListener::handleEvent
      or the event processing loop is to check the #type attribute of the event and
      then cast to the appropriate specific interface using @c QueryInterface().
    
      Interface ID:
        {0CA2ADBA-8F30-401B-A8CD-FE31DBE839C0}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def setProcessed(self):
       """
        Internal method called by the system when all listeners of a particular event have called
        IEventSource::eventProcessed. This should not be called by client code.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IEvent_setProcessed(*req)
       
       return 

   def waitProcessed(self, _arg_timeout):
       """
        Wait until time outs, or this event is processed. Event must be waitable for this operation to have
        described semantics, for non-waitable returns true immediately.
      
        :param _arg_timeout: Maximum time to wait for event processing, in ms; 0 = no wait, -1 = indefinite wait.
        :return: If this event was processed before timeout.
        :rtype: boolean

       """
   
       req = (self.handle,)
       req += (_arg_timeout,)
       val = self.mgr.getService().IEvent_waitProcessed(*req)
       
       return Boolean(self.mgr, val)

   def getType(self):
       """
        Event type.
       """
       val = self.mgr.getService().IEvent_getType(self.handle)
       return VBoxEventType(self.mgr, val)

   def getSource(self):
       """
        Source of this event.
       """
       val = self.mgr.getService().IEvent_getSource(self.handle)
       return IEventSource(self.mgr, val)

   def getWaitable(self):
       """
        If we can wait for this event being processed. If false, #waitProcessed returns immediately,
        and #setProcessed doesn't make sense. Non-waitable events are generally better performing,
        as no additional overhead associated with waitability imposed.
        Waitable events are needed when one need to be able to wait for particular event processed,
        for example for vetoable changes, or if event refers to some resource which need to be kept immutable
        until all consumers confirmed events.
       """
       val = self.mgr.getService().IEvent_getWaitable(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'type':[getType,None],
              'source':[getSource,None],
              'waitable':[getWaitable,None]}

class IReusableEvent(IEvent):
   """Base abstract interface for all reusable events.
      Interface ID:
        {69BFB134-80F6-4266-8E20-16371F68FA25}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IReusableEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IReusableEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IReusableEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def reuse(self):
       """
        Marks an event as reused, increments 'generation', fields shall no
        longer be considered valid.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IReusableEvent_reuse(*req)
       
       return 

   def getGeneration(self):
       """Current generation of event, incremented on reuse. """
       val = self.mgr.getService().IReusableEvent_getGeneration(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'generation':[getGeneration,None]}

class IMachineEvent(IEvent):
   """Base abstract interface for all machine events.
      Interface ID:
        {92ED7B1A-0D96-40ED-AE46-A564D484325E}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMachineEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachineEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachineEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMachineId(self):
       """ID of the machine this event relates to. """
       val = self.mgr.getService().IMachineEvent_getMachineId(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'machineId':[getMachineId,None]}

class IMachineStateChangedEvent(IMachineEvent):
   """Machine state change event.
      Interface ID:
        {5748F794-48DF-438D-85EB-98FFD70D18C9}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMachineStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachineStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachineStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getState(self):
       """New execution state. """
       val = self.mgr.getService().IMachineStateChangedEvent_getState(self.handle)
       return MachineState(self.mgr, val)



   _Attrs_ = {'state':[getState,None]}

class IMachineDataChangedEvent(IMachineEvent):
   """
      Any of the settings of the given machine has changed.
    
      Interface ID:
        {ABE94809-2E88-4436-83D7-50F3E64D0503}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMachineDataChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachineDataChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachineDataChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getTemporary(self):
       """@c true if the settings change is temporary. All permanent
        settings changes will trigger an event, and only temporary settings
        changes for running VMs will trigger an event. Note: sending events
        for temporary changes is NOT IMPLEMENTED. """
       val = self.mgr.getService().IMachineDataChangedEvent_getTemporary(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'temporary':[getTemporary,None]}

class IMediumRegisteredEvent(IEvent):
   """
      The given medium was registered or unregistered
      within this VirtualBox installation.
    
      Interface ID:
        {53FAC49A-B7F1-4A5A-A4EF-A11DD9C2A458}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMediumRegisteredEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMediumRegisteredEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMediumRegisteredEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMediumId(self):
       """ID of the medium this event relates to. """
       val = self.mgr.getService().IMediumRegisteredEvent_getMediumId(self.handle)
       return String(self.mgr, val)

   def getMediumType(self):
       """Type of the medium this event relates to. """
       val = self.mgr.getService().IMediumRegisteredEvent_getMediumType(self.handle)
       return DeviceType(self.mgr, val)

   def getRegistered(self):
       """
        If @c true, the medium was registered, otherwise it was
        unregistered.
       """
       val = self.mgr.getService().IMediumRegisteredEvent_getRegistered(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'mediumId':[getMediumId,None],
              'mediumType':[getMediumType,None],
              'registered':[getRegistered,None]}

class IMediumConfigChangedEvent(IEvent):
   """
      The configuration of the given medium was changed (location, properties,
      child/parent or anything else).
    
      Interface ID:
        {DD3E2654-A161-41F1-B583-4892F4A9D5D5}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMediumConfigChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMediumConfigChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMediumConfigChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMedium(self):
       """ID of the medium this event relates to. """
       val = self.mgr.getService().IMediumConfigChangedEvent_getMedium(self.handle)
       return IMedium(self.mgr, val)



   _Attrs_ = {'medium':[getMedium,None]}

class IMachineRegisteredEvent(IMachineEvent):
   """
      The given machine was registered or unregistered
      within this VirtualBox installation.
    
      Interface ID:
        {C354A762-3FF2-4F2E-8F09-07382EE25088}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMachineRegisteredEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachineRegisteredEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachineRegisteredEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getRegistered(self):
       """
        If @c true, the machine was registered, otherwise it was
        unregistered.
       """
       val = self.mgr.getService().IMachineRegisteredEvent_getRegistered(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'registered':[getRegistered,None]}

class ISessionStateChangedEvent(IMachineEvent):
   """
      The state of the session for the given machine was changed.
      
        .. sealso:: IMachine::sessionState
      Interface ID:
        {714A3EEF-799A-4489-86CD-FE8E45B2FF8E}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISessionStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISessionStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISessionStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getState(self):
       """
        New session state.
       """
       val = self.mgr.getService().ISessionStateChangedEvent_getState(self.handle)
       return SessionState(self.mgr, val)



   _Attrs_ = {'state':[getState,None]}

class IGuestPropertyChangedEvent(IMachineEvent):
   """
      Notification when a guest property has changed.
    
      Interface ID:
        {3F63597A-26F1-4EDB-8DD2-6BDDD0912368}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestPropertyChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestPropertyChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestPropertyChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getName(self):
       """
        The name of the property that has changed.
       """
       val = self.mgr.getService().IGuestPropertyChangedEvent_getName(self.handle)
       return String(self.mgr, val)

   def getValue(self):
       """
        The new property value.
       """
       val = self.mgr.getService().IGuestPropertyChangedEvent_getValue(self.handle)
       return String(self.mgr, val)

   def getFlags(self):
       """
        The new property flags.
       """
       val = self.mgr.getService().IGuestPropertyChangedEvent_getFlags(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'name':[getName,None],
              'value':[getValue,None],
              'flags':[getFlags,None]}

class ISnapshotEvent(IMachineEvent):
   """Base interface for all snapshot events.
      Interface ID:
        {21637B0E-34B8-42D3-ACFB-7E96DAF77C22}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshotEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshotEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshotEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getSnapshotId(self):
       """ID of the snapshot this event relates to. """
       val = self.mgr.getService().ISnapshotEvent_getSnapshotId(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'snapshotId':[getSnapshotId,None]}

class ISnapshotTakenEvent(ISnapshotEvent):
   """
      A new snapshot of the machine has been taken.
      
        .. sealso:: ::ISnapshot
      Interface ID:
        {D27C0B3D-6038-422C-B45E-6D4A0503D9F1}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshotTakenEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshotTakenEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return ISnapshotEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshotTakenEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().ISnapshotTakenEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class ISnapshotDeletedEvent(ISnapshotEvent):
   """
      Snapshot of the given machine has been deleted.

      
        .. note:: 
        This notification is delivered after the snapshot
        object has been uninitialized on the server (so that any
        attempt to call its methods will return an error).
      
        .. sealso:: ::ISnapshot
      Interface ID:
        {C48F3401-4A9E-43F4-B7A7-54BD285E22F4}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshotDeletedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshotDeletedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return ISnapshotEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshotDeletedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().ISnapshotDeletedEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class ISnapshotRestoredEvent(ISnapshotEvent):
   """
      Snapshot of the given machine has been restored.
      
        .. sealso:: ::ISnapshot
      Interface ID:
        {F4D803B4-9B2D-4377-BFE6-9702E881516B}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshotRestoredEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshotRestoredEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return ISnapshotEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshotRestoredEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().ISnapshotRestoredEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class ISnapshotChangedEvent(ISnapshotEvent):
   """
      Snapshot properties (name and/or description) have been changed.
      
        .. sealso:: ::ISnapshot
      Interface ID:
        {07541941-8079-447A-A33E-47A69C7980DB}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshotChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshotChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return ISnapshotEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshotChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().ISnapshotChangedEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IMousePointerShapeChangedEvent(IEvent):
   """
      Notification when the guest mouse pointer shape has
      changed. The new shape data is given.
    
      Interface ID:
        {A6DCF6E8-416B-4181-8C4A-45EC95177AEF}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMousePointerShapeChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMousePointerShapeChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMousePointerShapeChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getVisible(self):
       """
        Flag whether the pointer is visible.
       """
       val = self.mgr.getService().IMousePointerShapeChangedEvent_getVisible(self.handle)
       return Boolean(self.mgr, val)

   def getAlpha(self):
       """
        Flag whether the pointer has an alpha channel.
       """
       val = self.mgr.getService().IMousePointerShapeChangedEvent_getAlpha(self.handle)
       return Boolean(self.mgr, val)

   def getXhot(self):
       """
        The pointer hot spot X coordinate.
       """
       val = self.mgr.getService().IMousePointerShapeChangedEvent_getXhot(self.handle)
       return UnsignedInt(self.mgr, val)

   def getYhot(self):
       """
        The pointer hot spot Y coordinate.
       """
       val = self.mgr.getService().IMousePointerShapeChangedEvent_getYhot(self.handle)
       return UnsignedInt(self.mgr, val)

   def getWidth(self):
       """
        Width of the pointer shape in pixels.
       """
       val = self.mgr.getService().IMousePointerShapeChangedEvent_getWidth(self.handle)
       return UnsignedInt(self.mgr, val)

   def getHeight(self):
       """
        Height of the pointer shape in pixels.
       """
       val = self.mgr.getService().IMousePointerShapeChangedEvent_getHeight(self.handle)
       return UnsignedInt(self.mgr, val)

   def getShape(self):
       """
        Shape buffer arrays.

        The @a shape buffer contains a 1-bpp (bits per pixel) AND mask
        followed by a 32-bpp XOR (color) mask.

        For pointers without alpha channel the XOR mask pixels are
        32-bit values: (lsb)BGR0(msb). For pointers with alpha channel
        the XOR mask consists of (lsb)BGRA(msb) 32-bit values.

        An AND mask is used for pointers with alpha channel, so if the
        callback does not support alpha, the pointer could be
        displayed as a normal color pointer.

        The AND mask is a 1-bpp bitmap with byte aligned scanlines. The
        size of the AND mask therefore is cbAnd = (width + 7) / 8 *
          height. The padding bits at the end of each scanline are
        undefined.

        The XOR mask follows the AND mask on the next 4-byte aligned
        offset: uint8_t *pXor = pAnd + (cbAnd + 3) & ~3.
        Bytes in the gap between the AND and the XOR mask are undefined.
        The XOR mask scanlines have no gap between them and the size of
        the XOR mask is: cXor = width * 4 * height.

        
        .. note:: 
          If @a shape is 0, only the pointer visibility is changed.
         """
       val = self.mgr.getService().IMousePointerShapeChangedEvent_getShape(self.handle)
       return self.mgr.decodebase64( val)



   _Attrs_ = {'visible':[getVisible,None],
              'alpha':[getAlpha,None],
              'xhot':[getXhot,None],
              'yhot':[getYhot,None],
              'width':[getWidth,None],
              'height':[getHeight,None],
              'shape':[getShape,None]}

class IMouseCapabilityChangedEvent(IEvent):
   """
      Notification when the mouse capabilities reported by the
      guest have changed. The new capabilities are passed.
    
      Interface ID:
        {70E7779A-E64A-4908-804E-371CAD23A756}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMouseCapabilityChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMouseCapabilityChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMouseCapabilityChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getSupportsAbsolute(self):
       """
        Supports absolute coordinates.
       """
       val = self.mgr.getService().IMouseCapabilityChangedEvent_getSupportsAbsolute(self.handle)
       return Boolean(self.mgr, val)

   def getSupportsRelative(self):
       """
        Supports relative coordinates.
       """
       val = self.mgr.getService().IMouseCapabilityChangedEvent_getSupportsRelative(self.handle)
       return Boolean(self.mgr, val)

   def getSupportsMultiTouch(self):
       """
        Supports multi-touch events coordinates.
       """
       val = self.mgr.getService().IMouseCapabilityChangedEvent_getSupportsMultiTouch(self.handle)
       return Boolean(self.mgr, val)

   def getNeedsHostCursor(self):
       """
        If host cursor is needed.
       """
       val = self.mgr.getService().IMouseCapabilityChangedEvent_getNeedsHostCursor(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'supportsAbsolute':[getSupportsAbsolute,None],
              'supportsRelative':[getSupportsRelative,None],
              'supportsMultiTouch':[getSupportsMultiTouch,None],
              'needsHostCursor':[getNeedsHostCursor,None]}

class IKeyboardLedsChangedEvent(IEvent):
   """
      Notification when the guest OS executes the KBD_CMD_SET_LEDS command
      to alter the state of the keyboard LEDs.
    
      Interface ID:
        {6DDEF35E-4737-457B-99FC-BC52C851A44F}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IKeyboardLedsChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IKeyboardLedsChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IKeyboardLedsChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getNumLock(self):
       """
        NumLock status.
       """
       val = self.mgr.getService().IKeyboardLedsChangedEvent_getNumLock(self.handle)
       return Boolean(self.mgr, val)

   def getCapsLock(self):
       """
        CapsLock status.
       """
       val = self.mgr.getService().IKeyboardLedsChangedEvent_getCapsLock(self.handle)
       return Boolean(self.mgr, val)

   def getScrollLock(self):
       """
        ScrollLock status.
       """
       val = self.mgr.getService().IKeyboardLedsChangedEvent_getScrollLock(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'numLock':[getNumLock,None],
              'capsLock':[getCapsLock,None],
              'scrollLock':[getScrollLock,None]}

class IStateChangedEvent(IEvent):
   """
      Notification when the execution state of the machine has changed.
      The new state is given.
    
      Interface ID:
        {4376693C-CF37-453B-9289-3B0F521CAF27}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getState(self):
       """
        New machine state.
       """
       val = self.mgr.getService().IStateChangedEvent_getState(self.handle)
       return MachineState(self.mgr, val)



   _Attrs_ = {'state':[getState,None]}

class IAdditionsStateChangedEvent(IEvent):
   """
      Notification when a Guest Additions property changes.
      Interested callees should query IGuest attributes to
      find out what has changed.
    
      Interface ID:
        {D70F7915-DA7C-44C8-A7AC-9F173490446A}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IAdditionsStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IAdditionsStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IAdditionsStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IAdditionsStateChangedEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class INetworkAdapterChangedEvent(IEvent):
   """
      Notification when a property of one of the
      virtual IMachine::getNetworkAdapter
      changes. Interested callees should use INetworkAdapter methods and
      attributes to find out what has changed.
    
      Interface ID:
        {08889892-1EC6-4883-801D-77F56CFD0103}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INetworkAdapterChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INetworkAdapterChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INetworkAdapterChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getNetworkAdapter(self):
       """
        Network adapter that is subject to change.
       """
       val = self.mgr.getService().INetworkAdapterChangedEvent_getNetworkAdapter(self.handle)
       return INetworkAdapter(self.mgr, val)



   _Attrs_ = {'networkAdapter':[getNetworkAdapter,None]}

class IAudioAdapterChangedEvent(IEvent):
   """
      Notification when a property of the audio adapter changes.
      Interested callees should use IAudioAdapter methods and attributes
      to find out what has changed.
    
      Interface ID:
        {D5ABC823-04D0-4DB6-8D66-DC2F033120E1}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IAudioAdapterChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IAudioAdapterChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IAudioAdapterChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getAudioAdapter(self):
       """
        Audio adapter that is subject to change.
       """
       val = self.mgr.getService().IAudioAdapterChangedEvent_getAudioAdapter(self.handle)
       return IAudioAdapter(self.mgr, val)



   _Attrs_ = {'audioAdapter':[getAudioAdapter,None]}

class ISerialPortChangedEvent(IEvent):
   """
      Notification when a property of one of the
      virtual IMachine::getSerialPort changes.
      Interested callees should use ISerialPort methods and attributes
      to find out what has changed.
    
      Interface ID:
        {3BA329DC-659C-488B-835C-4ECA7AE71C6C}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISerialPortChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISerialPortChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISerialPortChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getSerialPort(self):
       """
        Serial port that is subject to change.
       """
       val = self.mgr.getService().ISerialPortChangedEvent_getSerialPort(self.handle)
       return ISerialPort(self.mgr, val)



   _Attrs_ = {'serialPort':[getSerialPort,None]}

class IParallelPortChangedEvent(IEvent):
   """
      Notification when a property of one of the
      virtual IMachine::getParallelPort
      changes. Interested callees should use ISerialPort methods and
      attributes to find out what has changed.
    
      Interface ID:
        {813C99FC-9849-4F47-813E-24A75DC85615}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IParallelPortChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IParallelPortChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IParallelPortChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getParallelPort(self):
       """
        Parallel port that is subject to change.
       """
       val = self.mgr.getService().IParallelPortChangedEvent_getParallelPort(self.handle)
       return IParallelPort(self.mgr, val)



   _Attrs_ = {'parallelPort':[getParallelPort,None]}

class IStorageControllerChangedEvent(IEvent):
   """
      Notification when a
      IMachine::storageControllers
      changes.
    
      Interface ID:
        {6BB335CC-1C58-440C-BB7B-3A1397284C7B}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IStorageControllerChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IStorageControllerChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IStorageControllerChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMachinId(self):
       """
        The id of the machine containing the storage controller.
       """
       val = self.mgr.getService().IStorageControllerChangedEvent_getMachinId(self.handle)
       return String(self.mgr, val)

   def getControllerName(self):
       """
        The name of the storage controller.
       """
       val = self.mgr.getService().IStorageControllerChangedEvent_getControllerName(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'machinId':[getMachinId,None],
              'controllerName':[getControllerName,None]}

class IMediumChangedEvent(IEvent):
   """
      Notification when a
      IMachine::mediumAttachments
      changes.
    
      Interface ID:
        {0FE2DA40-5637-472A-9736-72019EABD7DE}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IMediumChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMediumChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMediumChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMediumAttachment(self):
       """
        Medium attachment that is subject to change.
       """
       val = self.mgr.getService().IMediumChangedEvent_getMediumAttachment(self.handle)
       return IMediumAttachment(self.mgr, val)



   _Attrs_ = {'mediumAttachment':[getMediumAttachment,None]}

class IClipboardModeChangedEvent(IEvent):
   """
      Notification when the shared clipboard mode changes.
    
      Interface ID:
        {CAC21692-7997-4595-A731-3A509DB604E5}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IClipboardModeChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IClipboardModeChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IClipboardModeChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getClipboardMode(self):
       """
        The new clipboard mode.
       """
       val = self.mgr.getService().IClipboardModeChangedEvent_getClipboardMode(self.handle)
       return ClipboardMode(self.mgr, val)



   _Attrs_ = {'clipboardMode':[getClipboardMode,None]}

class IClipboardFileTransferModeChangedEvent(IEvent):
   """
      Notification when the shared clipboard file transfer mode changes.
    
      Interface ID:
        {00391758-00B1-4E9D-0000-11FA00F9D583}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IClipboardFileTransferModeChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IClipboardFileTransferModeChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IClipboardFileTransferModeChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getEnabled(self):
       """
        Whether file transfers are allowed or not.
       """
       val = self.mgr.getService().IClipboardFileTransferModeChangedEvent_getEnabled(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'enabled':[getEnabled,None]}

class IDnDModeChangedEvent(IEvent):
   """
      Notification when the drag'n drop mode changes.
    
      Interface ID:
        {B55CF856-1F8B-4692-ABB4-462429FAE5E9}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IDnDModeChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDnDModeChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDnDModeChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getDndMode(self):
       """
        The new drag'n drop mode.
       """
       val = self.mgr.getService().IDnDModeChangedEvent_getDndMode(self.handle)
       return DnDMode(self.mgr, val)



   _Attrs_ = {'dndMode':[getDndMode,None]}

class ICPUChangedEvent(IEvent):
   """
      Notification when a CPU changes.
    
      Interface ID:
        {4DA2DEC7-71B2-4817-9A64-4ED12C17388E}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICPUChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICPUChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICPUChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getCPU(self):
       """
        The CPU which changed.
       """
       val = self.mgr.getService().ICPUChangedEvent_getCPU(self.handle)
       return UnsignedInt(self.mgr, val)

   def getAdd(self):
       """
        Flag whether the CPU was added or removed.
       """
       val = self.mgr.getService().ICPUChangedEvent_getAdd(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'CPU':[getCPU,None],
              'add':[getAdd,None]}

class ICPUExecutionCapChangedEvent(IEvent):
   """
      Notification when the CPU execution cap changes.
    
      Interface ID:
        {DFA7E4F5-B4A4-44CE-85A8-127AC5EB59DC}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICPUExecutionCapChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICPUExecutionCapChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICPUExecutionCapChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getExecutionCap(self):
       """
        The new CPU execution cap value. (1-100)
       """
       val = self.mgr.getService().ICPUExecutionCapChangedEvent_getExecutionCap(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'executionCap':[getExecutionCap,None]}

class IGuestKeyboardEvent(IEvent):
   """
      Notification when guest keyboard event happens.
    
      Interface ID:
        {88394258-7006-40D4-B339-472EE3801844}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestKeyboardEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestKeyboardEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestKeyboardEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getScancodes(self):
       """
        Array of scancodes.
       """
       val = self.mgr.getService().IGuestKeyboardEvent_getScancodes(self.handle)
       return Int(self.mgr, val, True)



   _Attrs_ = {'scancodes':[getScancodes,None]}

class IGuestMouseEvent(IReusableEvent):
   """
      Notification when guest mouse event happens.
    
      Interface ID:
        {179F8647-319C-4E7E-8150-C5837BD265F6}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestMouseEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestMouseEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IReusableEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestMouseEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMode(self):
       """
        If this event is relative, absolute or multi-touch.
       """
       val = self.mgr.getService().IGuestMouseEvent_getMode(self.handle)
       return GuestMouseEventMode(self.mgr, val)

   def getX(self):
       """
        New X position, or X delta.
       """
       val = self.mgr.getService().IGuestMouseEvent_getX(self.handle)
       return Int(self.mgr, val)

   def getY(self):
       """
        New Y position, or Y delta.
       """
       val = self.mgr.getService().IGuestMouseEvent_getY(self.handle)
       return Int(self.mgr, val)

   def getZ(self):
       """
        Z delta.
       """
       val = self.mgr.getService().IGuestMouseEvent_getZ(self.handle)
       return Int(self.mgr, val)

   def getW(self):
       """
        W delta.
       """
       val = self.mgr.getService().IGuestMouseEvent_getW(self.handle)
       return Int(self.mgr, val)

   def getButtons(self):
       """
        Button state bitmask.
       """
       val = self.mgr.getService().IGuestMouseEvent_getButtons(self.handle)
       return Int(self.mgr, val)



   _Attrs_ = {'mode':[getMode,None],
              'x':[getX,None],
              'y':[getY,None],
              'z':[getZ,None],
              'w':[getW,None],
              'buttons':[getButtons,None]}

class IGuestMultiTouchEvent(IEvent):
   """
      Notification when guest touch screen event happens.
    
      Interface ID:
        {BE8A0EB5-F4F4-4DD0-9D30-C89B873247EC}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestMultiTouchEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestMultiTouchEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestMultiTouchEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getContactCount(self):
       """
        Number of contacts in the event.
       """
       val = self.mgr.getService().IGuestMultiTouchEvent_getContactCount(self.handle)
       return Int(self.mgr, val)

   def getXPositions(self):
       """
        X positions.
       """
       val = self.mgr.getService().IGuestMultiTouchEvent_getXPositions(self.handle)
       return Short(self.mgr, val, True)

   def getYPositions(self):
       """
        Y positions.
       """
       val = self.mgr.getService().IGuestMultiTouchEvent_getYPositions(self.handle)
       return Short(self.mgr, val, True)

   def getContactIds(self):
       """
        Contact identifiers.
       """
       val = self.mgr.getService().IGuestMultiTouchEvent_getContactIds(self.handle)
       return UnsignedShort(self.mgr, val, True)

   def getContactFlags(self):
       """
        Contact state.
        Bit 0: in contact.
        Bit 1: in range.
       """
       val = self.mgr.getService().IGuestMultiTouchEvent_getContactFlags(self.handle)
       return UnsignedShort(self.mgr, val, True)

   def getScanTime(self):
       """
        Timestamp of the event in milliseconds. Only relative time between events is important.
       """
       val = self.mgr.getService().IGuestMultiTouchEvent_getScanTime(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'contactCount':[getContactCount,None],
              'xPositions':[getXPositions,None],
              'yPositions':[getYPositions,None],
              'contactIds':[getContactIds,None],
              'contactFlags':[getContactFlags,None],
              'scanTime':[getScanTime,None]}

class IGuestSessionEvent(IEvent):
   """Base abstract interface for all guest session events.
      Interface ID:
        {B9ACD33F-647D-45AC-8FE9-F49B3183BA37}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestSessionEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestSessionEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestSessionEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getSession(self):
       """Guest session that is subject to change. """
       val = self.mgr.getService().IGuestSessionEvent_getSession(self.handle)
       return IGuestSession(self.mgr, val)



   _Attrs_ = {'session':[getSession,None]}

class IGuestSessionStateChangedEvent(IGuestSessionEvent):
   """
      Notification when a guest session changed its state.
    
      Interface ID:
        {327E3C00-EE61-462F-AED3-0DFF6CBF9904}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestSessionStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestSessionStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestSessionEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestSessionStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getId(self):
       """
        Session ID of guest session which was changed.
       """
       val = self.mgr.getService().IGuestSessionStateChangedEvent_getId(self.handle)
       return UnsignedInt(self.mgr, val)

   def getStatus(self):
       """
        New session status.
       """
       val = self.mgr.getService().IGuestSessionStateChangedEvent_getStatus(self.handle)
       return GuestSessionStatus(self.mgr, val)

   def getError(self):
       """
        Error information in case of new session status is indicating an error.

        The attribute IVirtualBoxErrorInfo::resultDetail will contain
        the runtime (IPRT) error code from the guest. See include/iprt/err.h and
        include/VBox/err.h for details.
       """
       val = self.mgr.getService().IGuestSessionStateChangedEvent_getError(self.handle)
       return IVirtualBoxErrorInfo(self.mgr, val)



   _Attrs_ = {'id':[getId,None],
              'status':[getStatus,None],
              'error':[getError,None]}

class IGuestSessionRegisteredEvent(IGuestSessionEvent):
   """
      Notification when a guest session was registered or unregistered.
    
      Interface ID:
        {B79DE686-EABD-4FA6-960A-F1756C99EA1C}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestSessionRegisteredEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestSessionRegisteredEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestSessionEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestSessionRegisteredEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getRegistered(self):
       """
        If @c true, the guest session was registered, otherwise it was
        unregistered.
       """
       val = self.mgr.getService().IGuestSessionRegisteredEvent_getRegistered(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'registered':[getRegistered,None]}

class IGuestProcessEvent(IGuestSessionEvent):
   """Base abstract interface for all guest process events.
      Interface ID:
        {2405F0E5-6588-40A3-9B0A-68C05BA52C4B}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestProcessEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestProcessEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestSessionEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestProcessEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getProcess(self):
       """
        Guest process object which is related to this event.
       """
       val = self.mgr.getService().IGuestProcessEvent_getProcess(self.handle)
       return IGuestProcess(self.mgr, val)

   def getPid(self):
       """
        Guest process ID (PID).
       """
       val = self.mgr.getService().IGuestProcessEvent_getPid(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'process':[getProcess,None],
              'pid':[getPid,None]}

class IGuestProcessRegisteredEvent(IGuestProcessEvent):
   """
      Notification when a guest process was registered or unregistered.
    
      Interface ID:
        {1D89E2B3-C6EA-45B6-9D43-DC6F70CC9F02}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestProcessRegisteredEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestProcessRegisteredEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestProcessEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestProcessRegisteredEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getRegistered(self):
       """
        If @c true, the guest process was registered, otherwise it was
        unregistered.
       """
       val = self.mgr.getService().IGuestProcessRegisteredEvent_getRegistered(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'registered':[getRegistered,None]}

class IGuestProcessStateChangedEvent(IGuestProcessEvent):
   """
      Notification when a guest process changed its state.
    
      Interface ID:
        {C365FB7B-4430-499F-92C8-8BED814A567A}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestProcessStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestProcessStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestProcessEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestProcessStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getStatus(self):
       """
        New guest process status.
       """
       val = self.mgr.getService().IGuestProcessStateChangedEvent_getStatus(self.handle)
       return ProcessStatus(self.mgr, val)

   def getError(self):
       """
        Error information in case of new session status is indicating an error.

        The attribute IVirtualBoxErrorInfo::resultDetail will contain
        the runtime (IPRT) error code from the guest. See include/iprt/err.h and
        include/VBox/err.h for details.
       """
       val = self.mgr.getService().IGuestProcessStateChangedEvent_getError(self.handle)
       return IVirtualBoxErrorInfo(self.mgr, val)



   _Attrs_ = {'status':[getStatus,None],
              'error':[getError,None]}

class IGuestProcessIOEvent(IGuestProcessEvent):
   """
      Base abstract interface for all guest process input/output (IO) events.
    
      Interface ID:
        {9EA9227C-E9BB-49B3-BFC7-C5171E93EF38}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestProcessIOEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestProcessIOEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestProcessEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestProcessIOEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getHandle(self):
       """
        Input/output (IO) handle involved in this event. Usually 0 is stdin,
        1 is stdout and 2 is stderr.
       """
       val = self.mgr.getService().IGuestProcessIOEvent_getHandle(self.handle)
       return UnsignedInt(self.mgr, val)

   def getProcessed(self):
       """
        Processed input or output (in bytes).
       """
       val = self.mgr.getService().IGuestProcessIOEvent_getProcessed(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'handle':[getHandle,None],
              'processed':[getProcessed,None]}

class IGuestProcessInputNotifyEvent(IGuestProcessIOEvent):
   """
      Notification when a guest process' stdin became available.
      
        .. note:: This event is right now not implemented!
      Interface ID:
        {0DE887F2-B7DB-4616-AAC6-CFB94D89BA78}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestProcessInputNotifyEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestProcessInputNotifyEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestProcessIOEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestProcessInputNotifyEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getStatus(self):
       """
        Current process input status.
       """
       val = self.mgr.getService().IGuestProcessInputNotifyEvent_getStatus(self.handle)
       return ProcessInputStatus(self.mgr, val)



   _Attrs_ = {'status':[getStatus,None]}

class IGuestProcessOutputEvent(IGuestProcessIOEvent):
   """
      Notification when there is guest process output available for reading.
    
      Interface ID:
        {D3D5F1EE-BCB2-4905-A7AB-CC85448A742B}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestProcessOutputEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestProcessOutputEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestProcessIOEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestProcessOutputEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getData(self):
       """
        Actual output data.
       """
       val = self.mgr.getService().IGuestProcessOutputEvent_getData(self.handle)
       return self.mgr.decodebase64( val)



   _Attrs_ = {'data':[getData,None]}

class IGuestFileEvent(IGuestSessionEvent):
   """Base abstract interface for all guest file events.
      Interface ID:
        {C8ADB7B0-057D-4391-B928-F14B06B710C5}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestFileEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestFileEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestSessionEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestFileEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getFile(self):
       """
        Guest file object which is related to this event.
       """
       val = self.mgr.getService().IGuestFileEvent_getFile(self.handle)
       return IGuestFile(self.mgr, val)



   _Attrs_ = {'file':[getFile,None]}

class IGuestFileRegisteredEvent(IGuestFileEvent):
   """
      Notification when a guest file was registered or unregistered.
    
      Interface ID:
        {D0D93830-70A2-487E-895E-D3FC9679F7B3}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestFileRegisteredEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestFileRegisteredEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestFileEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestFileRegisteredEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getRegistered(self):
       """
        If @c true, the guest file was registered, otherwise it was
        unregistered.
       """
       val = self.mgr.getService().IGuestFileRegisteredEvent_getRegistered(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'registered':[getRegistered,None]}

class IGuestFileStateChangedEvent(IGuestFileEvent):
   """
      Notification when a guest file changed its state.
    
      Interface ID:
        {D37FE88F-0979-486C-BAA1-3ABB144DC82D}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestFileStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestFileStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestFileEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestFileStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getStatus(self):
       """
        New guest file status.
       """
       val = self.mgr.getService().IGuestFileStateChangedEvent_getStatus(self.handle)
       return FileStatus(self.mgr, val)

   def getError(self):
       """
        Error information in case of new session status is indicating an error.

        The attribute IVirtualBoxErrorInfo::resultDetail will contain
        the runtime (IPRT) error code from the guest. See include/iprt/err.h and
        include/VBox/err.h for details.
       """
       val = self.mgr.getService().IGuestFileStateChangedEvent_getError(self.handle)
       return IVirtualBoxErrorInfo(self.mgr, val)



   _Attrs_ = {'status':[getStatus,None],
              'error':[getError,None]}

class IGuestFileIOEvent(IGuestFileEvent):
   """
      Base abstract interface for all guest file input/output (IO) events.
    
      Interface ID:
        {B5191A7C-9536-4EF8-820E-3B0E17E5BBC8}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestFileIOEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestFileIOEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestFileEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestFileIOEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getOffset(self):
       """
        Current offset (in bytes).
       """
       val = self.mgr.getService().IGuestFileIOEvent_getOffset(self.handle)
       return Long(self.mgr, val)

   def getProcessed(self):
       """
        Processed input or output (in bytes).
       """
       val = self.mgr.getService().IGuestFileIOEvent_getProcessed(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'offset':[getOffset,None],
              'processed':[getProcessed,None]}

class IGuestFileOffsetChangedEvent(IGuestFileIOEvent):
   """
      Notification when a guest file changed its current offset via IFile::seek.
    
      Interface ID:
        {E8F79A21-1207-4179-94CF-CA250036308F}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestFileOffsetChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestFileOffsetChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestFileIOEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestFileOffsetChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IGuestFileOffsetChangedEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IGuestFileSizeChangedEvent(IGuestFileEvent):
   """
      Notification when a guest file changed its size via IFile::setSize.
    
      Interface ID:
        {D78374E9-486E-472F-481B-969746AF2480}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestFileSizeChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestFileSizeChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestFileEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestFileSizeChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getNewSize(self):
       """ """
       val = self.mgr.getService().IGuestFileSizeChangedEvent_getNewSize(self.handle)
       return Long(self.mgr, val)



   _Attrs_ = {'newSize':[getNewSize,None]}

class IGuestFileReadEvent(IGuestFileIOEvent):
   """
      Notification when data has been read from a guest file.
    
      Interface ID:
        {4EE3CBCB-486F-40DB-9150-DEEE3FD24189}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestFileReadEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestFileReadEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestFileIOEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestFileReadEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getData(self):
       """
        Actual data read.
       """
       val = self.mgr.getService().IGuestFileReadEvent_getData(self.handle)
       return self.mgr.decodebase64( val)



   _Attrs_ = {'data':[getData,None]}

class IGuestFileWriteEvent(IGuestFileIOEvent):
   """
      Notification when data has been written to a guest file.
    
      Interface ID:
        {E062A915-3CF5-4C0A-BC90-9B8D4CC94D89}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestFileWriteEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestFileWriteEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IGuestFileIOEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestFileWriteEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IGuestFileWriteEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IVRDEServerChangedEvent(IEvent):
   """
      Notification when a property of the
      IMachine::VRDEServer changes.
      Interested callees should use IVRDEServer methods and attributes to
      find out what has changed.
    
      Interface ID:
        {A06FD66A-3188-4C8C-8756-1395E8CB691C}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IVRDEServerChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVRDEServerChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVRDEServerChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IVRDEServerChangedEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IVRDEServerInfoChangedEvent(IEvent):
   """
      Notification when the status of the VRDE server changes. Interested callees
      should use IConsole::VRDEServerInfo
      attributes to find out what is the current status.
    
      Interface ID:
        {DD6A1080-E1B7-4339-A549-F0878115596E}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IVRDEServerInfoChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVRDEServerInfoChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVRDEServerInfoChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IVRDEServerInfoChangedEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IRecordingChangedEvent(IEvent):
   """
      Notification when recording settings have changed.
    
      Interface ID:
        {B5DDB370-08A7-4C8F-910D-47AABD67253A}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IRecordingChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IRecordingChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IRecordingChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IRecordingChangedEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IUSBControllerChangedEvent(IEvent):
   """
      Notification when a property of the virtual
      IMachine::USBControllers changes.
      Interested callees should use IUSBController methods and attributes to
      find out what has changed.
    
      Interface ID:
        {93BADC0C-61D9-4940-A084-E6BB29AF3D83}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IUSBControllerChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBControllerChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBControllerChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IUSBControllerChangedEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IUSBDeviceStateChangedEvent(IEvent):
   """
      Notification when a USB device is attached to or detached from
      the virtual USB controller.

      This notification is sent as a result of the indirect
      request to attach the device because it matches one of the
      machine USB filters, or as a result of the direct request
      issued by IConsole::attachUSBDevice or
      IConsole::detachUSBDevice.

      This notification is sent in case of both a succeeded and a
      failed request completion. When the request succeeds, the
      @a error parameter is @c null, and the given device has been
      already added to (when @a attached is @c true) or removed from
      (when @a attached is @c false) the collection represented by
      IConsole::USBDevices. On failure, the collection
      doesn't change and the @a error parameter represents the error
      message describing the failure.
    
      Interface ID:
        {806DA61B-6679-422A-B629-51B06B0C6D93}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IUSBDeviceStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBDeviceStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBDeviceStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getDevice(self):
       """
        Device that is subject to state change.
       """
       val = self.mgr.getService().IUSBDeviceStateChangedEvent_getDevice(self.handle)
       return IUSBDevice(self.mgr, val)

   def getAttached(self):
       """
        @c true if the device was attached and @c false otherwise.
       """
       val = self.mgr.getService().IUSBDeviceStateChangedEvent_getAttached(self.handle)
       return Boolean(self.mgr, val)

   def getError(self):
       """
        @c null on success or an error message object on failure.
       """
       val = self.mgr.getService().IUSBDeviceStateChangedEvent_getError(self.handle)
       return IVirtualBoxErrorInfo(self.mgr, val)



   _Attrs_ = {'device':[getDevice,None],
              'attached':[getAttached,None],
              'error':[getError,None]}

class ISharedFolderChangedEvent(IEvent):
   """
      Notification when a shared folder is added or removed.
      The @a scope argument defines one of three scopes:
      IVirtualBox::sharedFolders
      (::Scope_Global),
      IMachine::sharedFolders of
      the machine (::Scope_Machine) or IConsole::sharedFolders of the
      machine (::Scope_Session). Interested callees
      should use query the corresponding collections to find out what has
      changed.
    
      Interface ID:
        {B66349B5-3534-4239-B2DE-8E1535D94C0B}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ISharedFolderChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISharedFolderChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISharedFolderChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getScope(self):
       """
        Scope of the notification.
       """
       val = self.mgr.getService().ISharedFolderChangedEvent_getScope(self.handle)
       return Scope(self.mgr, val)



   _Attrs_ = {'scope':[getScope,None]}

class IRuntimeErrorEvent(IEvent):
   """
      Notification when an error happens during the virtual
      machine execution.

      There are three kinds of runtime errors:
        * fatal
          * non-fatal with retry
          * non-fatal warningsFatal errors are indicated by the @a fatal parameter set
      to @c true. In case of fatal errors, the virtual machine
      execution is always paused before calling this notification, and
      the notification handler is supposed either to immediately save
      the virtual machine state using IMachine::saveState
      or power it off using IConsole::powerDown.
      Resuming the execution can lead to unpredictable results.

      Non-fatal errors and warnings are indicated by the
      @a fatal parameter set to @c false. If the virtual machine
      is in the Paused state by the time the error notification is
      received, it means that the user can try to resume the machine
      execution after attempting to solve the problem that caused the
      error. In this case, the notification handler is supposed
      to show an appropriate message to the user (depending on the
      value of the @a id parameter) that offers several actions such
      as Retry, Save or Power Off. If the user
      wants to retry, the notification handler should continue
      the machine execution using the IConsole::resume
      call. If the machine execution is not Paused during this
      notification, then it means this notification is a warning
      (for example, about a fatal condition that can happen very soon);
      no immediate action is required from the user, the machine
      continues its normal execution.

      Note that in either case the notification handler
      must not perform any action directly on a thread
      where this notification is called. Everything it is allowed to
      do is to post a message to another thread that will then talk
      to the user and take the corresponding action.

      Currently, the following error identifiers are known:
        * "HostMemoryLow"
          * "HostAudioNotResponding"
          * "VDIStorageFull"
          * "3DSupportIncompatibleAdditions"
      Interface ID:
        {883DD18B-0721-4CDE-867C-1A82ABAF914C}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IRuntimeErrorEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IRuntimeErrorEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IRuntimeErrorEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getFatal(self):
       """
        Whether the error is fatal or not.
       """
       val = self.mgr.getService().IRuntimeErrorEvent_getFatal(self.handle)
       return Boolean(self.mgr, val)

   def getId(self):
       """
        Error identifier.
       """
       val = self.mgr.getService().IRuntimeErrorEvent_getId(self.handle)
       return String(self.mgr, val)

   def getMessage(self):
       """
        Optional error message.
       """
       val = self.mgr.getService().IRuntimeErrorEvent_getMessage(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'fatal':[getFatal,None],
              'id':[getId,None],
              'message':[getMessage,None]}

class IEventSourceChangedEvent(IEvent):
   """
      Notification when an event source state changes (listener added or removed).
    
      Interface ID:
        {E7932CB8-F6D4-4AB6-9CBF-558EB8959A6A}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IEventSourceChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IEventSourceChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IEventSourceChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getListener(self):
       """
        Event listener which has changed.
       """
       val = self.mgr.getService().IEventSourceChangedEvent_getListener(self.handle)
       return IEventListener(self.mgr, val)

   def getAdd(self):
       """
        Flag whether listener was added or removed.
       """
       val = self.mgr.getService().IEventSourceChangedEvent_getAdd(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'listener':[getListener,None],
              'add':[getAdd,None]}

class IExtraDataChangedEvent(IEvent):
   """
      Notification when machine specific or global extra data
      has changed.
    
      Interface ID:
        {024F00CE-6E0B-492A-A8D0-968472A94DC7}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IExtraDataChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IExtraDataChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IExtraDataChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMachineId(self):
       """
        ID of the machine this event relates to.
        Null for global extra data changes.
       """
       val = self.mgr.getService().IExtraDataChangedEvent_getMachineId(self.handle)
       return String(self.mgr, val)

   def getKey(self):
       """
        Extra data key that has changed.
       """
       val = self.mgr.getService().IExtraDataChangedEvent_getKey(self.handle)
       return String(self.mgr, val)

   def getValue(self):
       """
        Extra data value for the given key.
       """
       val = self.mgr.getService().IExtraDataChangedEvent_getValue(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'machineId':[getMachineId,None],
              'key':[getKey,None],
              'value':[getValue,None]}

class IVetoEvent(IEvent):
   """Base abstract interface for veto events.
      Interface ID:
        {7C5E945F-2354-4267-883F-2F417D216519}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IVetoEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVetoEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVetoEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def addVeto(self, _arg_reason):
       """
        Adds a veto on this event.
      
        :param _arg_reason: Reason for veto, could be null or empty string.

       """
   
       req = (self.handle,)
       req += (_arg_reason,)
       val = self.mgr.getService().IVetoEvent_addVeto(*req)
       
       return 

   def isVetoed(self):
       """
        If this event was vetoed.
      
        :return: Reason for veto.
        :rtype: boolean

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVetoEvent_isVetoed(*req)
       
       return Boolean(self.mgr, val)

   def getVetos(self):
       """
        Current veto reason list, if size is 0 - no veto.
      
        :return: Array of reasons for veto provided by different event handlers.
        :rtype: List[wstring]

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVetoEvent_getVetos(*req)
       
       return String(self.mgr, val, True)

   def addApproval(self, _arg_reason):
       """
        Adds an approval on this event.
      
        :param _arg_reason: Reason for approval, could be null or empty string.

       """
   
       req = (self.handle,)
       req += (_arg_reason,)
       val = self.mgr.getService().IVetoEvent_addApproval(*req)
       
       return 

   def isApproved(self):
       """
        If this event was approved.
      
        :return: 
        :rtype: boolean

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVetoEvent_isApproved(*req)
       
       return Boolean(self.mgr, val)

   def getApprovals(self):
       """
        Current approval reason list, if size is 0 - no approvals.
      
        :return: Array of reasons for approval provided by different event handlers.
        :rtype: List[wstring]

       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVetoEvent_getApprovals(*req)
       
       return String(self.mgr, val, True)



   _Attrs_ = {}

class IExtraDataCanChangeEvent(IVetoEvent):
   """
      Notification when someone tries to change extra data for
      either the given machine or (if @c null) global extra data.
      This gives the chance to veto against changes.
    
      Interface ID:
        {245D88BD-800A-40F8-87A6-170D02249A55}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IExtraDataCanChangeEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IExtraDataCanChangeEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IVetoEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IExtraDataCanChangeEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMachineId(self):
       """
        ID of the machine this event relates to.
        Null for global extra data changes.
       """
       val = self.mgr.getService().IExtraDataCanChangeEvent_getMachineId(self.handle)
       return String(self.mgr, val)

   def getKey(self):
       """
        Extra data key that has changed.
       """
       val = self.mgr.getService().IExtraDataCanChangeEvent_getKey(self.handle)
       return String(self.mgr, val)

   def getValue(self):
       """
        Extra data value for the given key.
       """
       val = self.mgr.getService().IExtraDataCanChangeEvent_getValue(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'machineId':[getMachineId,None],
              'key':[getKey,None],
              'value':[getValue,None]}

class ICanShowWindowEvent(IVetoEvent):
   """
      Notification when a call to
      IMachine::canShowConsoleWindow is made by a
      front-end to check if a subsequent call to
      IMachine::showConsoleWindow can succeed.

      The callee should give an answer appropriate to the current
      machine state using event veto. This answer must
      remain valid at least until the next
      IConsole::state change.
    
      Interface ID:
        {ADF292B0-92C9-4A77-9D35-E058B39FE0B9}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICanShowWindowEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICanShowWindowEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IVetoEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICanShowWindowEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().ICanShowWindowEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IShowWindowEvent(IEvent):
   """
      Notification when a call to
      IMachine::showConsoleWindow
      requests the console window to be activated and brought to
      foreground on the desktop of the host PC.

      This notification should cause the VM console process to
      perform the requested action as described above. If it is
      impossible to do it at a time of this notification, this
      method should return a failure.

      Note that many modern window managers on many platforms
      implement some sort of focus stealing prevention logic, so
      that it may be impossible to activate a window without the
      help of the currently active application (which is supposedly
      an initiator of this notification). In this case, this method
      must return a non-zero identifier that represents the
      top-level window of the VM console process. The caller, if it
      represents a currently active process, is responsible to use
      this identifier (in a platform-dependent manner) to perform
      actual window activation.

      This method must set @a winId to zero if it has performed all
      actions necessary to complete the request and the console
      window is now active and in foreground, to indicate that no
      further action is required on the caller's side.
    
      Interface ID:
        {B0A0904D-2F05-4D28-855F-488F96BAD2B2}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IShowWindowEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IShowWindowEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IShowWindowEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getWinId(self):
       """
        Platform-dependent identifier of the top-level VM console
        window, or zero if this method has performed all actions
        necessary to implement the show window semantics for
        the given platform and/or this VirtualBox front-end.
       """
       val = self.mgr.getService().IShowWindowEvent_getWinId(self.handle)
       return Long(self.mgr, val)

   def setWinId(self, value):
       """
        Platform-dependent identifier of the top-level VM console
        window, or zero if this method has performed all actions
        necessary to implement the show window semantics for
        the given platform and/or this VirtualBox front-end.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().IShowWindowEvent_setWinId(_this, _val)



   _Attrs_ = {'winId':[getWinId,setWinId,]}

class INATRedirectEvent(IMachineEvent):
   """
      Notification when NAT redirect rule added or removed.
    
      Interface ID:
        {24EEF068-C380-4510-BC7C-19314A7352F1}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INATRedirectEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATRedirectEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATRedirectEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getSlot(self):
       """
        Adapter which NAT attached to.
       """
       val = self.mgr.getService().INATRedirectEvent_getSlot(self.handle)
       return UnsignedInt(self.mgr, val)

   def getRemove(self):
       """
        Whether rule remove or add.
       """
       val = self.mgr.getService().INATRedirectEvent_getRemove(self.handle)
       return Boolean(self.mgr, val)

   def getName(self):
       """
        Name of the rule.
       """
       val = self.mgr.getService().INATRedirectEvent_getName(self.handle)
       return String(self.mgr, val)

   def getProto(self):
       """
        Protocol (TCP or UDP) of the redirect rule.
       """
       val = self.mgr.getService().INATRedirectEvent_getProto(self.handle)
       return NATProtocol(self.mgr, val)

   def getHostIP(self):
       """
        Host ip address to bind socket on.
       """
       val = self.mgr.getService().INATRedirectEvent_getHostIP(self.handle)
       return String(self.mgr, val)

   def getHostPort(self):
       """
        Host port to bind socket on.
       """
       val = self.mgr.getService().INATRedirectEvent_getHostPort(self.handle)
       return Int(self.mgr, val)

   def getGuestIP(self):
       """
        Guest ip address to redirect to.
       """
       val = self.mgr.getService().INATRedirectEvent_getGuestIP(self.handle)
       return String(self.mgr, val)

   def getGuestPort(self):
       """
        Guest port to redirect to.
       """
       val = self.mgr.getService().INATRedirectEvent_getGuestPort(self.handle)
       return Int(self.mgr, val)



   _Attrs_ = {'slot':[getSlot,None],
              'remove':[getRemove,None],
              'name':[getName,None],
              'proto':[getProto,None],
              'hostIP':[getHostIP,None],
              'hostPort':[getHostPort,None],
              'guestIP':[getGuestIP,None],
              'guestPort':[getGuestPort,None]}

class IHostPCIDevicePlugEvent(IMachineEvent):
   """
      Notification when host PCI device is plugged/unplugged. Plugging
      usually takes place on VM startup, unplug - when
      IMachine::detachHostPCIDevice is called.

      
        .. sealso:: IMachine::detachHostPCIDevice
      Interface ID:
        {A0BAD6DF-D612-47D3-89D4-DB3992533948}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IHostPCIDevicePlugEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostPCIDevicePlugEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostPCIDevicePlugEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getPlugged(self):
       """
      If device successfully plugged or unplugged.
       """
       val = self.mgr.getService().IHostPCIDevicePlugEvent_getPlugged(self.handle)
       return Boolean(self.mgr, val)

   def getSuccess(self):
       """
        If operation was successful, if false - 'message' attribute
        may be of interest.
       """
       val = self.mgr.getService().IHostPCIDevicePlugEvent_getSuccess(self.handle)
       return Boolean(self.mgr, val)

   def getAttachment(self):
       """
        Attachment info for this device.
       """
       val = self.mgr.getService().IHostPCIDevicePlugEvent_getAttachment(self.handle)
       return IPCIDeviceAttachment(self.mgr, val)

   def getMessage(self):
       """
        Optional error message.
       """
       val = self.mgr.getService().IHostPCIDevicePlugEvent_getMessage(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'plugged':[getPlugged,None],
              'success':[getSuccess,None],
              'attachment':[getAttachment,None],
              'message':[getMessage,None]}

class IVBoxSVCAvailabilityChangedEvent(IEvent):
   """
      Notification when VBoxSVC becomes unavailable (due to a crash or similar
      unexpected circumstances) or available again.
    
      Interface ID:
        {97C78FCD-D4FC-485F-8613-5AF88BFCFCDC}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IVBoxSVCAvailabilityChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVBoxSVCAvailabilityChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVBoxSVCAvailabilityChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getAvailable(self):
       """
        Whether VBoxSVC is available now.
       """
       val = self.mgr.getService().IVBoxSVCAvailabilityChangedEvent_getAvailable(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'available':[getAvailable,None]}

class IBandwidthGroupChangedEvent(IEvent):
   """
      Notification when one of the bandwidth groups changed
    
      Interface ID:
        {334DF94A-7556-4CBC-8C04-043096B02D82}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IBandwidthGroupChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IBandwidthGroupChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IBandwidthGroupChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getBandwidthGroup(self):
       """
        The changed bandwidth group.
       """
       val = self.mgr.getService().IBandwidthGroupChangedEvent_getBandwidthGroup(self.handle)
       return IBandwidthGroup(self.mgr, val)



   _Attrs_ = {'bandwidthGroup':[getBandwidthGroup,None]}

class IGuestMonitorChangedEvent(IEvent):
   """
      Notification when the guest enables one of its monitors.
    
      Interface ID:
        {0F7B8A22-C71F-4A36-8E5F-A77D01D76090}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestMonitorChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestMonitorChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestMonitorChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getChangeType(self):
       """
        What was changed for this guest monitor.
       """
       val = self.mgr.getService().IGuestMonitorChangedEvent_getChangeType(self.handle)
       return GuestMonitorChangedEventType(self.mgr, val)

   def getScreenId(self):
       """
        The monitor which was changed.
       """
       val = self.mgr.getService().IGuestMonitorChangedEvent_getScreenId(self.handle)
       return UnsignedInt(self.mgr, val)

   def getOriginX(self):
       """
        Physical X origin relative to the primary screen.
        Valid for Enabled and NewOrigin.
       """
       val = self.mgr.getService().IGuestMonitorChangedEvent_getOriginX(self.handle)
       return UnsignedInt(self.mgr, val)

   def getOriginY(self):
       """
        Physical Y origin relative to the primary screen.
        Valid for Enabled and NewOrigin.
       """
       val = self.mgr.getService().IGuestMonitorChangedEvent_getOriginY(self.handle)
       return UnsignedInt(self.mgr, val)

   def getWidth(self):
       """
        Width of the screen.
        Valid for Enabled.
       """
       val = self.mgr.getService().IGuestMonitorChangedEvent_getWidth(self.handle)
       return UnsignedInt(self.mgr, val)

   def getHeight(self):
       """
        Height of the screen.
        Valid for Enabled.
       """
       val = self.mgr.getService().IGuestMonitorChangedEvent_getHeight(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'changeType':[getChangeType,None],
              'screenId':[getScreenId,None],
              'originX':[getOriginX,None],
              'originY':[getOriginY,None],
              'width':[getWidth,None],
              'height':[getHeight,None]}

class IGuestUserStateChangedEvent(IEvent):
   """
      Notification when a guest user changed its state.
    
      Interface ID:
        {39B4E759-1EC0-4C0F-857F-FBE2A737A256}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestUserStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestUserStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestUserStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getName(self):
       """
        Name of the guest user whose state changed.
       """
       val = self.mgr.getService().IGuestUserStateChangedEvent_getName(self.handle)
       return String(self.mgr, val)

   def getDomain(self):
       """
        Name of the FQDN (fully qualified domain name) this user is bound
        to. Optional.
       """
       val = self.mgr.getService().IGuestUserStateChangedEvent_getDomain(self.handle)
       return String(self.mgr, val)

   def getState(self):
       """
        What was changed for this guest user. See ::GuestUserState for
        more information.
       """
       val = self.mgr.getService().IGuestUserStateChangedEvent_getState(self.handle)
       return GuestUserState(self.mgr, val)

   def getStateDetails(self):
       """
        Optional state details, depending on the #state attribute.
       """
       val = self.mgr.getService().IGuestUserStateChangedEvent_getStateDetails(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'name':[getName,None],
              'domain':[getDomain,None],
              'state':[getState,None],
              'stateDetails':[getStateDetails,None]}

class IStorageDeviceChangedEvent(IEvent):
   """
      Notification when a
      IMachine::mediumAttachments
      is attached or removed.
    
      Interface ID:
        {232E9151-AE84-4B8E-B0F3-5C20C35CAAC9}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IStorageDeviceChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IStorageDeviceChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IStorageDeviceChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getStorageDevice(self):
       """
        Storage device that is subject to change.
       """
       val = self.mgr.getService().IStorageDeviceChangedEvent_getStorageDevice(self.handle)
       return IMediumAttachment(self.mgr, val)

   def getRemoved(self):
       """
        Flag whether the device was removed or added to the VM.
       """
       val = self.mgr.getService().IStorageDeviceChangedEvent_getRemoved(self.handle)
       return Boolean(self.mgr, val)

   def getSilent(self):
       """
        Flag whether the guest should be notified about the change.
       """
       val = self.mgr.getService().IStorageDeviceChangedEvent_getSilent(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'storageDevice':[getStorageDevice,None],
              'removed':[getRemoved,None],
              'silent':[getSilent,None]}

class INATNetworkChangedEvent(IEvent):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INATNetworkChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATNetworkChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATNetworkChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getNetworkName(self):
       """ """
       val = self.mgr.getService().INATNetworkChangedEvent_getNetworkName(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'networkName':[getNetworkName,None]}

class INATNetworkStartStopEvent(INATNetworkChangedEvent):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INATNetworkStartStopEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATNetworkStartStopEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return INATNetworkChangedEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATNetworkStartStopEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getStartEvent(self):
       """
        IsStartEvent is true when NAT network is started and false on stopping.
       """
       val = self.mgr.getService().INATNetworkStartStopEvent_getStartEvent(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'startEvent':[getStartEvent,None]}

class INATNetworkAlterEvent(INATNetworkChangedEvent):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INATNetworkAlterEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATNetworkAlterEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return INATNetworkChangedEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATNetworkAlterEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().INATNetworkAlterEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class INATNetworkCreationDeletionEvent(INATNetworkAlterEvent):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INATNetworkCreationDeletionEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATNetworkCreationDeletionEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return INATNetworkAlterEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATNetworkCreationDeletionEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getCreationEvent(self):
       """ """
       val = self.mgr.getService().INATNetworkCreationDeletionEvent_getCreationEvent(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'creationEvent':[getCreationEvent,None]}

class INATNetworkSettingEvent(INATNetworkAlterEvent):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INATNetworkSettingEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATNetworkSettingEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return INATNetworkAlterEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATNetworkSettingEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getEnabled(self):
       """ """
       val = self.mgr.getService().INATNetworkSettingEvent_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def getNetwork(self):
       """ """
       val = self.mgr.getService().INATNetworkSettingEvent_getNetwork(self.handle)
       return String(self.mgr, val)

   def getGateway(self):
       """ """
       val = self.mgr.getService().INATNetworkSettingEvent_getGateway(self.handle)
       return String(self.mgr, val)

   def getAdvertiseDefaultIPv6RouteEnabled(self):
       """ """
       val = self.mgr.getService().INATNetworkSettingEvent_getAdvertiseDefaultIPv6RouteEnabled(self.handle)
       return Boolean(self.mgr, val)

   def getNeedDhcpServer(self):
       """ """
       val = self.mgr.getService().INATNetworkSettingEvent_getNeedDhcpServer(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'enabled':[getEnabled,None],
              'network':[getNetwork,None],
              'gateway':[getGateway,None],
              'advertiseDefaultIPv6RouteEnabled':[getAdvertiseDefaultIPv6RouteEnabled,None],
              'needDhcpServer':[getNeedDhcpServer,None]}

class INATNetworkPortForwardEvent(INATNetworkAlterEvent):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return INATNetworkPortForwardEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATNetworkPortForwardEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return INATNetworkAlterEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATNetworkPortForwardEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getCreate(self):
       """ """
       val = self.mgr.getService().INATNetworkPortForwardEvent_getCreate(self.handle)
       return Boolean(self.mgr, val)

   def getIpv6(self):
       """ """
       val = self.mgr.getService().INATNetworkPortForwardEvent_getIpv6(self.handle)
       return Boolean(self.mgr, val)

   def getName(self):
       """ """
       val = self.mgr.getService().INATNetworkPortForwardEvent_getName(self.handle)
       return String(self.mgr, val)

   def getProto(self):
       """ """
       val = self.mgr.getService().INATNetworkPortForwardEvent_getProto(self.handle)
       return NATProtocol(self.mgr, val)

   def getHostIp(self):
       """ """
       val = self.mgr.getService().INATNetworkPortForwardEvent_getHostIp(self.handle)
       return String(self.mgr, val)

   def getHostPort(self):
       """ """
       val = self.mgr.getService().INATNetworkPortForwardEvent_getHostPort(self.handle)
       return Int(self.mgr, val)

   def getGuestIp(self):
       """ """
       val = self.mgr.getService().INATNetworkPortForwardEvent_getGuestIp(self.handle)
       return String(self.mgr, val)

   def getGuestPort(self):
       """ """
       val = self.mgr.getService().INATNetworkPortForwardEvent_getGuestPort(self.handle)
       return Int(self.mgr, val)



   _Attrs_ = {'create':[getCreate,None],
              'ipv6':[getIpv6,None],
              'name':[getName,None],
              'proto':[getProto,None],
              'hostIp':[getHostIp,None],
              'hostPort':[getHostPort,None],
              'guestIp':[getGuestIp,None],
              'guestPort':[getGuestPort,None]}

class IHostNameResolutionConfigurationChangeEvent(IEvent):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IHostNameResolutionConfigurationChangeEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostNameResolutionConfigurationChangeEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostNameResolutionConfigurationChangeEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IHostNameResolutionConfigurationChangeEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class IProgressEvent(IEvent):
   """Base abstract interface for all progress events.
      Interface ID:
        {DAAF9016-1F04-4191-AA2F-1FAC9646AE4C}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IProgressEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IProgressEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IProgressEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getProgressId(self):
       """GUID of the progress this event relates to. """
       val = self.mgr.getService().IProgressEvent_getProgressId(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'progressId':[getProgressId,None]}

class IProgressPercentageChangedEvent(IProgressEvent):
   """Progress state change event.
      Interface ID:
        {F05D7E60-1BCF-4218-9807-04E036CC70F1}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IProgressPercentageChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IProgressPercentageChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IProgressEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IProgressPercentageChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getPercent(self):
       """New percent """
       val = self.mgr.getService().IProgressPercentageChangedEvent_getPercent(self.handle)
       return Int(self.mgr, val)



   _Attrs_ = {'percent':[getPercent,None]}

class IProgressTaskCompletedEvent(IProgressEvent):
   """Progress task completion event.
      Interface ID:
        {A5BBDB7D-8CE7-469F-A4C2-6476F581FF72}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IProgressTaskCompletedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IProgressTaskCompletedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IProgressEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IProgressTaskCompletedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getMidlDoesNotLikeEmptyInterfaces(self):
       """ """
       val = self.mgr.getService().IProgressTaskCompletedEvent_getMidlDoesNotLikeEmptyInterfaces(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'midlDoesNotLikeEmptyInterfaces':[getMidlDoesNotLikeEmptyInterfaces,None]}

class ICursorPositionChangedEvent(IEvent):
   """The guest reports cursor position data.
      Interface ID:
        {6F302674-C927-11E7-B788-33C248E71FC7}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICursorPositionChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICursorPositionChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICursorPositionChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getHasData(self):
       """Event contains valid data.  If not set, switch back to using the host cursor. """
       val = self.mgr.getService().ICursorPositionChangedEvent_getHasData(self.handle)
       return Boolean(self.mgr, val)

   def getX(self):
       """Reported X position """
       val = self.mgr.getService().ICursorPositionChangedEvent_getX(self.handle)
       return UnsignedInt(self.mgr, val)

   def getY(self):
       """Reported Y position """
       val = self.mgr.getService().ICursorPositionChangedEvent_getY(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'hasData':[getHasData,None],
              'x':[getX,None],
              'y':[getY,None]}

class IGuestAdditionsStatusChangedEvent(IEvent):
   """The guest addition status changed.
      Interface ID:
        {A443DA5B-AA82-4720-BC84-BD097B2B13B8}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestAdditionsStatusChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestAdditionsStatusChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestAdditionsStatusChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getFacility(self):
       """Facility this event relates to. """
       val = self.mgr.getService().IGuestAdditionsStatusChangedEvent_getFacility(self.handle)
       return AdditionsFacilityType(self.mgr, val)

   def getStatus(self):
       """The new facility status. """
       val = self.mgr.getService().IGuestAdditionsStatusChangedEvent_getStatus(self.handle)
       return AdditionsFacilityStatus(self.mgr, val)

   def getRunLevel(self):
       """The new run level. """
       val = self.mgr.getService().IGuestAdditionsStatusChangedEvent_getRunLevel(self.handle)
       return AdditionsRunLevelType(self.mgr, val)

   def getTimestamp(self):
       """The millisecond timestamp associated with the event. """
       val = self.mgr.getService().IGuestAdditionsStatusChangedEvent_getTimestamp(self.handle)
       return Long(self.mgr, val)



   _Attrs_ = {'facility':[getFacility,None],
              'status':[getStatus,None],
              'runLevel':[getRunLevel,None],
              'timestamp':[getTimestamp,None]}

class IGuestMonitorInfoChangedEvent(IEvent):
   """The guest reports cursor position data.
      Interface ID:
        {0B3CDEB2-808E-11E9-B773-133D9330F849}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IGuestMonitorInfoChangedEvent(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestMonitorInfoChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestMonitorInfoChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getOutput(self):
       """The virtual display output on which the monitor has changed. """
       val = self.mgr.getService().IGuestMonitorInfoChangedEvent_getOutput(self.handle)
       return UnsignedInt(self.mgr, val)



   _Attrs_ = {'output':[getOutput,None]}

class IStringArray(IUnknown):
   """
      When you need to return an array of strings asynchronously
      (under a progress) you cannot use by-value out parameter
      type="wstring" safearray="yes"
      dir="out", hence this wrapper.
    
      Interface ID:
        {3890B2C8-604D-11E9-92D3-53CB473DB9FB}    
   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IStringArray(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IStringArray._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IStringArray._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getValues(self):
       """ """
       val = self.mgr.getService().IStringArray_getValues(self.handle)
       return String(self.mgr, val, True)



   _Attrs_ = {'values':[getValues,None]}

class IFormValue(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IFormValue(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IFormValue._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IFormValue._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getType(self):
       """ """
       val = self.mgr.getService().IFormValue_getType(self.handle)
       return FormValueType(self.mgr, val)

   def getGeneration(self):
       """ """
       val = self.mgr.getService().IFormValue_getGeneration(self.handle)
       return Int(self.mgr, val)

   def getEnabled(self):
       """ """
       val = self.mgr.getService().IFormValue_getEnabled(self.handle)
       return Boolean(self.mgr, val)

   def getVisible(self):
       """ """
       val = self.mgr.getService().IFormValue_getVisible(self.handle)
       return Boolean(self.mgr, val)

   def getLabel(self):
       """ """
       val = self.mgr.getService().IFormValue_getLabel(self.handle)
       return String(self.mgr, val)

   def getDescription(self):
       """ """
       val = self.mgr.getService().IFormValue_getDescription(self.handle)
       return String(self.mgr, val)

   def getHelp(self):
       """ """
       val = self.mgr.getService().IFormValue_getHelp(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'type':[getType,None],
              'generation':[getGeneration,None],
              'enabled':[getEnabled,None],
              'visible':[getVisible,None],
              'label':[getLabel,None],
              'description':[getDescription,None],
              'help':[getHelp,None]}

class IBooleanFormValue(IFormValue):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IBooleanFormValue(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IBooleanFormValue._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IFormValue.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IBooleanFormValue._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getSelected(self):
       """       """
   
       req = (self.handle,)
       val = self.mgr.getService().IBooleanFormValue_getSelected(*req)
       
       return Boolean(self.mgr, val)

   def setSelected(self, _arg_selected):
       """       """
   
       req = (self.handle,)
       req += (_arg_selected,)
       val = self.mgr.getService().IBooleanFormValue_setSelected(*req)
       
       return IProgress(self.mgr, val)



   _Attrs_ = {}

class IRangedIntegerFormValue(IFormValue):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IRangedIntegerFormValue(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IRangedIntegerFormValue._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IFormValue.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IRangedIntegerFormValue._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getInteger(self):
       """       """
   
       req = (self.handle,)
       val = self.mgr.getService().IRangedIntegerFormValue_getInteger(*req)
       
       return Int(self.mgr, val)

   def setInteger(self, _arg_value):
       """       """
   
       req = (self.handle,)
       req += (_arg_value,)
       val = self.mgr.getService().IRangedIntegerFormValue_setInteger(*req)
       
       return IProgress(self.mgr, val)

   def getSuffix(self):
       """
        Counterpart of the IFormValue::label attribute.
        May be null or empty.  Usually used for units.
       """
       val = self.mgr.getService().IRangedIntegerFormValue_getSuffix(self.handle)
       return String(self.mgr, val)

   def getMinimum(self):
       """ """
       val = self.mgr.getService().IRangedIntegerFormValue_getMinimum(self.handle)
       return Int(self.mgr, val)

   def getMaximum(self):
       """ """
       val = self.mgr.getService().IRangedIntegerFormValue_getMaximum(self.handle)
       return Int(self.mgr, val)



   _Attrs_ = {'suffix':[getSuffix,None],
              'minimum':[getMinimum,None],
              'maximum':[getMaximum,None]}

class IStringFormValue(IFormValue):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IStringFormValue(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IStringFormValue._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IFormValue.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IStringFormValue._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getString(self):
       """       """
   
       req = (self.handle,)
       val = self.mgr.getService().IStringFormValue_getString(*req)
       
       return String(self.mgr, val)

   def setString(self, _arg_text):
       """       """
   
       req = (self.handle,)
       req += (_arg_text,)
       val = self.mgr.getService().IStringFormValue_setString(*req)
       
       return IProgress(self.mgr, val)

   def getMultiline(self):
       """ """
       val = self.mgr.getService().IStringFormValue_getMultiline(self.handle)
       return Boolean(self.mgr, val)



   _Attrs_ = {'multiline':[getMultiline,None]}

class IChoiceFormValue(IFormValue):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IChoiceFormValue(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IChoiceFormValue._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IFormValue.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IChoiceFormValue._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getSelectedIndex(self):
       """       """
   
       req = (self.handle,)
       val = self.mgr.getService().IChoiceFormValue_getSelectedIndex(*req)
       
       return Int(self.mgr, val)

   def setSelectedIndex(self, _arg_index):
       """       """
   
       req = (self.handle,)
       req += (_arg_index,)
       val = self.mgr.getService().IChoiceFormValue_setSelectedIndex(*req)
       
       return IProgress(self.mgr, val)

   def getValues(self):
       """ """
       val = self.mgr.getService().IChoiceFormValue_getValues(self.handle)
       return String(self.mgr, val, True)



   _Attrs_ = {'values':[getValues,None]}

class IForm(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IForm(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IForm._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IForm._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getValues(self):
       """ """
       val = self.mgr.getService().IForm_getValues(self.handle)
       return IFormValue(self.mgr, val, True)



   _Attrs_ = {'values':[getValues,None]}

class IVirtualSystemDescriptionForm(IForm):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return IVirtualSystemDescriptionForm(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVirtualSystemDescriptionForm._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IForm.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVirtualSystemDescriptionForm._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getVirtualSystemDescription(self):
       """       """
   
       req = (self.handle,)
       val = self.mgr.getService().IVirtualSystemDescriptionForm_getVirtualSystemDescription(*req)
       
       return IVirtualSystemDescription(self.mgr, val)



   _Attrs_ = {}

class ICloudNetworkGatewayInfo(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICloudNetworkGatewayInfo(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICloudNetworkGatewayInfo._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICloudNetworkGatewayInfo._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getPublicIP(self):
       """ """
       val = self.mgr.getService().ICloudNetworkGatewayInfo_getPublicIP(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'publicIP':[getPublicIP,None]}

class ICloudClient(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICloudClient(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICloudClient._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICloudClient._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getExportDescriptionForm(self, _arg_description):
       """
        Returns a form for editing the virtual system description for
        exporting a local VM into a cloud custom image.
      
        :param _arg_description: Virtual system description to be edited.

        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_description,)
       val = self.mgr.getService().ICloudClient_getExportDescriptionForm(*req)
       
       return IProgress(self.mgr,val["returnval"]), IVirtualSystemDescriptionForm(self.mgr,val["form"])

   def exportVM(self, _arg_description, _arg_progress):
       """
        Export local VM into the cloud, creating a custom image.
      
        :param _arg_description: Virtual system description object which describes the machine and all required parameters.
        :param _arg_progress: Progress object to track the operation completion.

       """
   
       req = (self.handle,)
       req += (_arg_description,)
       req += (_arg_progress,)
       val = self.mgr.getService().ICloudClient_exportVM(*req)
       
       return 

   def getLaunchDescriptionForm(self, _arg_description):
       """       """
   
       req = (self.handle,)
       req += (_arg_description,)
       val = self.mgr.getService().ICloudClient_getLaunchDescriptionForm(*req)
       
       return IProgress(self.mgr,val["returnval"]), IVirtualSystemDescriptionForm(self.mgr,val["form"])

   def launchVM(self, _arg_description):
       """       """
   
       req = (self.handle,)
       req += (_arg_description,)
       val = self.mgr.getService().ICloudClient_launchVM(*req)
       
       return IProgress(self.mgr, val)

   def getImportDescriptionForm(self, _arg_description):
       """
        Returns a form for editing the virtual system description for
        import from cloud.
      
        :param _arg_description: Virtual system description to be edited.

        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_description,)
       val = self.mgr.getService().ICloudClient_getImportDescriptionForm(*req)
       
       return IProgress(self.mgr,val["returnval"]), IVirtualSystemDescriptionForm(self.mgr,val["form"])

   def importInstance(self, _arg_description, _arg_progress):
       """
        Import an existing cloud instance to the local host.
        All needed parameters are passed in the description (VSD).
      
        :param _arg_description: VirtualSystemDescription object which is describing a machine and all required parameters.
        :param _arg_progress: Progress object to track the operation completion.

       """
   
       req = (self.handle,)
       req += (_arg_description,)
       req += (_arg_progress,)
       val = self.mgr.getService().ICloudClient_importInstance(*req)
       
       return 

   def listInstances(self, _arg_machineState):
       """
        Returns the list of the instances in the Cloud.
      
        :param _arg_machineState: State of each VM.


        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_machineState,)
       val = self.mgr.getService().ICloudClient_listInstances(*req)
       
       return IProgress(self.mgr,val["returnval"]), IStringArray(self.mgr,val["returnNames"]), IStringArray(self.mgr,val["returnIds"])

   def listImages(self, _arg_imageState):
       """
        Returns the list of the images in the Cloud.
      
        :param _arg_imageState: State of each image.


        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_imageState,)
       val = self.mgr.getService().ICloudClient_listImages(*req)
       
       return IProgress(self.mgr,val["returnval"]), IStringArray(self.mgr,val["returnNames"]), IStringArray(self.mgr,val["returnIds"])

   def getInstanceInfo(self, _arg_uid, _arg_description):
       """
        Returns the information about an instance in the Cloud.
      
        :param _arg_uid: The id of instance in the Cloud.
        :param _arg_description: VirtualSystemDescription object which is describing a machine
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_uid,)
       req += (_arg_description,)
       val = self.mgr.getService().ICloudClient_getInstanceInfo(*req)
       
       return IProgress(self.mgr, val)

   def startInstance(self, _arg_uid):
       """
        Start an existing instance with passed id.
      
        :param _arg_uid: The id of instance in the Cloud.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_uid,)
       val = self.mgr.getService().ICloudClient_startInstance(*req)
       
       return IProgress(self.mgr, val)

   def pauseInstance(self, _arg_uid):
       """
        Pause an existing instance with passed id.
      
        :param _arg_uid: The id of instance in the Cloud.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_uid,)
       val = self.mgr.getService().ICloudClient_pauseInstance(*req)
       
       return IProgress(self.mgr, val)

   def terminateInstance(self, _arg_uid):
       """
        Terminate an existing instance with passed id.
      
        :param _arg_uid: the id of instance in the Cloud.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_uid,)
       val = self.mgr.getService().ICloudClient_terminateInstance(*req)
       
       return IProgress(self.mgr, val)

   def createImage(self, _arg_parameters):
       """
        Create an image in the Cloud.
      
        :param _arg_parameters: Each parameter in the array must be in the form "name=value".
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_parameters,)
       val = self.mgr.getService().ICloudClient_createImage(*req)
       
       return IProgress(self.mgr, val)

   def exportImage(self, _arg_image, _arg_parameters):
       """
        Export an existing VBox image in the Cloud.
      
        :param _arg_image: Reference to the existing VBox image.
        :param _arg_parameters: Each parameter in the array must be in the form "name=value".
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_image,)
       req += (_arg_parameters,)
       val = self.mgr.getService().ICloudClient_exportImage(*req)
       
       return IProgress(self.mgr, val)

   def importImage(self, _arg_uid, _arg_parameters):
       """
        Import an existing image in the Cloud to the local host.
      
        :param _arg_uid: the id of image in the Cloud.
        :param _arg_parameters: Each parameter in the array must be in the form "name=value".
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_uid,)
       req += (_arg_parameters,)
       val = self.mgr.getService().ICloudClient_importImage(*req)
       
       return IProgress(self.mgr, val)

   def deleteImage(self, _arg_uid):
       """
        Delete an existing image with passed id from the Cloud.
      
        :param _arg_uid: The id of image in the Cloud.
        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_uid,)
       val = self.mgr.getService().ICloudClient_deleteImage(*req)
       
       return IProgress(self.mgr, val)

   def getImageInfo(self, _arg_uid):
       """
        Returns the information about an image in the Cloud.
      
        :param _arg_uid: The id of image in the Cloud.

        :return: Progress object to track the operation completion.
        :rtype: IProgress

       """
   
       req = (self.handle,)
       req += (_arg_uid,)
       val = self.mgr.getService().ICloudClient_getImageInfo(*req)
       
       return IProgress(self.mgr,val["returnval"]), IStringArray(self.mgr,val["infoArray"])

   def startCloudNetworkGateway(self, _arg_network, _arg_sshPublicKey):
       """       """
   
       req = (self.handle,)
       req += (_arg_network,)
       req += (_arg_sshPublicKey,)
       val = self.mgr.getService().ICloudClient_startCloudNetworkGateway(*req)
       
       return IProgress(self.mgr,val["returnval"]), ICloudNetworkGatewayInfo(self.mgr,val["gatewayInfo"])



   _Attrs_ = {}

class ICloudProfile(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICloudProfile(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICloudProfile._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICloudProfile._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getProperty(self, _arg_name):
       """
        Returns the value of the cloud profile property with the given name.

        If the requested data @a name does not exist, this function will
        succeed and return an empty string in the @a value argument.

        
        :param _arg_name: Name of the property to get.
        :return: Current property value.
        :rtype: wstring

        Expected result codes:
        E_INVALIDARG@a name is @c null or empty.
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().ICloudProfile_getProperty(*req)
       
       return String(self.mgr, val)

   def setProperty(self, _arg_name, _arg_value):
       """
        Sets the value of the cloud profile property with the given name.

        Setting the property value to @c null or an empty string is equivalent
        to deleting the existing value.

        
        :param _arg_name: Name of the property to set.
        :param _arg_value: Property value to set.

        Expected result codes:
        E_INVALIDARG@a name is @c null or empty.
       """
   
       req = (self.handle,)
       req += (_arg_name,)
       req += (_arg_value,)
       val = self.mgr.getService().ICloudProfile_setProperty(*req)
       
       return 

   def getProperties(self, _arg_names):
       """
        Returns values for a group of properties in one call.

        The names of the properties to get are specified using the @a names
        argument which is a list of comma-separated property names or
        an empty string if all properties are to be returned.
        

        The method returns two arrays, the array of property names corresponding
        to the @a names argument and the current values of these properties.
        Both arrays have the same number of elements with each element at the
        given index in the first array corresponds to an element at the same
        index in the second array.
      
        :param _arg_names: Names of properties to get.

        :return: Values of returned properties.
        :rtype: List[wstring]

        .. note:: Currently the value of this argument is ignored and the method
        always returns all existing properties.
       """
   
       req = (self.handle,)
       req += (_arg_names,)
       val = self.mgr.getService().ICloudProfile_getProperties(*req)
       
       return String(self.mgr,val["returnval"], True), String(self.mgr,val["returnNames"], True)

   def setProperties(self, _arg_names, _arg_values):
       """
        Updates profile, changing/adding/removing properties.

        The names of the properties to set are passed in the @a names
        array along with the new values for them in the @a values array. Both
        arrays have the same number of elements with each element at the given
        index in the first array corresponding to an element at the same index
        in the second array.

        If there is at least one property name in @a names that is not valid,
        the method will fail before changing the values of any other properties
        from the @a names array.

        Using this method over #setProperty is preferred if you
        need to set several properties at once since it is more efficient.

        Setting the property value to @c null or an empty string is equivalent
        to deleting the existing value.
      
        :param _arg_names: Names of properties.
        :param _arg_values: Values of set properties.

       """
   
       req = (self.handle,)
       req += (_arg_names,)
       req += (_arg_values,)
       val = self.mgr.getService().ICloudProfile_setProperties(*req)
       
       return 

   def remove(self):
       """
        Deletes a profile.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().ICloudProfile_remove(*req)
       
       return 

   def createCloudClient(self):
       """
        Creates a cloud client for this cloud profile.
      
        :return: The cloud client object reference.
        :rtype: ICloudClient

       """
   
       req = (self.handle,)
       val = self.mgr.getService().ICloudProfile_createCloudClient(*req)
       
       return ICloudClient(self.mgr, val)

   def getName(self):
       """
        Returns the profile name.
       """
       val = self.mgr.getService().ICloudProfile_getName(self.handle)
       return String(self.mgr, val)

   def setName(self, value):
       """
        Returns the profile name.
       """
       _this=self.handle
       if type(value) in [int, bool, str]:
            _val = value
       else:
            _val = value.handle
       self.mgr.getService().ICloudProfile_setName(_this, _val)

   def getProviderId(self):
       """
        Returns provider identifier tied with this profile.
       """
       val = self.mgr.getService().ICloudProfile_getProviderId(self.handle)
       return String(self.mgr, val)



   _Attrs_ = {'name':[getName,setName,],
              'providerId':[getProviderId,None]}

class ICloudProvider(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICloudProvider(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICloudProvider._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICloudProvider._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getPropertyDescription(self, _arg_name):
       """       """
   
       req = (self.handle,)
       req += (_arg_name,)
       val = self.mgr.getService().ICloudProvider_getPropertyDescription(*req)
       
       return String(self.mgr, val)

   def createProfile(self, _arg_profileName, _arg_names, _arg_values):
       """
        Creates a new profile.
      
        :param _arg_profileName: The profile name. Must not exist, otherwise an error is raised.
        :param _arg_names: Names of properties.
        :param _arg_values: Values of set properties.

       """
   
       req = (self.handle,)
       req += (_arg_profileName,)
       req += (_arg_names,)
       req += (_arg_values,)
       val = self.mgr.getService().ICloudProvider_createProfile(*req)
       
       return 

   def importProfiles(self):
       """
        Import the profiles from the original source
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().ICloudProvider_importProfiles(*req)
       
       return 

   def restoreProfiles(self):
       """
        Restores the old local profiles if they exist
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().ICloudProvider_restoreProfiles(*req)
       
       return 

   def saveProfiles(self):
       """
        Saves the local profiles
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().ICloudProvider_saveProfiles(*req)
       
       return 

   def getProfileByName(self, _arg_profileName):
       """       """
   
       req = (self.handle,)
       req += (_arg_profileName,)
       val = self.mgr.getService().ICloudProvider_getProfileByName(*req)
       
       return ICloudProfile(self.mgr, val)

   def prepareUninstall(self):
       """
        The caller requests the cloud provider to cease operation. Should
        return an error if this is currently not possible (due to ongoing
        cloud activity, possibly by a different API client). However, this
        must not wait for the completion for a larger amount of time (ideally
        stays below a second of execution time). If this succeeds it should
        leave the cloud provider in a state which does not allow starting new
        operations.
      

       """
   
       req = (self.handle,)
       val = self.mgr.getService().ICloudProvider_prepareUninstall(*req)
       
       return 

   def getName(self):
       """Returns the long name of the provider. Includes vendor and precise
        product name spelled out in the preferred way. """
       val = self.mgr.getService().ICloudProvider_getName(self.handle)
       return String(self.mgr, val)

   def getShortName(self):
       """Returns the short name of the provider. Less than 8 ASCII chars,
        using acronyms. No vendor name, but can contain a hint if it's a 3rd
        party implementation for this cloud provider, to keep it unique. """
       val = self.mgr.getService().ICloudProvider_getShortName(self.handle)
       return String(self.mgr, val)

   def getId(self):
       """Returns the UUID of this cloud provider. """
       val = self.mgr.getService().ICloudProvider_getId(self.handle)
       return String(self.mgr, val)

   def getProfiles(self):
       """Returns all profiles for this cloud provider. """
       val = self.mgr.getService().ICloudProvider_getProfiles(self.handle)
       return ICloudProfile(self.mgr, val, True)

   def getProfileNames(self):
       """Returns all profile names for this cloud provider. """
       val = self.mgr.getService().ICloudProvider_getProfileNames(self.handle)
       return String(self.mgr, val, True)

   def getSupportedPropertyNames(self):
       """
        Returns the supported property names.
       """
       val = self.mgr.getService().ICloudProvider_getSupportedPropertyNames(self.handle)
       return String(self.mgr, val, True)



   _Attrs_ = {'name':[getName,None],
              'shortName':[getShortName,None],
              'id':[getId,None],
              'profiles':[getProfiles,None],
              'profileNames':[getProfileNames,None],
              'supportedPropertyNames':[getSupportedPropertyNames,None]}

class ICloudProviderManager(IUnknown):
   """   """
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray
       if self.isarray:
           for strHnd in handle:
               mgr.register(strHnd)
       else:
           mgr.register(self.handle)

   def __del__(self):
       self.releaseRemote()

   def releaseRemote(self):
        try:
            if self.handle is not None:
               if self.isarray:
                   for strHnd in self.handle:
                       self.mgr.unregister(strHnd)
               else:
                   self.mgr.unregister(self.handle)
               self.handle = None;
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

   def __getitem__(self, index):
      if self.isarray:
          return ICloudProviderManager(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")

   def __str__(self):
        if self.isarray:
            return str(self.handle)
        else:
            return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICloudProviderManager._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICloudProviderManager._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val
   
   def getProviderById(self, _arg_providerId):
       """       """
   
       req = (self.handle,)
       req += (_arg_providerId,)
       val = self.mgr.getService().ICloudProviderManager_getProviderById(*req)
       
       return ICloudProvider(self.mgr, val)

   def getProviderByShortName(self, _arg_providerName):
       """       """
   
       req = (self.handle,)
       req += (_arg_providerName,)
       val = self.mgr.getService().ICloudProviderManager_getProviderByShortName(*req)
       
       return ICloudProvider(self.mgr, val)

   def getProviderByName(self, _arg_providerName):
       """       """
   
       req = (self.handle,)
       req += (_arg_providerName,)
       val = self.mgr.getService().ICloudProviderManager_getProviderByName(*req)
       
       return ICloudProvider(self.mgr, val)

   def getProviders(self):
       """Returns all supported cloud providers. """
       val = self.mgr.getService().ICloudProviderManager_getProviders(self.handle)
       return ICloudProvider(self.mgr, val, True)



   _Attrs_ = {'providers':[getProviders,None]}
class IPCIDeviceAttachment:
    """
      Information about PCI attachments.
    """
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.name = String(self.mgr, handle._name)
       
          self.isPhysicalDevice = Boolean(self.mgr, handle._isPhysicalDevice)
       
          self.hostAddress = Int(self.mgr, handle._hostAddress)
       
          self.guestAddress = Int(self.mgr, handle._guestAddress)
       
          pass

   
    def getName(self):
       return self.name

    def setName(self):
       raise Error('setters not supported')
    
    def getIsPhysicalDevice(self):
       return self.isPhysicalDevice

    def setIsPhysicalDevice(self):
       raise Error('setters not supported')
    
    def getHostAddress(self):
       return self.hostAddress

    def setHostAddress(self):
       raise Error('setters not supported')
    
    def getGuestAddress(self):
       return self.guestAddress

    def setGuestAddress(self):
       raise Error('setters not supported')
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

    def __getitem__(self, index):
      if self.isarray:
          return IPCIDeviceAttachment(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")


class IVRDEServerInfo:
    """
      Contains information about the remote desktop (VRDE) server capabilities and status.
      This is used in the  attribute.
    """
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.active = Boolean(self.mgr, handle._active)
       
          self.port = Int(self.mgr, handle._port)
       
          self.numberOfClients = UnsignedInt(self.mgr, handle._numberOfClients)
       
          self.beginTime = Long(self.mgr, handle._beginTime)
       
          self.endTime = Long(self.mgr, handle._endTime)
       
          self.bytesSent = Long(self.mgr, handle._bytesSent)
       
          self.bytesSentTotal = Long(self.mgr, handle._bytesSentTotal)
       
          self.bytesReceived = Long(self.mgr, handle._bytesReceived)
       
          self.bytesReceivedTotal = Long(self.mgr, handle._bytesReceivedTotal)
       
          self.user = String(self.mgr, handle._user)
       
          self.domain = String(self.mgr, handle._domain)
       
          self.clientName = String(self.mgr, handle._clientName)
       
          self.clientIP = String(self.mgr, handle._clientIP)
       
          self.clientVersion = UnsignedInt(self.mgr, handle._clientVersion)
       
          self.encryptionStyle = UnsignedInt(self.mgr, handle._encryptionStyle)
       
          pass

   
    def getActive(self):
       return self.active

    def setActive(self):
       raise Error('setters not supported')
    
    def getPort(self):
       return self.port

    def setPort(self):
       raise Error('setters not supported')
    
    def getNumberOfClients(self):
       return self.numberOfClients

    def setNumberOfClients(self):
       raise Error('setters not supported')
    
    def getBeginTime(self):
       return self.beginTime

    def setBeginTime(self):
       raise Error('setters not supported')
    
    def getEndTime(self):
       return self.endTime

    def setEndTime(self):
       raise Error('setters not supported')
    
    def getBytesSent(self):
       return self.bytesSent

    def setBytesSent(self):
       raise Error('setters not supported')
    
    def getBytesSentTotal(self):
       return self.bytesSentTotal

    def setBytesSentTotal(self):
       raise Error('setters not supported')
    
    def getBytesReceived(self):
       return self.bytesReceived

    def setBytesReceived(self):
       raise Error('setters not supported')
    
    def getBytesReceivedTotal(self):
       return self.bytesReceivedTotal

    def setBytesReceivedTotal(self):
       raise Error('setters not supported')
    
    def getUser(self):
       return self.user

    def setUser(self):
       raise Error('setters not supported')
    
    def getDomain(self):
       return self.domain

    def setDomain(self):
       raise Error('setters not supported')
    
    def getClientName(self):
       return self.clientName

    def setClientName(self):
       raise Error('setters not supported')
    
    def getClientIP(self):
       return self.clientIP

    def setClientIP(self):
       raise Error('setters not supported')
    
    def getClientVersion(self):
       return self.clientVersion

    def setClientVersion(self):
       raise Error('setters not supported')
    
    def getEncryptionStyle(self):
       return self.encryptionStyle

    def setEncryptionStyle(self):
       raise Error('setters not supported')
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

    def __getitem__(self, index):
      if self.isarray:
          return IVRDEServerInfo(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")


class IGuestOSType:
    """
    """
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.familyId = String(self.mgr, handle._familyId)
       
          self.familyDescription = String(self.mgr, handle._familyDescription)
       
          self.id = String(self.mgr, handle._id)
       
          self.description = String(self.mgr, handle._description)
       
          self.is64Bit = Boolean(self.mgr, handle._is64Bit)
       
          self.recommendedIOAPIC = Boolean(self.mgr, handle._recommendedIOAPIC)
       
          self.recommendedVirtEx = Boolean(self.mgr, handle._recommendedVirtEx)
       
          self.recommendedRAM = UnsignedInt(self.mgr, handle._recommendedRAM)
       
          self.recommendedGraphicsController = GraphicsControllerType(self.mgr, handle._recommendedGraphicsController)
       
          self.recommendedVRAM = UnsignedInt(self.mgr, handle._recommendedVRAM)
       
          self.recommended2DVideoAcceleration = Boolean(self.mgr, handle._recommended2DVideoAcceleration)
       
          self.recommended3DAcceleration = Boolean(self.mgr, handle._recommended3DAcceleration)
       
          self.recommendedHDD = Long(self.mgr, handle._recommendedHDD)
       
          self.adapterType = NetworkAdapterType(self.mgr, handle._adapterType)
       
          self.recommendedPAE = Boolean(self.mgr, handle._recommendedPAE)
       
          self.recommendedDVDStorageController = StorageControllerType(self.mgr, handle._recommendedDVDStorageController)
       
          self.recommendedDVDStorageBus = StorageBus(self.mgr, handle._recommendedDVDStorageBus)
       
          self.recommendedHDStorageController = StorageControllerType(self.mgr, handle._recommendedHDStorageController)
       
          self.recommendedHDStorageBus = StorageBus(self.mgr, handle._recommendedHDStorageBus)
       
          self.recommendedFirmware = FirmwareType(self.mgr, handle._recommendedFirmware)
       
          self.recommendedUSBHID = Boolean(self.mgr, handle._recommendedUSBHID)
       
          self.recommendedHPET = Boolean(self.mgr, handle._recommendedHPET)
       
          self.recommendedUSBTablet = Boolean(self.mgr, handle._recommendedUSBTablet)
       
          self.recommendedRTCUseUTC = Boolean(self.mgr, handle._recommendedRTCUseUTC)
       
          self.recommendedChipset = ChipsetType(self.mgr, handle._recommendedChipset)
       
          self.recommendedAudioController = AudioControllerType(self.mgr, handle._recommendedAudioController)
       
          self.recommendedAudioCodec = AudioCodecType(self.mgr, handle._recommendedAudioCodec)
       
          self.recommendedFloppy = Boolean(self.mgr, handle._recommendedFloppy)
       
          self.recommendedUSB = Boolean(self.mgr, handle._recommendedUSB)
       
          self.recommendedUSB3 = Boolean(self.mgr, handle._recommendedUSB3)
       
          self.recommendedTFReset = Boolean(self.mgr, handle._recommendedTFReset)
       
          self.recommendedX2APIC = Boolean(self.mgr, handle._recommendedX2APIC)
       
          pass

   
    def getFamilyId(self):
       return self.familyId

    def setFamilyId(self):
       raise Error('setters not supported')
    
    def getFamilyDescription(self):
       return self.familyDescription

    def setFamilyDescription(self):
       raise Error('setters not supported')
    
    def getId(self):
       return self.id

    def setId(self):
       raise Error('setters not supported')
    
    def getDescription(self):
       return self.description

    def setDescription(self):
       raise Error('setters not supported')
    
    def getIs64Bit(self):
       return self.is64Bit

    def setIs64Bit(self):
       raise Error('setters not supported')
    
    def getRecommendedIOAPIC(self):
       return self.recommendedIOAPIC

    def setRecommendedIOAPIC(self):
       raise Error('setters not supported')
    
    def getRecommendedVirtEx(self):
       return self.recommendedVirtEx

    def setRecommendedVirtEx(self):
       raise Error('setters not supported')
    
    def getRecommendedRAM(self):
       return self.recommendedRAM

    def setRecommendedRAM(self):
       raise Error('setters not supported')
    
    def getRecommendedGraphicsController(self):
       return self.recommendedGraphicsController

    def setRecommendedGraphicsController(self):
       raise Error('setters not supported')
    
    def getRecommendedVRAM(self):
       return self.recommendedVRAM

    def setRecommendedVRAM(self):
       raise Error('setters not supported')
    
    def getRecommended2DVideoAcceleration(self):
       return self.recommended2DVideoAcceleration

    def setRecommended2DVideoAcceleration(self):
       raise Error('setters not supported')
    
    def getRecommended3DAcceleration(self):
       return self.recommended3DAcceleration

    def setRecommended3DAcceleration(self):
       raise Error('setters not supported')
    
    def getRecommendedHDD(self):
       return self.recommendedHDD

    def setRecommendedHDD(self):
       raise Error('setters not supported')
    
    def getAdapterType(self):
       return self.adapterType

    def setAdapterType(self):
       raise Error('setters not supported')
    
    def getRecommendedPAE(self):
       return self.recommendedPAE

    def setRecommendedPAE(self):
       raise Error('setters not supported')
    
    def getRecommendedDVDStorageController(self):
       return self.recommendedDVDStorageController

    def setRecommendedDVDStorageController(self):
       raise Error('setters not supported')
    
    def getRecommendedDVDStorageBus(self):
       return self.recommendedDVDStorageBus

    def setRecommendedDVDStorageBus(self):
       raise Error('setters not supported')
    
    def getRecommendedHDStorageController(self):
       return self.recommendedHDStorageController

    def setRecommendedHDStorageController(self):
       raise Error('setters not supported')
    
    def getRecommendedHDStorageBus(self):
       return self.recommendedHDStorageBus

    def setRecommendedHDStorageBus(self):
       raise Error('setters not supported')
    
    def getRecommendedFirmware(self):
       return self.recommendedFirmware

    def setRecommendedFirmware(self):
       raise Error('setters not supported')
    
    def getRecommendedUSBHID(self):
       return self.recommendedUSBHID

    def setRecommendedUSBHID(self):
       raise Error('setters not supported')
    
    def getRecommendedHPET(self):
       return self.recommendedHPET

    def setRecommendedHPET(self):
       raise Error('setters not supported')
    
    def getRecommendedUSBTablet(self):
       return self.recommendedUSBTablet

    def setRecommendedUSBTablet(self):
       raise Error('setters not supported')
    
    def getRecommendedRTCUseUTC(self):
       return self.recommendedRTCUseUTC

    def setRecommendedRTCUseUTC(self):
       raise Error('setters not supported')
    
    def getRecommendedChipset(self):
       return self.recommendedChipset

    def setRecommendedChipset(self):
       raise Error('setters not supported')
    
    def getRecommendedAudioController(self):
       return self.recommendedAudioController

    def setRecommendedAudioController(self):
       raise Error('setters not supported')
    
    def getRecommendedAudioCodec(self):
       return self.recommendedAudioCodec

    def setRecommendedAudioCodec(self):
       raise Error('setters not supported')
    
    def getRecommendedFloppy(self):
       return self.recommendedFloppy

    def setRecommendedFloppy(self):
       raise Error('setters not supported')
    
    def getRecommendedUSB(self):
       return self.recommendedUSB

    def setRecommendedUSB(self):
       raise Error('setters not supported')
    
    def getRecommendedUSB3(self):
       return self.recommendedUSB3

    def setRecommendedUSB3(self):
       raise Error('setters not supported')
    
    def getRecommendedTFReset(self):
       return self.recommendedTFReset

    def setRecommendedTFReset(self):
       raise Error('setters not supported')
    
    def getRecommendedX2APIC(self):
       return self.recommendedX2APIC

    def setRecommendedX2APIC(self):
       raise Error('setters not supported')
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

    def __getitem__(self, index):
      if self.isarray:
          return IGuestOSType(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")


class IAdditionsFacility:
    """
      Structure representing a Guest Additions facility.
    """
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.classType = AdditionsFacilityClass(self.mgr, handle._classType)
       
          self.lastUpdated = Long(self.mgr, handle._lastUpdated)
       
          self.name = String(self.mgr, handle._name)
       
          self.status = AdditionsFacilityStatus(self.mgr, handle._status)
       
          self.type = AdditionsFacilityType(self.mgr, handle._type)
       
          pass

   
    def getClassType(self):
       return self.classType

    def setClassType(self):
       raise Error('setters not supported')
    
    def getLastUpdated(self):
       return self.lastUpdated

    def setLastUpdated(self):
       raise Error('setters not supported')
    
    def getName(self):
       return self.name

    def setName(self):
       raise Error('setters not supported')
    
    def getStatus(self):
       return self.status

    def setStatus(self):
       raise Error('setters not supported')
    
    def getType(self):
       return self.type

    def setType(self):
       raise Error('setters not supported')
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

    def __getitem__(self, index):
      if self.isarray:
          return IAdditionsFacility(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")


class IMediumAttachment:
    """
      The IMediumAttachment interface links storage media to virtual machines.
      For each medium () which has been attached to a
      storage controller () of a machine
      () via the 
      method, one instance of IMediumAttachment is added to the machine's
       array attribute.

      Each medium attachment specifies the storage controller as well as a
      port and device number and the IMedium instance representing a virtual
      hard disk or floppy or DVD image.

      For removable media (DVDs or floppies), there are two additional
      options. For one, the IMedium instance can be @c null to represent
      an empty drive with no media inserted (see );
      secondly, the medium can be one of the pseudo-media for host drives
      listed in  or .

      Attaching Hard Disks

      Hard disks are attached to virtual machines using the
       method and detached using the
       method. Depending on a medium's
      type (see ), hard disks are attached either
      directly or indirectly.

      When a hard disk is being attached directly, it is associated with the
      virtual machine and used for hard disk operations when the machine is
      running. When a hard disk is being attached indirectly, a new differencing
      hard disk linked to it is implicitly created and this differencing hard
      disk is associated with the machine and used for hard disk operations.
      This also means that if  performs
      a direct attachment then the same hard disk will be returned in response
      to the subsequent  call; however if
      an indirect attachment is performed then
       will return the implicitly created
      differencing hard disk, not the original one passed to . In detail:

      
        Normal base hard disks that do not have children (i.e.
            differencing hard disks linked to them) and that are not already
            attached to virtual machines in snapshots are attached directly.
            Otherwise, they are attached indirectly because having
            dependent children or being part of the snapshot makes it impossible
            to modify hard disk contents without breaking the integrity of the
            dependent party. The  attribute allows to
            quickly determine the kind of the attachment for the given hard
            disk. Note that if a normal base hard disk is to be indirectly
            attached to a virtual machine with snapshots then a special
            procedure called smart attachment is performed (see below).
        Normal differencing hard disks are like normal base hard disks:
            they are attached directly if they do not have children and are
            not attached to virtual machines in snapshots, and indirectly
            otherwise. Note that the smart attachment procedure is never performed
            for differencing hard disks.
        Immutable hard disks are always attached indirectly because
            they are designed to be non-writable. If an immutable hard disk is
            attached to a virtual machine with snapshots then a special
            procedure called smart attachment is performed (see below).
        Writethrough hard disks are always attached directly,
            also as designed. This also means that writethrough hard disks cannot
            have other hard disks linked to them at all.
        Shareable hard disks are always attached directly,
            also as designed. This also means that shareable hard disks cannot
            have other hard disks linked to them at all. They behave almost
            like writethrough hard disks, except that shareable hard disks can
            be attached to several virtual machines which are running, allowing
            concurrent accesses. You need special cluster software running in
            the virtual machines to make use of such disks.
      

      Note that the same hard disk, regardless of its type, may be attached to
      more than one virtual machine at a time. In this case, the machine that is
      started first gains exclusive access to the hard disk and attempts to
      start other machines having this hard disk attached will fail until the
      first machine is powered down.

      Detaching hard disks is performed in a deferred fashion. This means
      that the given hard disk remains associated with the given machine after a
      successful  call until
       is called to save all changes to
      machine settings to disk. This deferring is necessary to guarantee that
      the hard disk configuration may be restored at any time by a call to
       before the settings
      are saved (committed).

      Note that if  is called after
      indirectly attaching some hard disks to the machine but before a call to
       is made, it will implicitly delete
      all differencing hard disks implicitly created by
       for these indirect attachments.
      Such implicitly created hard disks will also be immediately deleted when
      detached explicitly using the 
      call if it is made before . This
      implicit deletion is safe because newly created differencing hard
      disks do not contain any user data.

      However, keep in mind that detaching differencing hard disks that were
      implicitly created by 
      before the last  call will
      not implicitly delete them as they may already contain some data
      (for example, as a result of virtual machine execution). If these hard
      disks are no more necessary, the caller can always delete them explicitly
      using  after they are actually de-associated
      from this machine by the  call.

      Smart Attachment

      When normal base or immutable hard disks are indirectly attached to a
      virtual machine then some additional steps are performed to make sure the
      virtual machine will have the most recent "view" of the hard disk being
      attached. These steps include walking through the machine's snapshots
      starting from the current one and going through ancestors up to the first
      snapshot. Hard disks attached to the virtual machine in all
      of the encountered snapshots are checked whether they are descendants of
      the given normal base or immutable hard disk. The first found child (which
      is the differencing hard disk) will be used instead of the normal base or
      immutable hard disk as a parent for creating a new differencing hard disk
      that will be actually attached to the machine. And only if no descendants
      are found or if the virtual machine does not have any snapshots then the
      normal base or immutable hard disk will be used itself as a parent for
      this differencing hard disk.

      It is easier to explain what smart attachment does using the
      following example:
      
BEFORE attaching B.vdi:       AFTER attaching B.vdi:

Snapshot 1 (B.vdi)            Snapshot 1 (B.vdi)
 Snapshot 2 (D1->B.vdi)        Snapshot 2 (D1->B.vdi)
  Snapshot 3 (D2->D1.vdi)       Snapshot 3 (D2->D1.vdi)
   Snapshot 4 (none)             Snapshot 4 (none)
    CurState   (none)             CurState   (D3->D2.vdi)

                              NOT
                                 ...
                                  CurState   (D3->B.vdi)
      
      The first column is the virtual machine configuration before the base hard
      disk B.vdi is attached, the second column shows the machine after
      this hard disk is attached. Constructs like D1->B.vdi and similar
      mean that the hard disk that is actually attached to the machine is a
      differencing hard disk, D1.vdi, which is linked to (based on)
      another hard disk, B.vdi.

      As we can see from the example, the hard disk B.vdi was detached
      from the machine before taking Snapshot 4. Later, after Snapshot 4 was
      taken, the user decides to attach B.vdi again. B.vdi has
      dependent child hard disks (D1.vdi, D2.vdi), therefore
      it cannot be attached directly and needs an indirect attachment (i.e.
      implicit creation of a new differencing hard disk). Due to the smart
      attachment procedure, the new differencing hard disk
      (D3.vdi) will be based on D2.vdi, not on
      B.vdi itself, since D2.vdi is the most recent view of
      B.vdi existing for this snapshot branch of the given virtual
      machine.

      Note that if there is more than one descendant hard disk of the given base
      hard disk found in a snapshot, and there is an exact device, channel and
      bus match, then this exact match will be used. Otherwise, the youngest
      descendant will be picked up.

      There is one more important aspect of the smart attachment procedure which
      is not related to snapshots at all. Before walking through the snapshots
      as described above, the backup copy of the current list of hard disk
      attachment is searched for descendants. This backup copy is created when
      the hard disk configuration is changed for the first time after the last
       call and used by
       to undo the recent hard disk
      changes. When such a descendant is found in this backup copy, it will be
      simply re-attached back, without creating a new differencing hard disk for
      it. This optimization is necessary to make it possible to re-attach the
      base or immutable hard disk to a different bus, channel or device slot
      without losing the contents of the differencing hard disk actually
      attached to the machine in place of it.

    """
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.machine = IMachine(self.mgr, handle._machine)
       
          self.medium = IMedium(self.mgr, handle._medium)
       
          self.controller = String(self.mgr, handle._controller)
       
          self.port = Int(self.mgr, handle._port)
       
          self.device = Int(self.mgr, handle._device)
       
          self.type = DeviceType(self.mgr, handle._type)
       
          self.passthrough = Boolean(self.mgr, handle._passthrough)
       
          self.temporaryEject = Boolean(self.mgr, handle._temporaryEject)
       
          self.isEjected = Boolean(self.mgr, handle._isEjected)
       
          self.nonRotational = Boolean(self.mgr, handle._nonRotational)
       
          self.discard = Boolean(self.mgr, handle._discard)
       
          self.hotPluggable = Boolean(self.mgr, handle._hotPluggable)
       
          self.bandwidthGroup = IBandwidthGroup(self.mgr, handle._bandwidthGroup)
       
          pass

   
    def getMachine(self):
       return self.machine

    def setMachine(self):
       raise Error('setters not supported')
    
    def getMedium(self):
       return self.medium

    def setMedium(self):
       raise Error('setters not supported')
    
    def getController(self):
       return self.controller

    def setController(self):
       raise Error('setters not supported')
    
    def getPort(self):
       return self.port

    def setPort(self):
       raise Error('setters not supported')
    
    def getDevice(self):
       return self.device

    def setDevice(self):
       raise Error('setters not supported')
    
    def getType(self):
       return self.type

    def setType(self):
       raise Error('setters not supported')
    
    def getPassthrough(self):
       return self.passthrough

    def setPassthrough(self):
       raise Error('setters not supported')
    
    def getTemporaryEject(self):
       return self.temporaryEject

    def setTemporaryEject(self):
       raise Error('setters not supported')
    
    def getIsEjected(self):
       return self.isEjected

    def setIsEjected(self):
       raise Error('setters not supported')
    
    def getNonRotational(self):
       return self.nonRotational

    def setNonRotational(self):
       raise Error('setters not supported')
    
    def getDiscard(self):
       return self.discard

    def setDiscard(self):
       raise Error('setters not supported')
    
    def getHotPluggable(self):
       return self.hotPluggable

    def setHotPluggable(self):
       raise Error('setters not supported')
    
    def getBandwidthGroup(self):
       return self.bandwidthGroup

    def setBandwidthGroup(self):
       raise Error('setters not supported')
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError("iteration over non-sequence")

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError("iteration over non-sequence")

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError("iteration over non-sequence")

    def __getitem__(self, index):
      if self.isarray:
          return IMediumAttachment(self.mgr, self.handle[index])
      raise TypeError("iteration over non-sequence")


class SettingsVersion:
   """
      Settings version of VirtualBox settings files. This is written to
      the "version" attribute of the root "VirtualBox" element in the settings
      file XML and indicates which VirtualBox version wrote the file.
    
      "Null" = 0:
        Null value, indicates invalid version.
      
      "v1_0" = 1:
        Legacy settings version, not currently supported.
      
      "v1_1" = 2:
        Legacy settings version, not currently supported.
      
      "v1_2" = 3:
        Legacy settings version, not currently supported.
      
      "v1_3pre" = 4:
        Legacy settings version, not currently supported.
      
      "v1_3" = 5:
        Settings version "1.3", written by VirtualBox 2.0.12.
      
      "v1_4" = 6:
        Intermediate settings version, understood by VirtualBox 2.1.x.
      
      "v1_5" = 7:
        Intermediate settings version, understood by VirtualBox 2.1.x.
      
      "v1_6" = 8:
        Settings version "1.6", written by VirtualBox 2.1.4 (at least).
      
      "v1_7" = 9:
        Settings version "1.7", written by VirtualBox 2.2.x and 3.0.x.
      
      "v1_8" = 10:
        Intermediate settings version "1.8", understood by VirtualBox 3.1.x.
      
      "v1_9" = 11:
        Settings version "1.9", written by VirtualBox 3.1.x.
      
      "v1_10" = 12:
        Settings version "1.10", written by VirtualBox 3.2.x.
      
      "v1_11" = 13:
        Settings version "1.11", written by VirtualBox 4.0.x.
      
      "v1_12" = 14:
        Settings version "1.12", written by VirtualBox 4.1.x.
      
      "v1_13" = 15:
        Settings version "1.13", written by VirtualBox 4.2.x.
      
      "v1_14" = 16:
        Settings version "1.14", written by VirtualBox 4.3.x.
      
      "v1_15" = 17:
        Settings version "1.15", written by VirtualBox 5.0.x.
      
      "v1_16" = 18:
        Settings version "1.16", written by VirtualBox 5.1.x.
      
      "v1_17" = 19:
        Settings version "1.17", written by VirtualBox 6.0.x.
      
      "v1_18" = 20:
        Settings version "1.18", written by VirtualBox 6.1.x.
      
      "Future" = 99999:
        Settings version greater than "1.15", written by a future VirtualBox version.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = SettingsVersion._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,SettingsVersion):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,SettingsVersion):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return SettingsVersion._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'v1_0',2:'v1_1',3:'v1_2',4:'v1_3pre',5:'v1_3',6:'v1_4',7:'v1_5',8:'v1_6',9:'v1_7',10:'v1_8',11:'v1_9',12:'v1_10',13:'v1_11',14:'v1_12',15:'v1_13',16:'v1_14',17:'v1_15',18:'v1_16',19:'v1_17',20:'v1_18',99999:'Future'}
   _ValueMap = {'Null':0,'v1_0':1,'v1_1':2,'v1_2':3,'v1_3pre':4,'v1_3':5,'v1_4':6,'v1_5':7,'v1_6':8,'v1_7':9,'v1_8':10,'v1_9':11,'v1_10':12,'v1_11':13,'v1_12':14,'v1_13':15,'v1_14':16,'v1_15':17,'v1_16':18,'v1_17':19,'v1_18':20,'Future':99999}

   Null = 0
   v1_0 = 1
   v1_1 = 2
   v1_2 = 3
   v1_3pre = 4
   v1_3 = 5
   v1_4 = 6
   v1_5 = 7
   v1_6 = 8
   v1_7 = 9
   v1_8 = 10
   v1_9 = 11
   v1_10 = 12
   v1_11 = 13
   v1_12 = 14
   v1_13 = 15
   v1_14 = 16
   v1_15 = 17
   v1_16 = 18
   v1_17 = 19
   v1_18 = 20
   Future = 99999

class AccessMode:
   """
      Access mode for opening files.
    
      "ReadOnly" = 1:
        
      "ReadWrite" = 2:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AccessMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AccessMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AccessMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AccessMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'ReadOnly',2:'ReadWrite'}
   _ValueMap = {'ReadOnly':1,'ReadWrite':2}

   ReadOnly = 1
   ReadWrite = 2

class MachineState:
   """
      Virtual machine execution state.

      This enumeration represents possible values of the IMachine::state attribute.

      Below is the basic virtual machine state diagram. It shows how the state
      changes during virtual machine execution. The text in square braces shows
      a method of the IConsole or IMachine interface that performs the given state
      transition.

      
            +---------[powerDown()] <- Stuck <--[failure]-+
            V                                             |
    +-> PoweredOff --+-->[powerUp()]--> Starting --+      | +-----[resume()]-----+
    |                |                             |      | V                    |
    |   Aborted -----+                             +--> Running --[pause()]--> Paused
    |                                              |      ^ |                   ^ |
    |   Saved -----------[powerUp()]--> Restoring -+      | |                   | |
    |     ^                                               | |                   | |
    |     |     +-----------------------------------------+-|-------------------+ +
    |     |     |                                           |                     |
    |     |     +- OnlineSnapshotting <--[takeSnapshot()]<--+---------------------+
    |     |                                                 |                     |
    |     +-------- Saving <--------[saveState()]<----------+---------------------+
    |                                                       |                     |
    +-------------- Stopping -------[powerDown()]<----------+---------------------+
      

      Note that states to the right from PoweredOff, Aborted and Saved in the
      above diagram are called online VM states. These states
      represent the virtual machine which is being executed in a dedicated
      process (usually with a GUI window attached to it where you can see the
      activity of the virtual machine and interact with it). There are two
      special pseudo-states, FirstOnline and LastOnline, that can be used in
      relational expressions to detect if the given machine state is online or
      not:

      
        if (machine.GetState() >= MachineState_FirstOnline &&
            machine.GetState() <= MachineState_LastOnline)
        {
            ...the machine is being executed...
        }
      

      When the virtual machine is in one of the online VM states (that is, being
      executed), only a few machine settings can be modified. Methods working
      with such settings contain an explicit note about that. An attempt to
      change any other setting or perform a modifying operation during this time
      will result in the @c VBOX_E_INVALID_VM_STATE error.

      All online states except Running, Paused and Stuck are transitional: they
      represent temporary conditions of the virtual machine that will last as
      long as the operation that initiated such a condition.

      The Stuck state is a special case. It means that execution of the machine
      has reached the "Guru Meditation" condition. This condition indicates an
      internal VMM (virtual machine manager) failure which may happen as a
      result of either an unhandled low-level virtual hardware exception or one
      of the recompiler exceptions (such as the too-many-traps
      condition).

      Note also that any online VM state may transit to the Aborted state. This
      happens if the process that is executing the virtual machine terminates
      unexpectedly (for example, crashes). Other than that, the Aborted state is
      equivalent to PoweredOff.

      There are also a few additional state diagrams that do not deal with
      virtual machine execution and therefore are shown separately. The states
      shown on these diagrams are called offline VM states (this includes
      PoweredOff, Aborted and Saved too).

      The first diagram shows what happens when a lengthy setup operation is
      being executed (such as IMachine::attachDevice).

      
    +----------------------------------(same state as before the call)------+
    |                                                                       |
    +-> PoweredOff --+                                                      |
    |                |                                                      |
    |-> Aborted -----+-->[lengthy VM configuration call] --> SettingUp -----+
    |                |
    +-> Saved -------+
      

      The next two diagrams demonstrate the process of taking a snapshot of a
      powered off virtual machine, restoring the state to that as of a snapshot
      or deleting a snapshot, respectively.

      
    +----------------------------------(same state as before the call)------+
    |                                                                       |
    +-> PoweredOff --+                                                      |
    |                +-->[takeSnapshot()] ------------------> Snapshotting -+
    +-> Aborted -----+

    +-> PoweredOff --+
    |                |
    |   Aborted -----+-->[restoreSnapshot()    ]-------> RestoringSnapshot -+
    |                |   [deleteSnapshot()     ]-------> DeletingSnapshot --+
    +-> Saved -------+                                                      |
    |                                                                       |
    +---(Saved if restored from an online snapshot, PoweredOff otherwise)---+
      
      "Null" = 0:
        Null value (never used by the API).
      
      "PoweredOff" = 1:
        The machine is not running and has no saved execution state; it has
        either never been started or been shut down successfully.
      
      "Saved" = 2:
        The machine is not currently running, but the execution state of the machine
        has been saved to an external file when it was running, from where
        it can be resumed.
      
      "Teleported" = 3:
        The machine was teleported to a different host (or process) and then
        powered off. Take care when powering it on again may corrupt resources
        it shares with the teleportation target (e.g. disk and network).
      
      "Aborted" = 4:
        The process running the machine has terminated abnormally. This may
        indicate a crash of the VM process in host execution context, or
        the VM process has been terminated externally.
      
      "Running" = 5:
        The machine is currently being executed.
        
      "Paused" = 6:
        Execution of the machine has been paused.
        
      "Stuck" = 7:
        Execution of the machine has reached the "Guru Meditation"
        condition. This indicates a severe error in the hypervisor itself.
        
      "Teleporting" = 8:
        The machine is about to be teleported to a different host or process.
        It is possible to pause a machine in this state, but it will go to the
        @c TeleportingPausedVM state and it will not be
        possible to resume it again unless the teleportation fails.
      
      "LiveSnapshotting" = 9:
        A live snapshot is being taken. The machine is running normally, but
        some of the runtime configuration options are inaccessible. Also, if
        paused while in this state it will transition to
        @c OnlineSnapshotting and it will not be resume the
        execution until the snapshot operation has completed.
      
      "Starting" = 10:
        Machine is being started after powering it on from a
        zero execution state.
      
      "Stopping" = 11:
        Machine is being normally stopped powering it off, or after the guest OS
        has initiated a shutdown sequence.
      
      "Saving" = 12:
        Machine is saving its execution state to a file.
      
      "Restoring" = 13:
        Execution state of the machine is being restored from a file
        after powering it on from the saved execution state.
      
      "TeleportingPausedVM" = 14:
        The machine is being teleported to another host or process, but it is
        not running. This is the paused variant of the
        @c Teleporting state.
      
      "TeleportingIn" = 15:
        Teleporting the machine state in from another host or process.
      
      "DeletingSnapshotOnline" = 16:
        Like @c DeletingSnapshot, but the merging of media is ongoing in
        the background while the machine is running.
      
      "DeletingSnapshotPaused" = 17:
        Like @c DeletingSnapshotOnline, but the machine was paused when the
        merging of differencing media was started.
      
      "OnlineSnapshotting" = 18:
        Like @c LiveSnapshotting, but the machine was paused when the
        merging of differencing media was started.
      
      "RestoringSnapshot" = 19:
        A machine snapshot is being restored; this typically does not take long.
      
      "DeletingSnapshot" = 20:
        A machine snapshot is being deleted; this can take a long time since this
        may require merging differencing media. This value indicates that the
        machine is not running while the snapshot is being deleted.
      
      "SettingUp" = 21:
        Lengthy setup operation is in progress.
      
      "Snapshotting" = 22:
        Taking an (offline) snapshot.
      
      "FirstOnline" = 5:
        Pseudo-state: first online state (for use in relational expressions).
      
      "LastOnline" = 18:
        Pseudo-state: last online state (for use in relational expressions).
      
      "FirstTransient" = 8:
        Pseudo-state: first transient state (for use in relational expressions).
      
      "LastTransient" = 22:
        Pseudo-state: last transient state (for use in relational expressions).
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = MachineState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MachineState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MachineState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return MachineState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'PoweredOff',2:'Saved',3:'Teleported',4:'Aborted',5:'Running',6:'Paused',7:'Stuck',8:'Teleporting',9:'LiveSnapshotting',10:'Starting',11:'Stopping',12:'Saving',13:'Restoring',14:'TeleportingPausedVM',15:'TeleportingIn',16:'DeletingSnapshotOnline',17:'DeletingSnapshotPaused',18:'OnlineSnapshotting',19:'RestoringSnapshot',20:'DeletingSnapshot',21:'SettingUp',22:'Snapshotting',5:'FirstOnline',18:'LastOnline',8:'FirstTransient',22:'LastTransient'}
   _ValueMap = {'Null':0,'PoweredOff':1,'Saved':2,'Teleported':3,'Aborted':4,'Running':5,'Paused':6,'Stuck':7,'Teleporting':8,'LiveSnapshotting':9,'Starting':10,'Stopping':11,'Saving':12,'Restoring':13,'TeleportingPausedVM':14,'TeleportingIn':15,'DeletingSnapshotOnline':16,'DeletingSnapshotPaused':17,'OnlineSnapshotting':18,'RestoringSnapshot':19,'DeletingSnapshot':20,'SettingUp':21,'Snapshotting':22,'FirstOnline':5,'LastOnline':18,'FirstTransient':8,'LastTransient':22}

   Null = 0
   PoweredOff = 1
   Saved = 2
   Teleported = 3
   Aborted = 4
   Running = 5
   Paused = 6
   Stuck = 7
   Teleporting = 8
   LiveSnapshotting = 9
   Starting = 10
   Stopping = 11
   Saving = 12
   Restoring = 13
   TeleportingPausedVM = 14
   TeleportingIn = 15
   DeletingSnapshotOnline = 16
   DeletingSnapshotPaused = 17
   OnlineSnapshotting = 18
   RestoringSnapshot = 19
   DeletingSnapshot = 20
   SettingUp = 21
   Snapshotting = 22
   FirstOnline = 5
   LastOnline = 18
   FirstTransient = 8
   LastTransient = 22

class SessionState:
   """
      Session state. This enumeration represents possible values of
      IMachine::sessionState and ISession::state
      attributes.
    
      "Null" = 0:
        Null value (never used by the API).
      
      "Unlocked" = 1:
        In IMachine::sessionState, this means that the machine
        is not locked for any sessions.

        In ISession::state, this means that no machine is
        currently locked for this session.
      
      "Locked" = 2:
        In IMachine::sessionState, this means that the machine
        is currently locked for a session, whose process identifier can
        then be found in the IMachine::sessionPID attribute.

        In ISession::state, this means that a machine is
        currently locked for this session, and the mutable machine object
        can be found in the ISession::machine attribute
        (see IMachine::lockMachine for details).
      
      "Spawning" = 3:
        A new process is being spawned for the machine as a result of
        IMachine::launchVMProcess call. This state also occurs
        as a short transient state during an IMachine::lockMachine
        call.
      
      "Unlocking" = 4:
        The session is being unlocked.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = SessionState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,SessionState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,SessionState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return SessionState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'Unlocked',2:'Locked',3:'Spawning',4:'Unlocking'}
   _ValueMap = {'Null':0,'Unlocked':1,'Locked':2,'Spawning':3,'Unlocking':4}

   Null = 0
   Unlocked = 1
   Locked = 2
   Spawning = 3
   Unlocking = 4

class CPUPropertyType:
   """
      Virtual CPU property type. This enumeration represents possible values of the
      IMachine get- and setCPUProperty methods.
    
      "Null" = 0:
        Null value (never used by the API).
      
      "PAE" = 1:
        This setting determines whether VirtualBox will expose the Physical Address
        Extension (PAE) feature of the host CPU to the guest. Note that in case PAE
        is not available, it will not be reported.
      
      "LongMode" = 2:
        This setting determines whether VirtualBox will advertise long mode
        (i.e. 64-bit guest support) and let the guest enter it.
      
      "TripleFaultReset" = 3:
        This setting determines whether a triple fault within a guest will
        trigger an internal error condition and stop the VM (default) or reset
        the virtual CPU/VM and continue execution.
      
      "APIC" = 4:
        This setting determines whether an APIC is part of the virtual CPU.
        This feature can only be turned off when the X2APIC feature is off.
      
      "X2APIC" = 5:
        This setting determines whether an x2APIC is part of the virtual CPU.
        Since this feature implies that the APIC feature is present, it
        automatically enables the APIC feature when set.
      
      "IBPBOnVMExit" = 6:
        If set, force an indirect branch prediction barrier on VM exits if the
        host CPU supports it.  This setting will significantly slow down workloads
        causing many VM exits, so it is only recommended for situation where there
        is a real need to be paranoid.
      
      "IBPBOnVMEntry" = 7:
        If set, force an indirect branch prediction barrier on VM entry if the
        host CPU supports it.  This setting will significantly slow down workloads
        causing many VM exits, so it is only recommended for situation where there
        is a real need to be paranoid.
      
      "HWVirt" = 8:
        Enabled the hardware virtualization (AMD-V/VT-x) feature on the guest CPU.
        This requires hardware virtualization on the host CPU.
      
      "SpecCtrl" = 9:
        If set, the speculation control CPUID bits and MSRs, when available on the
        host, are exposed to the guest. Depending on the host CPU and operating
        system, this may significantly slow down workloads causing many VM exits.
      
      "SpecCtrlByHost" = 10:
        If set, the speculation controls are managed by the host. This is intended
        for guests which do not set the speculation controls themselves.
        Note! This has not yet been implemented beyond leaving everything to the host OS.
      
      "L1DFlushOnEMTScheduling" = 11:
        If set and the host is affected by CVE-2018-3646, flushes the level 1 data
        cache when the EMT is scheduled to do ring-0 guest execution.  There could
        be a small performance penalty for certain typs of workloads.
        For security reasons this setting will be enabled by default.
      
      "L1DFlushOnVMEntry" = 12:
        If set and the host is affected by CVE-2018-3646, flushes the level 1 data
        on every VM entry.  This setting may significantly slow down workloads
        causing many VM exits, so it is only recommended for situation where there
        is a real need to be paranoid.
      
      "MDSClearOnEMTScheduling" = 13:
        If set and the host is affected by CVE-2018-12126, CVE-2018-12127, or
        CVE-2018-12130, clears the relevant MDS buffers when the EMT is scheduled
        to do ring-0 guest execution.  There could be a small performance penalty
        for certain typs of workloads. For security reasons this setting will be
        enabled by default.
      
      "MDSClearOnVMEntry" = 14:
        If set and the host is affected by CVE-2018-12126, CVE-2018-12127, or
        CVE-2018-12130, clears the relevant MDS buffers on every VM entry.  This
        setting may slow down workloads causing many VM exits, so it is only
        recommended for situation where there is a real need to be paranoid.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = CPUPropertyType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CPUPropertyType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CPUPropertyType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return CPUPropertyType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'PAE',2:'LongMode',3:'TripleFaultReset',4:'APIC',5:'X2APIC',6:'IBPBOnVMExit',7:'IBPBOnVMEntry',8:'HWVirt',9:'SpecCtrl',10:'SpecCtrlByHost',11:'L1DFlushOnEMTScheduling',12:'L1DFlushOnVMEntry',13:'MDSClearOnEMTScheduling',14:'MDSClearOnVMEntry'}
   _ValueMap = {'Null':0,'PAE':1,'LongMode':2,'TripleFaultReset':3,'APIC':4,'X2APIC':5,'IBPBOnVMExit':6,'IBPBOnVMEntry':7,'HWVirt':8,'SpecCtrl':9,'SpecCtrlByHost':10,'L1DFlushOnEMTScheduling':11,'L1DFlushOnVMEntry':12,'MDSClearOnEMTScheduling':13,'MDSClearOnVMEntry':14}

   Null = 0
   PAE = 1
   LongMode = 2
   TripleFaultReset = 3
   APIC = 4
   X2APIC = 5
   IBPBOnVMExit = 6
   IBPBOnVMEntry = 7
   HWVirt = 8
   SpecCtrl = 9
   SpecCtrlByHost = 10
   L1DFlushOnEMTScheduling = 11
   L1DFlushOnVMEntry = 12
   MDSClearOnEMTScheduling = 13
   MDSClearOnVMEntry = 14

class HWVirtExPropertyType:
   """
      Hardware virtualization property type. This enumeration represents possible values
      for the IMachine::getHWVirtExProperty and
      IMachine::setHWVirtExProperty methods.
    
      "Null" = 0:
        Null value (never used by the API).
      
      "Enabled" = 1:
        Whether hardware virtualization (VT-x/AMD-V) is enabled at all. If
        such extensions are not available, they will not be used.
      
      "VPID" = 2:
        Whether VT-x VPID is enabled. If this extension is not available, it will not be used.
      
      "NestedPaging" = 3:
        Whether Nested Paging is enabled. If this extension is not available, it will not be used.
      
      "UnrestrictedExecution" = 4:
        Whether VT-x unrestricted execution is enabled. If this feature is not available, it will not be used.
      
      "LargePages" = 5:
        Whether large page allocation is enabled; requires nested paging and a 64-bit host.
      
      "Force" = 6:
        Whether the VM should fail to start if hardware virtualization (VT-x/AMD-V) cannot be used. If
        not set, there will be an automatic fallback to software virtualization.
      
      "UseNativeApi" = 7:
        Use the native hypervisor API instead of the VirtualBox one (HM) for VT-X/AMD-V.  This is
        ignored if ::HWVirtExPropertyType_Enabled isn't set.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = HWVirtExPropertyType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,HWVirtExPropertyType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,HWVirtExPropertyType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return HWVirtExPropertyType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'Enabled',2:'VPID',3:'NestedPaging',4:'UnrestrictedExecution',5:'LargePages',6:'Force',7:'UseNativeApi'}
   _ValueMap = {'Null':0,'Enabled':1,'VPID':2,'NestedPaging':3,'UnrestrictedExecution':4,'LargePages':5,'Force':6,'UseNativeApi':7}

   Null = 0
   Enabled = 1
   VPID = 2
   NestedPaging = 3
   UnrestrictedExecution = 4
   LargePages = 5
   Force = 6
   UseNativeApi = 7

class ParavirtProvider:
   """
      The paravirtualized guest interface provider. This enumeration represents possible
      values for the IMachine::paravirtProvider attribute.
    
      "None" = 0:
        No provider is used.
      
      "Default" = 1:
        A default provider is automatically chosen according to the guest OS type.
      
      "Legacy" = 2:Used for VMs which didn't used to have any provider settings. Usually
        interpreted as @c None for most VMs.
      "Minimal" = 3:
        A minimal set of features to expose to the paravirtualized guest.
      
      "HyperV" = 4:
        Microsoft Hyper-V.
      
      "KVM" = 5:
        Linux KVM.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ParavirtProvider._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ParavirtProvider):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ParavirtProvider):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ParavirtProvider._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'Default',2:'Legacy',3:'Minimal',4:'HyperV',5:'KVM'}
   _ValueMap = {'None':0,'Default':1,'Legacy':2,'Minimal':3,'HyperV':4,'KVM':5}

   _None = 0
   Default = 1
   Legacy = 2
   Minimal = 3
   HyperV = 4
   KVM = 5

class LockType:
   """
      Used with IMachine::lockMachine.
    
      "Null" = 0:
        Placeholder value, do not use when obtaining a lock.
      
      "Shared" = 1:Request only a shared lock for remote-controlling the machine.
        Such a lock allows changing certain VM settings which can be safely
        modified for a running VM.
      "Write" = 2:Lock the machine for writing. This requests an exclusive lock, i.e.
        there cannot be any other API client holding any type of lock for this
        VM concurrently. Remember that a VM process counts as an API client
        which implicitly holds the equivalent of a shared lock during the
        entire VM runtime.
      "VM" = 3:Lock the machine for writing, and create objects necessary for
        running a VM in this process.
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = LockType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,LockType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,LockType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return LockType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'Shared',2:'Write',3:'VM'}
   _ValueMap = {'Null':0,'Shared':1,'Write':2,'VM':3}

   Null = 0
   Shared = 1
   Write = 2
   VM = 3

class SessionType:
   """
      Session type. This enumeration represents possible values of the
      ISession::type attribute.
    
      "Null" = 0:
        Null value (never used by the API).
      
      "WriteLock" = 1:
        Session has acquired an exclusive write lock on a machine
        using IMachine::lockMachine.
      
      "Remote" = 2:
        Session has launched a VM process using
        IMachine::launchVMProcess
      "Shared" = 3:
        Session has obtained a link to another session using
        IMachine::lockMachine
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = SessionType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,SessionType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,SessionType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return SessionType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'WriteLock',2:'Remote',3:'Shared'}
   _ValueMap = {'Null':0,'WriteLock':1,'Remote':2,'Shared':3}

   Null = 0
   WriteLock = 1
   Remote = 2
   Shared = 3

class DeviceType:
   """
      Device type.
    
      "Null" = 0:
        Null value, may also mean "no device" (not allowed for
        IConsole::getDeviceActivity).
      
      "Floppy" = 1:
        Floppy device.
      
      "DVD" = 2:
        CD/DVD-ROM device.
      
      "HardDisk" = 3:
        Hard disk device.
      
      "Network" = 4:
        Network device.
      
      "USB" = 5:
        USB device.
      
      "SharedFolder" = 6:
        Shared folder device.
      
      "Graphics3D" = 7:
        Graphics device 3D activity.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DeviceType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DeviceType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DeviceType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DeviceType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'Floppy',2:'DVD',3:'HardDisk',4:'Network',5:'USB',6:'SharedFolder',7:'Graphics3D'}
   _ValueMap = {'Null':0,'Floppy':1,'DVD':2,'HardDisk':3,'Network':4,'USB':5,'SharedFolder':6,'Graphics3D':7}

   Null = 0
   Floppy = 1
   DVD = 2
   HardDisk = 3
   Network = 4
   USB = 5
   SharedFolder = 6
   Graphics3D = 7

class DeviceActivity:
   """
      Device activity for IConsole::getDeviceActivity.
    
      "Null" = 0:
        
      "Idle" = 1:
        
      "Reading" = 2:
        
      "Writing" = 3:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DeviceActivity._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DeviceActivity):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DeviceActivity):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DeviceActivity._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'Idle',2:'Reading',3:'Writing'}
   _ValueMap = {'Null':0,'Idle':1,'Reading':2,'Writing':3}

   Null = 0
   Idle = 1
   Reading = 2
   Writing = 3

class ClipboardMode:
   """
      Host-Guest clipboard interchange mode.
    
      "Disabled" = 0:
        
      "HostToGuest" = 1:
        
      "GuestToHost" = 2:
        
      "Bidirectional" = 3:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ClipboardMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ClipboardMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ClipboardMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ClipboardMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Disabled',1:'HostToGuest',2:'GuestToHost',3:'Bidirectional'}
   _ValueMap = {'Disabled':0,'HostToGuest':1,'GuestToHost':2,'Bidirectional':3}

   Disabled = 0
   HostToGuest = 1
   GuestToHost = 2
   Bidirectional = 3

class DnDMode:
   """
      Drag and drop interchange mode.
    
      "Disabled" = 0:
        
      "HostToGuest" = 1:
        
      "GuestToHost" = 2:
        
      "Bidirectional" = 3:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DnDMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DnDMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DnDMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DnDMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Disabled',1:'HostToGuest',2:'GuestToHost',3:'Bidirectional'}
   _ValueMap = {'Disabled':0,'HostToGuest':1,'GuestToHost':2,'Bidirectional':3}

   Disabled = 0
   HostToGuest = 1
   GuestToHost = 2
   Bidirectional = 3

class Scope:
   """
      Scope of the operation.

      A generic enumeration used in various methods to define the action or
      argument scope.
    
      "Global" = 0:
        
      "Machine" = 1:
        
      "Session" = 2:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = Scope._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,Scope):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,Scope):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return Scope._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Global',1:'Machine',2:'Session'}
   _ValueMap = {'Global':0,'Machine':1,'Session':2}

   Global = 0
   Machine = 1
   Session = 2

class BIOSBootMenuMode:
   """
      BIOS boot menu mode.
    
      "Disabled" = 0:
        
      "MenuOnly" = 1:
        
      "MessageAndMenu" = 2:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = BIOSBootMenuMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,BIOSBootMenuMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,BIOSBootMenuMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return BIOSBootMenuMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Disabled',1:'MenuOnly',2:'MessageAndMenu'}
   _ValueMap = {'Disabled':0,'MenuOnly':1,'MessageAndMenu':2}

   Disabled = 0
   MenuOnly = 1
   MessageAndMenu = 2

class APICMode:
   """
      BIOS APIC initialization mode. If the hardware does not support the
      mode then the code falls back to a lower mode.
    
      "Disabled" = 0:
        
      "APIC" = 1:
        
      "X2APIC" = 2:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = APICMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,APICMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,APICMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return APICMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Disabled',1:'APIC',2:'X2APIC'}
   _ValueMap = {'Disabled':0,'APIC':1,'X2APIC':2}

   Disabled = 0
   APIC = 1
   X2APIC = 2

class ProcessorFeature:
   """
      CPU features.
    
      "HWVirtEx" = 0:
        
      "PAE" = 1:
        
      "LongMode" = 2:
        
      "NestedPaging" = 3:
        
      "UnrestrictedGuest" = 4:
        
      "NestedHWVirt" = 5:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ProcessorFeature._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessorFeature):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessorFeature):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessorFeature._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'HWVirtEx',1:'PAE',2:'LongMode',3:'NestedPaging',4:'UnrestrictedGuest',5:'NestedHWVirt'}
   _ValueMap = {'HWVirtEx':0,'PAE':1,'LongMode':2,'NestedPaging':3,'UnrestrictedGuest':4,'NestedHWVirt':5}

   HWVirtEx = 0
   PAE = 1
   LongMode = 2
   NestedPaging = 3
   UnrestrictedGuest = 4
   NestedHWVirt = 5

class FirmwareType:
   """
      Firmware type.
    
      "BIOS" = 1:
        BIOS Firmware.
      
      "EFI" = 2:
        EFI Firmware, bitness detected basing on OS type.
      
      "EFI32" = 3:
        EFI firmware, 32-bit.
      
      "EFI64" = 4:
        EFI firmware, 64-bit.
      
      "EFIDUAL" = 5:
        EFI firmware, combined 32 and 64-bit.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FirmwareType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FirmwareType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FirmwareType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FirmwareType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'BIOS',2:'EFI',3:'EFI32',4:'EFI64',5:'EFIDUAL'}
   _ValueMap = {'BIOS':1,'EFI':2,'EFI32':3,'EFI64':4,'EFIDUAL':5}

   BIOS = 1
   EFI = 2
   EFI32 = 3
   EFI64 = 4
   EFIDUAL = 5

class PointingHIDType:
   """
      Type of pointing device used in a virtual machine.
    
      "None" = 1:
        No mouse.
      
      "PS2Mouse" = 2:
        PS/2 auxiliary device, a.k.a. mouse.
      
      "USBMouse" = 3:
        USB mouse (relative pointer).
      
      "USBTablet" = 4:
        USB tablet (absolute pointer).  Also enables a relative USB mouse in
        addition.
      
      "ComboMouse" = 5:
        Combined device, working as PS/2 or USB mouse, depending on guest
        behavior.  Using this device can have negative performance implications.
      
      "USBMultiTouch" = 6:
        USB multi-touch device.  Also enables the USB tablet and mouse devices.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = PointingHIDType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,PointingHIDType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,PointingHIDType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return PointingHIDType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'None',2:'PS2Mouse',3:'USBMouse',4:'USBTablet',5:'ComboMouse',6:'USBMultiTouch'}
   _ValueMap = {'None':1,'PS2Mouse':2,'USBMouse':3,'USBTablet':4,'ComboMouse':5,'USBMultiTouch':6}

   _None = 1
   PS2Mouse = 2
   USBMouse = 3
   USBTablet = 4
   ComboMouse = 5
   USBMultiTouch = 6

class KeyboardHIDType:
   """
      Type of keyboard device used in a virtual machine.
    
      "None" = 1:
        No keyboard.
      
      "PS2Keyboard" = 2:
        PS/2 keyboard.
      
      "USBKeyboard" = 3:
        USB keyboard.
      
      "ComboKeyboard" = 4:Combined device, working as PS/2 or USB keyboard, depending on guest behavior.
      Using of such device can have negative performance implications.
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = KeyboardHIDType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,KeyboardHIDType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,KeyboardHIDType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return KeyboardHIDType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'None',2:'PS2Keyboard',3:'USBKeyboard',4:'ComboKeyboard'}
   _ValueMap = {'None':1,'PS2Keyboard':2,'USBKeyboard':3,'ComboKeyboard':4}

   _None = 1
   PS2Keyboard = 2
   USBKeyboard = 3
   ComboKeyboard = 4

class BitmapFormat:
   """
      Format of a bitmap. Generic values for formats used by
      the source bitmap, the screen shot or image update APIs.
    
      "Opaque" = 0:
        Unknown buffer format (the user may not assume any particular format of
        the buffer).
      
      "BGR" = 0x20524742:
        Generic BGR format without alpha channel.
        Pixel layout depends on the number of bits per pixel:
          * 32 - bits 31:24 undefined, bits 23:16 R, bits 15:8 G, bits 7:0 B.
          
          * 16 - bits 15:11 R, bits 10:5 G, bits 4:0 B.
          
      "BGR0" = 0x30524742:
        4 bytes per pixel: B, G, R, 0.
      
      "BGRA" = 0x41524742:
        4 bytes per pixel: B, G, R, A.
      
      "RGBA" = 0x41424752:
        4 bytes per pixel: R, G, B, A.
      
      "PNG" = 0x20474E50:
        PNG image.
      
      "JPEG" = 0x4745504A:
        JPEG image.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = BitmapFormat._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,BitmapFormat):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,BitmapFormat):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return BitmapFormat._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Opaque',0x20524742:'BGR',0x30524742:'BGR0',0x41524742:'BGRA',0x41424752:'RGBA',0x20474E50:'PNG',0x4745504A:'JPEG'}
   _ValueMap = {'Opaque':0,'BGR':0x20524742,'BGR0':0x30524742,'BGRA':0x41524742,'RGBA':0x41424752,'PNG':0x20474E50,'JPEG':0x4745504A}

   Opaque = 0
   BGR = 0x20524742
   BGR0 = 0x30524742
   BGRA = 0x41524742
   RGBA = 0x41424752
   PNG = 0x20474E50
   JPEG = 0x4745504A

class DHCPOption:
   """
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DHCPOption._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DHCPOption):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DHCPOption):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DHCPOption._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'SubnetMask',2:'TimeOffset',3:'Routers',4:'TimeServers',5:'NameServers',6:'DomainNameServers',7:'LogServers',8:'CookieServers',9:'LPRServers',10:'ImpressServers',11:'ResourseLocationServers',12:'HostName',13:'BootFileSize',14:'MeritDumpFile',15:'DomainName',16:'SwapServer',17:'RootPath',18:'ExtensionPath',19:'IPForwarding',20:'OptNonLocalSourceRouting',21:'PolicyFilter',22:'MaxDgramReassemblySize',23:'DefaultIPTTL',24:'PathMTUAgingTimeout',25:'PathMTUPlateauTable',26:'InterfaceMTU',27:'AllSubnetsAreLocal',28:'BroadcastAddress',29:'PerformMaskDiscovery',30:'MaskSupplier',31:'PerformRouterDiscovery',32:'RouterSolicitationAddress',33:'StaticRoute',34:'TrailerEncapsulation',35:'ARPCacheTimeout',36:'EthernetEncapsulation',37:'TCPDefaultTTL',38:'TCPKeepaliveInterval',39:'TCPKeepaliveGarbage',40:'NISDomain',41:'NISServers',42:'NTPServers',43:'VendorSpecificInfo',44:'NetBIOSNameServers',45:'NetBIOSDatagramServers',46:'NetBIOSNodeType',47:'NetBIOSScope',48:'XWindowsFontServers',49:'XWindowsDisplayManager',62:'NetWareIPDomainName',63:'NetWareIPInformation',64:'NISPlusDomain',65:'NISPlusServers',66:'TFTPServerName',67:'BootfileName',68:'MobileIPHomeAgents',69:'SMTPServers',70:'POP3Servers',71:'NNTPServers',72:'WWWServers',73:'FingerServers',74:'IRCServers',75:'StreetTalkServers',76:'STDAServers',78:'SLPDirectoryAgent',79:'SLPServiceScope',119:'DomainSearch'}
   _ValueMap = {'SubnetMask':1,'TimeOffset':2,'Routers':3,'TimeServers':4,'NameServers':5,'DomainNameServers':6,'LogServers':7,'CookieServers':8,'LPRServers':9,'ImpressServers':10,'ResourseLocationServers':11,'HostName':12,'BootFileSize':13,'MeritDumpFile':14,'DomainName':15,'SwapServer':16,'RootPath':17,'ExtensionPath':18,'IPForwarding':19,'OptNonLocalSourceRouting':20,'PolicyFilter':21,'MaxDgramReassemblySize':22,'DefaultIPTTL':23,'PathMTUAgingTimeout':24,'PathMTUPlateauTable':25,'InterfaceMTU':26,'AllSubnetsAreLocal':27,'BroadcastAddress':28,'PerformMaskDiscovery':29,'MaskSupplier':30,'PerformRouterDiscovery':31,'RouterSolicitationAddress':32,'StaticRoute':33,'TrailerEncapsulation':34,'ARPCacheTimeout':35,'EthernetEncapsulation':36,'TCPDefaultTTL':37,'TCPKeepaliveInterval':38,'TCPKeepaliveGarbage':39,'NISDomain':40,'NISServers':41,'NTPServers':42,'VendorSpecificInfo':43,'NetBIOSNameServers':44,'NetBIOSDatagramServers':45,'NetBIOSNodeType':46,'NetBIOSScope':47,'XWindowsFontServers':48,'XWindowsDisplayManager':49,'NetWareIPDomainName':62,'NetWareIPInformation':63,'NISPlusDomain':64,'NISPlusServers':65,'TFTPServerName':66,'BootfileName':67,'MobileIPHomeAgents':68,'SMTPServers':69,'POP3Servers':70,'NNTPServers':71,'WWWServers':72,'FingerServers':73,'IRCServers':74,'StreetTalkServers':75,'STDAServers':76,'SLPDirectoryAgent':78,'SLPServiceScope':79,'DomainSearch':119}

   SubnetMask = 1
   TimeOffset = 2
   Routers = 3
   TimeServers = 4
   NameServers = 5
   DomainNameServers = 6
   LogServers = 7
   CookieServers = 8
   LPRServers = 9
   ImpressServers = 10
   ResourseLocationServers = 11
   HostName = 12
   BootFileSize = 13
   MeritDumpFile = 14
   DomainName = 15
   SwapServer = 16
   RootPath = 17
   ExtensionPath = 18
   IPForwarding = 19
   OptNonLocalSourceRouting = 20
   PolicyFilter = 21
   MaxDgramReassemblySize = 22
   DefaultIPTTL = 23
   PathMTUAgingTimeout = 24
   PathMTUPlateauTable = 25
   InterfaceMTU = 26
   AllSubnetsAreLocal = 27
   BroadcastAddress = 28
   PerformMaskDiscovery = 29
   MaskSupplier = 30
   PerformRouterDiscovery = 31
   RouterSolicitationAddress = 32
   StaticRoute = 33
   TrailerEncapsulation = 34
   ARPCacheTimeout = 35
   EthernetEncapsulation = 36
   TCPDefaultTTL = 37
   TCPKeepaliveInterval = 38
   TCPKeepaliveGarbage = 39
   NISDomain = 40
   NISServers = 41
   NTPServers = 42
   VendorSpecificInfo = 43
   NetBIOSNameServers = 44
   NetBIOSDatagramServers = 45
   NetBIOSNodeType = 46
   NetBIOSScope = 47
   XWindowsFontServers = 48
   XWindowsDisplayManager = 49
   NetWareIPDomainName = 62
   NetWareIPInformation = 63
   NISPlusDomain = 64
   NISPlusServers = 65
   TFTPServerName = 66
   BootfileName = 67
   MobileIPHomeAgents = 68
   SMTPServers = 69
   POP3Servers = 70
   NNTPServers = 71
   WWWServers = 72
   FingerServers = 73
   IRCServers = 74
   StreetTalkServers = 75
   STDAServers = 76
   SLPDirectoryAgent = 78
   SLPServiceScope = 79
   DomainSearch = 119

class DHCPOptionEncoding:
   """
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DHCPOptionEncoding._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DHCPOptionEncoding):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DHCPOptionEncoding):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DHCPOptionEncoding._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Normal',1:'Hex'}
   _ValueMap = {'Normal':0,'Hex':1}

   Normal = 0
   Hex = 1

class DHCPConfigScope:
   """
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DHCPConfigScope._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DHCPConfigScope):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DHCPConfigScope):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DHCPConfigScope._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Global',1:'Group',2:'MachineNIC',3:'MAC'}
   _ValueMap = {'Global':0,'Group':1,'MachineNIC':2,'MAC':3}

   Global = 0
   Group = 1
   MachineNIC = 2
   MAC = 3

class DHCPGroupConditionType:
   """
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DHCPGroupConditionType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DHCPGroupConditionType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DHCPGroupConditionType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DHCPGroupConditionType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'MAC',1:'MACWildcard',2:'vendorClassID',3:'vendorClassIDWildcard',4:'userClassID',5:'userClassIDWildcard'}
   _ValueMap = {'MAC':0,'MACWildcard':1,'vendorClassID':2,'vendorClassIDWildcard':3,'userClassID':4,'userClassIDWildcard':5}

   MAC = 0
   MACWildcard = 1
   vendorClassID = 2
   vendorClassIDWildcard = 3
   userClassID = 4
   userClassIDWildcard = 5

class VFSType:
   """
      Virtual file systems supported by VFSExplorer.
    
      "File" = 1:
        
      "Cloud" = 2:
        
      "S3" = 3:
        
      "WebDav" = 4:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = VFSType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VFSType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VFSType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return VFSType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'File',2:'Cloud',3:'S3',4:'WebDav'}
   _ValueMap = {'File':1,'Cloud':2,'S3':3,'WebDav':4}

   File = 1
   Cloud = 2
   S3 = 3
   WebDav = 4

class ImportOptions:
   """
    Import options, used with IAppliance::importMachines.
    
      "KeepAllMACs" = 1:
        Don't generate new MAC addresses of the attached network adapters.
      
      "KeepNATMACs" = 2:
        Don't generate new MAC addresses of the attached network adapters when they are using NAT.
      
      "ImportToVDI" = 3:
        Import all disks to VDI format
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ImportOptions._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ImportOptions):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ImportOptions):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ImportOptions._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'KeepAllMACs',2:'KeepNATMACs',3:'ImportToVDI'}
   _ValueMap = {'KeepAllMACs':1,'KeepNATMACs':2,'ImportToVDI':3}

   KeepAllMACs = 1
   KeepNATMACs = 2
   ImportToVDI = 3

class ExportOptions:
   """
    Export options, used with IAppliance::write.
    
      "CreateManifest" = 1:Write the optional manifest file (.mf) which is used for integrity
      checks prior import.
      "ExportDVDImages" = 2:Export DVD images. Default is not to export them as it is rarely
      needed for typical VMs.
      "StripAllMACs" = 3:Do not export any MAC address information. Default is to keep them
      to avoid losing information which can cause trouble after import, at the
      price of risking duplicate MAC addresses, if the import options are used
      to keep them.
      "StripAllNonNATMACs" = 4:Do not export any MAC address information, except for adapters
      using NAT. Default is to keep them to avoid losing information which can
      cause trouble after import, at the price of risking duplicate MAC
      addresses, if the import options are used to keep them.
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ExportOptions._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ExportOptions):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ExportOptions):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ExportOptions._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'CreateManifest',2:'ExportDVDImages',3:'StripAllMACs',4:'StripAllNonNATMACs'}
   _ValueMap = {'CreateManifest':1,'ExportDVDImages':2,'StripAllMACs':3,'StripAllNonNATMACs':4}

   CreateManifest = 1
   ExportDVDImages = 2
   StripAllMACs = 3
   StripAllNonNATMACs = 4

class CertificateVersion:
   """
      X.509 certificate version numbers.
    
      "V1" = 1:
        
      "V2" = 2:
        
      "V3" = 3:
        
      "Unknown" = 99:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = CertificateVersion._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CertificateVersion):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CertificateVersion):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return CertificateVersion._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'V1',2:'V2',3:'V3',99:'Unknown'}
   _ValueMap = {'V1':1,'V2':2,'V3':3,'Unknown':99}

   V1 = 1
   V2 = 2
   V3 = 3
   Unknown = 99

class VirtualSystemDescriptionType:
   """Used with ::IVirtualSystemDescription to describe the type of
    a configuration value.
      "Ignore" = 1:
        
      "OS" = 2:
        
      "Name" = 3:
        
      "Product" = 4:
        
      "Vendor" = 5:
        
      "Version" = 6:
        
      "ProductUrl" = 7:
        
      "VendorUrl" = 8:
        
      "Description" = 9:
        
      "License" = 10:
        
      "Miscellaneous" = 11:
        
      "CPU" = 12:
        
      "Memory" = 13:
        
      "HardDiskControllerIDE" = 14:
        
      "HardDiskControllerSATA" = 15:
        
      "HardDiskControllerSCSI" = 16:
        
      "HardDiskControllerSAS" = 17:
        
      "HardDiskImage" = 18:
        
      "Floppy" = 19:
        
      "CDROM" = 20:
        
      "NetworkAdapter" = 21:
        
      "USBController" = 22:
        
      "SoundCard" = 23:
        
      "SettingsFile" = 24:Optional, may be unset by the API caller. If this is changed by the
        API caller it defines the absolute path of the VM settings file and
        therefore also the VM folder with highest priority.
      "BaseFolder" = 25:Optional, may be unset by the API caller. If set (and
        ::VirtualSystemDescriptionType_SettingsFile is not changed),
        defines the VM base folder (taking the primary group into account if
        also set).
      "PrimaryGroup" = 26:Optional, empty by default and may be unset by the API caller.
        Defines the primary group of the VM after import. May influence the
        selection of the VM folder. Additional groups may be configured later
        using IMachine::groups, after importing.
      "CloudInstanceShape" = 27:
        
      "CloudDomain" = 28:
        
      "CloudBootDiskSize" = 29:
        
      "CloudBucket" = 30:
        
      "CloudOCIVCN" = 31:
        
      "CloudPublicIP" = 32:
        
      "CloudProfileName" = 33:
        
      "CloudOCISubnet" = 34:
        
      "CloudKeepObject" = 35:
        
      "CloudLaunchInstance" = 36:
        
      "CloudInstanceId" = 37:
        
      "CloudImageId" = 38:
        
      "CloudInstanceState" = 39:
        
      "CloudImageState" = 40:
        
      "CloudInstanceDisplayName" = 41:
        
      "CloudImageDisplayName" = 42:
        
      "CloudOCILaunchMode" = 43:
        
      "CloudPrivateIP" = 44:
        
      "CloudBootVolumeId" = 45:
        
      "CloudOCIVCNCompartment" = 46:
        
      "CloudOCISubnetCompartment" = 47:
        
      "CloudPublicSSHKey" = 48:
        
      "BootingFirmware" = 49:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = VirtualSystemDescriptionType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VirtualSystemDescriptionType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VirtualSystemDescriptionType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return VirtualSystemDescriptionType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'Ignore',2:'OS',3:'Name',4:'Product',5:'Vendor',6:'Version',7:'ProductUrl',8:'VendorUrl',9:'Description',10:'License',11:'Miscellaneous',12:'CPU',13:'Memory',14:'HardDiskControllerIDE',15:'HardDiskControllerSATA',16:'HardDiskControllerSCSI',17:'HardDiskControllerSAS',18:'HardDiskImage',19:'Floppy',20:'CDROM',21:'NetworkAdapter',22:'USBController',23:'SoundCard',24:'SettingsFile',25:'BaseFolder',26:'PrimaryGroup',27:'CloudInstanceShape',28:'CloudDomain',29:'CloudBootDiskSize',30:'CloudBucket',31:'CloudOCIVCN',32:'CloudPublicIP',33:'CloudProfileName',34:'CloudOCISubnet',35:'CloudKeepObject',36:'CloudLaunchInstance',37:'CloudInstanceId',38:'CloudImageId',39:'CloudInstanceState',40:'CloudImageState',41:'CloudInstanceDisplayName',42:'CloudImageDisplayName',43:'CloudOCILaunchMode',44:'CloudPrivateIP',45:'CloudBootVolumeId',46:'CloudOCIVCNCompartment',47:'CloudOCISubnetCompartment',48:'CloudPublicSSHKey',49:'BootingFirmware'}
   _ValueMap = {'Ignore':1,'OS':2,'Name':3,'Product':4,'Vendor':5,'Version':6,'ProductUrl':7,'VendorUrl':8,'Description':9,'License':10,'Miscellaneous':11,'CPU':12,'Memory':13,'HardDiskControllerIDE':14,'HardDiskControllerSATA':15,'HardDiskControllerSCSI':16,'HardDiskControllerSAS':17,'HardDiskImage':18,'Floppy':19,'CDROM':20,'NetworkAdapter':21,'USBController':22,'SoundCard':23,'SettingsFile':24,'BaseFolder':25,'PrimaryGroup':26,'CloudInstanceShape':27,'CloudDomain':28,'CloudBootDiskSize':29,'CloudBucket':30,'CloudOCIVCN':31,'CloudPublicIP':32,'CloudProfileName':33,'CloudOCISubnet':34,'CloudKeepObject':35,'CloudLaunchInstance':36,'CloudInstanceId':37,'CloudImageId':38,'CloudInstanceState':39,'CloudImageState':40,'CloudInstanceDisplayName':41,'CloudImageDisplayName':42,'CloudOCILaunchMode':43,'CloudPrivateIP':44,'CloudBootVolumeId':45,'CloudOCIVCNCompartment':46,'CloudOCISubnetCompartment':47,'CloudPublicSSHKey':48,'BootingFirmware':49}

   Ignore = 1
   OS = 2
   Name = 3
   Product = 4
   Vendor = 5
   Version = 6
   ProductUrl = 7
   VendorUrl = 8
   Description = 9
   License = 10
   Miscellaneous = 11
   CPU = 12
   Memory = 13
   HardDiskControllerIDE = 14
   HardDiskControllerSATA = 15
   HardDiskControllerSCSI = 16
   HardDiskControllerSAS = 17
   HardDiskImage = 18
   Floppy = 19
   CDROM = 20
   NetworkAdapter = 21
   USBController = 22
   SoundCard = 23
   SettingsFile = 24
   BaseFolder = 25
   PrimaryGroup = 26
   CloudInstanceShape = 27
   CloudDomain = 28
   CloudBootDiskSize = 29
   CloudBucket = 30
   CloudOCIVCN = 31
   CloudPublicIP = 32
   CloudProfileName = 33
   CloudOCISubnet = 34
   CloudKeepObject = 35
   CloudLaunchInstance = 36
   CloudInstanceId = 37
   CloudImageId = 38
   CloudInstanceState = 39
   CloudImageState = 40
   CloudInstanceDisplayName = 41
   CloudImageDisplayName = 42
   CloudOCILaunchMode = 43
   CloudPrivateIP = 44
   CloudBootVolumeId = 45
   CloudOCIVCNCompartment = 46
   CloudOCISubnetCompartment = 47
   CloudPublicSSHKey = 48
   BootingFirmware = 49

class VirtualSystemDescriptionValueType:
   """Used with IVirtualSystemDescription::getValuesByType to describe the value
    type to fetch.
      "Reference" = 1:
        
      "Original" = 2:
        
      "Auto" = 3:
        
      "ExtraConfig" = 4:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = VirtualSystemDescriptionValueType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VirtualSystemDescriptionValueType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VirtualSystemDescriptionValueType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return VirtualSystemDescriptionValueType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'Reference',2:'Original',3:'Auto',4:'ExtraConfig'}
   _ValueMap = {'Reference':1,'Original':2,'Auto':3,'ExtraConfig':4}

   Reference = 1
   Original = 2
   Auto = 3
   ExtraConfig = 4

class RecordingDestination:
   """
      Recording destination enumeration.
    
      "None" = 0:
        No destination.
      
      "File" = 1:
        Destination is a regular file.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = RecordingDestination._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,RecordingDestination):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,RecordingDestination):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return RecordingDestination._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'File'}
   _ValueMap = {'None':0,'File':1}

   _None = 0
   File = 1

class RecordingFeature:
   """
      Recording features enumeration.
    
      "None" = 0:
        No feature set.
      
      "Video" = 1:
        Video recording.
      
      "Audio" = 2:
        Audio recording.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = RecordingFeature._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,RecordingFeature):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,RecordingFeature):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return RecordingFeature._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'Video',2:'Audio'}
   _ValueMap = {'None':0,'Video':1,'Audio':2}

   _None = 0
   Video = 1
   Audio = 2

class RecordingAudioCodec:
   """
      Recording audio codec enumeration.
    
      "None" = 0:
        No codec set.
      
      "WavPCM" = 1:WAV format, linear PCM, uncompressed.
        Not implemented yet.
      "Opus" = 2:
        Opus Audio.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = RecordingAudioCodec._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,RecordingAudioCodec):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,RecordingAudioCodec):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return RecordingAudioCodec._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'WavPCM',2:'Opus'}
   _ValueMap = {'None':0,'WavPCM':1,'Opus':2}

   _None = 0
   WavPCM = 1
   Opus = 2

class RecordingVideoCodec:
   """
      Recording video codec enumeration.
    
      "None" = 0:
        No codec set.
      
      "VP8" = 1:
        VP8 codec.
      
      "VP9" = 2:
        VP9 codec. Not implemented yet.
      
      "AV1" = 3:
        AV1 codec. Not implemented yet.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = RecordingVideoCodec._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,RecordingVideoCodec):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,RecordingVideoCodec):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return RecordingVideoCodec._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'VP8',2:'VP9',3:'AV1'}
   _ValueMap = {'None':0,'VP8':1,'VP9':2,'AV1':3}

   _None = 0
   VP8 = 1
   VP9 = 2
   AV1 = 3

class RecordingVideoScalingMethod:
   """
      Recording video scaling method enumeration.
    
      "None" = 0:
        No scaling performed.
      
      "NearestNeighbor" = 1:Performs scaling via nearest-neighbor interpolation.
        Not yet implemented.
      "Bilinear" = 2:Performs scaling via bilinear interpolation.
        Not yet implemented.
      "Bicubic" = 3:Performs scaling via bicubic interpolation.
        Not yet implemented.
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = RecordingVideoScalingMethod._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,RecordingVideoScalingMethod):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,RecordingVideoScalingMethod):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return RecordingVideoScalingMethod._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'NearestNeighbor',2:'Bilinear',3:'Bicubic'}
   _ValueMap = {'None':0,'NearestNeighbor':1,'Bilinear':2,'Bicubic':3}

   _None = 0
   NearestNeighbor = 1
   Bilinear = 2
   Bicubic = 3

class RecordingVideoRateControlMode:
   """
      Recording video rate control mode enumeration.
    
      "CBR" = 0:
        Constant bit rate (CBR).
      
      "VBR" = 1:
        Variable bit rate (VBR). Not yet implemented.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = RecordingVideoRateControlMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,RecordingVideoRateControlMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,RecordingVideoRateControlMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return RecordingVideoRateControlMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'CBR',1:'VBR'}
   _ValueMap = {'CBR':0,'VBR':1}

   CBR = 0
   VBR = 1

class GraphicsControllerType:
   """Graphics controller type, used with IGraphicsAdapter::graphicsControllerType.
    
      "Null" = 0:
        Reserved value, invalid.
      
      "VBoxVGA" = 1:
        VirtualBox VGA device.
      
      "VMSVGA" = 2:
        VMware SVGA II device.
      
      "VBoxSVGA" = 3:
        VirtualBox VGA device with VMware SVGA II extensions.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = GraphicsControllerType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,GraphicsControllerType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,GraphicsControllerType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return GraphicsControllerType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'VBoxVGA',2:'VMSVGA',3:'VBoxSVGA'}
   _ValueMap = {'Null':0,'VBoxVGA':1,'VMSVGA':2,'VBoxSVGA':3}

   Null = 0
   VBoxVGA = 1
   VMSVGA = 2
   VBoxSVGA = 3

class CleanupMode:
   """Cleanup mode, used with IMachine::unregister.
    
      "UnregisterOnly" = 1:
        Unregister only the machine, but neither delete snapshots nor detach media.
      
      "DetachAllReturnNone" = 2:
        Delete all snapshots and detach all media but return none; this will keep all media registered.
      
      "DetachAllReturnHardDisksOnly" = 3:
        Delete all snapshots, detach all media and return hard disks for closing, but not removable media.
      
      "Full" = 4:
        Delete all snapshots, detach all media and return all media for closing.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = CleanupMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CleanupMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CleanupMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return CleanupMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'UnregisterOnly',2:'DetachAllReturnNone',3:'DetachAllReturnHardDisksOnly',4:'Full'}
   _ValueMap = {'UnregisterOnly':1,'DetachAllReturnNone':2,'DetachAllReturnHardDisksOnly':3,'Full':4}

   UnregisterOnly = 1
   DetachAllReturnNone = 2
   DetachAllReturnHardDisksOnly = 3
   Full = 4

class CloneMode:
   """
    Clone mode, used with IMachine::cloneTo.
    
      "MachineState" = 1:
        Clone the state of the selected machine.
      
      "MachineAndChildStates" = 2:
        Clone the state of the selected machine and its child snapshots if present.
      
      "AllStates" = 3:
        Clone all states (including all snapshots) of the machine, regardless of the machine object used.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = CloneMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CloneMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CloneMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return CloneMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'MachineState',2:'MachineAndChildStates',3:'AllStates'}
   _ValueMap = {'MachineState':1,'MachineAndChildStates':2,'AllStates':3}

   MachineState = 1
   MachineAndChildStates = 2
   AllStates = 3

class CloneOptions:
   """
    Clone options, used with IMachine::cloneTo.
    
      "Link" = 1:
        Create a clone VM where all virtual disks are linked to the original VM.
      
      "KeepAllMACs" = 2:
        Don't generate new MAC addresses of the attached network adapters.
      
      "KeepNATMACs" = 3:
        Don't generate new MAC addresses of the attached network adapters when they are using NAT.
      
      "KeepDiskNames" = 4:
        Don't change the disk names.
      
      "KeepHwUUIDs" = 5:
        Don't change UUID of the machine hardware.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = CloneOptions._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CloneOptions):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CloneOptions):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return CloneOptions._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'Link',2:'KeepAllMACs',3:'KeepNATMACs',4:'KeepDiskNames',5:'KeepHwUUIDs'}
   _ValueMap = {'Link':1,'KeepAllMACs':2,'KeepNATMACs':3,'KeepDiskNames':4,'KeepHwUUIDs':5}

   Link = 1
   KeepAllMACs = 2
   KeepNATMACs = 3
   KeepDiskNames = 4
   KeepHwUUIDs = 5

class AutostopType:
   """
    Autostop types, used with IMachine::autostopType.
    
      "Disabled" = 1:
        Stopping the VM during system shutdown is disabled.
      
      "SaveState" = 2:
        The state of the VM will be saved when the system shuts down.
      
      "PowerOff" = 3:
        The VM is powered off when the system shuts down.
      
      "AcpiShutdown" = 4:
        An ACPI shutdown event is generated.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AutostopType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AutostopType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AutostopType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AutostopType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'Disabled',2:'SaveState',3:'PowerOff',4:'AcpiShutdown'}
   _ValueMap = {'Disabled':1,'SaveState':2,'PowerOff':3,'AcpiShutdown':4}

   Disabled = 1
   SaveState = 2
   PowerOff = 3
   AcpiShutdown = 4

class VMProcPriority:
   """
      Virtual machine process priorities.
    
      "Invalid" = 0:
        Invalid priority, do not use.
      
      "Default" = 1:
        Default process priority determined by the OS.
      
      "Flat" = 2:
        Assumes a scheduling policy which puts the process at the default
        priority and with all thread at the same priority
      
      "Low" = 3:
        Assumes a scheduling policy which puts the process mostly below the
        default priority of the host OS.
      
      "Normal" = 5:
        Assume a scheduling policy which shares the CPU resources fairly with
        other processes running with the default priority of the host OS.
      
      "High" = 6:
        Assumes a scheduling policy which puts the task above the default
        priority of the host OS. This policy might easily cause other tasks
        in the system to starve.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = VMProcPriority._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VMProcPriority):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VMProcPriority):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return VMProcPriority._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Invalid',1:'Default',2:'Flat',3:'Low',5:'Normal',6:'High'}
   _ValueMap = {'Invalid':0,'Default':1,'Flat':2,'Low':3,'Normal':5,'High':6}

   Invalid = 0
   Default = 1
   Flat = 2
   Low = 3
   Normal = 5
   High = 6

class HostNetworkInterfaceMediumType:
   """
      Type of encapsulation. Ethernet encapsulation includes both wired and
      wireless Ethernet connections.
      
        .. sealso:: ::IHostNetworkInterface
      "Unknown" = 0:
        The type of interface cannot be determined.
      
      "Ethernet" = 1:
        Ethernet frame encapsulation.
      
      "PPP" = 2:
        Point-to-point protocol encapsulation.
      
      "SLIP" = 3:
        Serial line IP encapsulation.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = HostNetworkInterfaceMediumType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,HostNetworkInterfaceMediumType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,HostNetworkInterfaceMediumType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return HostNetworkInterfaceMediumType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Unknown',1:'Ethernet',2:'PPP',3:'SLIP'}
   _ValueMap = {'Unknown':0,'Ethernet':1,'PPP':2,'SLIP':3}

   Unknown = 0
   Ethernet = 1
   PPP = 2
   SLIP = 3

class HostNetworkInterfaceStatus:
   """
      Current status of the interface.
      
        .. sealso:: ::IHostNetworkInterface
      "Unknown" = 0:
        The state of interface cannot be determined.
      
      "Up" = 1:
        The interface is fully operational.
      
      "Down" = 2:
        The interface is not functioning.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = HostNetworkInterfaceStatus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,HostNetworkInterfaceStatus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,HostNetworkInterfaceStatus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return HostNetworkInterfaceStatus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Unknown',1:'Up',2:'Down'}
   _ValueMap = {'Unknown':0,'Up':1,'Down':2}

   Unknown = 0
   Up = 1
   Down = 2

class HostNetworkInterfaceType:
   """
      Network interface type.
    
      "Bridged" = 1:
        
      "HostOnly" = 2:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = HostNetworkInterfaceType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,HostNetworkInterfaceType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,HostNetworkInterfaceType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return HostNetworkInterfaceType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'Bridged',2:'HostOnly'}
   _ValueMap = {'Bridged':1,'HostOnly':2}

   Bridged = 1
   HostOnly = 2

class ProxyMode:
   """ Proxy setting: System (default), NoProxy and Manual. ISystemProperties::proxyMode
      "System" = 0:
        Use the system proxy settings as far as possible.
      
      "NoProxy" = 1:
        Direct connection to the Internet.
      
      "Manual" = 2:
        Use the manual proxy from ISystemProperties::proxyURL.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ProxyMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProxyMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProxyMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ProxyMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'System',1:'NoProxy',2:'Manual'}
   _ValueMap = {'System':0,'NoProxy':1,'Manual':2}

   System = 0
   NoProxy = 1
   Manual = 2

class AdditionsFacilityType:
   """
      Guest Additions facility IDs.
    
      "None" = 0:
        No/invalid facility.
      
      "VBoxGuestDriver" = 20:
        VirtualBox base driver (VBoxGuest).
      
      "AutoLogon" = 90:
        Auto-logon modules (VBoxGINA, VBoxCredProv, pam_vbox).
      
      "VBoxService" = 100:
        VirtualBox system service (VBoxService).
      
      "VBoxTrayClient" = 101:
        VirtualBox desktop integration (VBoxTray on Windows, VBoxClient on non-Windows).
      
      "Seamless" = 1000:
        Seamless guest desktop integration.
      
      "Graphics" = 1100:Guest graphics mode. If not enabled, seamless rendering will not work, resize hints
        are not immediately acted on and guest display resizes are probably not initiated by
        the guest additions.
      
      "MonitorAttach" = 1101:Guest supports monitor hotplug.
      
      "All" = 2147483646:
        All facilities selected.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AdditionsFacilityType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AdditionsFacilityType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AdditionsFacilityType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AdditionsFacilityType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',20:'VBoxGuestDriver',90:'AutoLogon',100:'VBoxService',101:'VBoxTrayClient',1000:'Seamless',1100:'Graphics',1101:'MonitorAttach',2147483646:'All'}
   _ValueMap = {'None':0,'VBoxGuestDriver':20,'AutoLogon':90,'VBoxService':100,'VBoxTrayClient':101,'Seamless':1000,'Graphics':1100,'MonitorAttach':1101,'All':2147483646}

   _None = 0
   VBoxGuestDriver = 20
   AutoLogon = 90
   VBoxService = 100
   VBoxTrayClient = 101
   Seamless = 1000
   Graphics = 1100
   MonitorAttach = 1101
   All = 2147483646

class AdditionsFacilityClass:
   """
      Guest Additions facility classes.
    
      "None" = 0:
        No/invalid class.
      
      "Driver" = 10:
        Driver.
      
      "Service" = 30:
        System service.
      
      "Program" = 50:
        Program.
      
      "Feature" = 100:
        Feature.
      
      "ThirdParty" = 999:
        Third party.
      
      "All" = 2147483646:
        All facility classes selected.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AdditionsFacilityClass._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AdditionsFacilityClass):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AdditionsFacilityClass):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AdditionsFacilityClass._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',10:'Driver',30:'Service',50:'Program',100:'Feature',999:'ThirdParty',2147483646:'All'}
   _ValueMap = {'None':0,'Driver':10,'Service':30,'Program':50,'Feature':100,'ThirdParty':999,'All':2147483646}

   _None = 0
   Driver = 10
   Service = 30
   Program = 50
   Feature = 100
   ThirdParty = 999
   All = 2147483646

class AdditionsFacilityStatus:
   """
      Guest Additions facility states.
    
      "Inactive" = 0:
        Facility is not active.
      
      "Paused" = 1:
        Facility has been paused.
      
      "PreInit" = 20:
        Facility is preparing to initialize.
      
      "Init" = 30:
        Facility is initializing.
      
      "Active" = 50:
        Facility is up and running.
      
      "Terminating" = 100:
        Facility is shutting down.
      
      "Terminated" = 101:
        Facility successfully shut down.
      
      "Failed" = 800:
        Facility failed to start.
      
      "Unknown" = 999:
        Facility status is unknown.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AdditionsFacilityStatus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AdditionsFacilityStatus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AdditionsFacilityStatus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AdditionsFacilityStatus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Inactive',1:'Paused',20:'PreInit',30:'Init',50:'Active',100:'Terminating',101:'Terminated',800:'Failed',999:'Unknown'}
   _ValueMap = {'Inactive':0,'Paused':1,'PreInit':20,'Init':30,'Active':50,'Terminating':100,'Terminated':101,'Failed':800,'Unknown':999}

   Inactive = 0
   Paused = 1
   PreInit = 20
   Init = 30
   Active = 50
   Terminating = 100
   Terminated = 101
   Failed = 800
   Unknown = 999

class AdditionsRunLevelType:
   """
      Guest Additions run level type.
    
      "None" = 0:
        Guest Additions are not loaded.
      
      "System" = 1:
        Guest drivers are loaded.
      
      "Userland" = 2:
        Common components (such as application services) are loaded.
      
      "Desktop" = 3:
        Per-user desktop components are loaded.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AdditionsRunLevelType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AdditionsRunLevelType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AdditionsRunLevelType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AdditionsRunLevelType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'System',2:'Userland',3:'Desktop'}
   _ValueMap = {'None':0,'System':1,'Userland':2,'Desktop':3}

   _None = 0
   System = 1
   Userland = 2
   Desktop = 3

class AdditionsUpdateFlag:
   """
      Guest Additions update flags.
    
      "None" = 0:
        No flag set.
      
      "WaitForUpdateStartOnly" = 1:Starts the regular updating process and waits until the
        actual Guest Additions update inside the guest was started.
        This can be necessary due to needed interaction with the guest
        OS during the installation phase.
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AdditionsUpdateFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AdditionsUpdateFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AdditionsUpdateFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AdditionsUpdateFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'WaitForUpdateStartOnly'}
   _ValueMap = {'None':0,'WaitForUpdateStartOnly':1}

   _None = 0
   WaitForUpdateStartOnly = 1

class GuestSessionStatus:
   """
      Guest session status. This enumeration represents possible values of
      the IGuestSession::status attribute.
    
      "Undefined" = 0:
        Guest session is in an undefined state.
      
      "Starting" = 10:
        Guest session is being started.
      
      "Started" = 100:
        Guest session has been started.
      
      "Terminating" = 480:
        Guest session is being terminated.
      
      "Terminated" = 500:
        Guest session terminated normally.
      
      "TimedOutKilled" = 512:
        Guest session timed out and was killed.
      
      "TimedOutAbnormally" = 513:
        Guest session timed out and was not killed successfully.
      
      "Down" = 600:
        Service/OS is stopping, guest session was killed.
      
      "Error" = 800:
        Something went wrong.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = GuestSessionStatus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,GuestSessionStatus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,GuestSessionStatus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return GuestSessionStatus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Undefined',10:'Starting',100:'Started',480:'Terminating',500:'Terminated',512:'TimedOutKilled',513:'TimedOutAbnormally',600:'Down',800:'Error'}
   _ValueMap = {'Undefined':0,'Starting':10,'Started':100,'Terminating':480,'Terminated':500,'TimedOutKilled':512,'TimedOutAbnormally':513,'Down':600,'Error':800}

   Undefined = 0
   Starting = 10
   Started = 100
   Terminating = 480
   Terminated = 500
   TimedOutKilled = 512
   TimedOutAbnormally = 513
   Down = 600
   Error = 800

class GuestSessionWaitForFlag:
   """
      Guest session waiting flags.
    
      "None" = 0:
        No waiting flags specified. Do not use this.
      
      "Start" = 1:
        Wait for the guest session being started.
      
      "Terminate" = 2:
        Wait for the guest session being terminated.
      
      "Status" = 4:
        Wait for the next guest session status change.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = GuestSessionWaitForFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,GuestSessionWaitForFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,GuestSessionWaitForFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return GuestSessionWaitForFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'Start',2:'Terminate',4:'Status'}
   _ValueMap = {'None':0,'Start':1,'Terminate':2,'Status':4}

   _None = 0
   Start = 1
   Terminate = 2
   Status = 4

class GuestSessionWaitResult:
   """
      Guest session waiting results. Depending on the session waiting flags (for
      more information see ::GuestSessionWaitForFlag) the waiting result
      can vary based on the session's current status.

      To wait for a guest session to terminate after it has been
      created by IGuest::createSession one would specify
      GuestSessionWaitResult_Terminate.
    
      "None" = 0:
        No result was returned. Not being used.
      
      "Start" = 1:
        The guest session has been started.
      
      "Terminate" = 2:
        The guest session has been terminated.
      
      "Status" = 3:
        The guest session has changed its status. The status then can
        be retrieved via IGuestSession::status.
      
      "Error" = 4:
        Error while executing the process.
      
      "Timeout" = 5:
        The waiting operation timed out. This also will happen
        when no event has been occurred matching the
        current waiting flags in a IGuestSession::waitFor call.
      
      "WaitFlagNotSupported" = 6:
        A waiting flag specified in the IGuestSession::waitFor call
        is not supported by the guest.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = GuestSessionWaitResult._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,GuestSessionWaitResult):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,GuestSessionWaitResult):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return GuestSessionWaitResult._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'Start',2:'Terminate',3:'Status',4:'Error',5:'Timeout',6:'WaitFlagNotSupported'}
   _ValueMap = {'None':0,'Start':1,'Terminate':2,'Status':3,'Error':4,'Timeout':5,'WaitFlagNotSupported':6}

   _None = 0
   Start = 1
   Terminate = 2
   Status = 3
   Error = 4
   Timeout = 5
   WaitFlagNotSupported = 6

class GuestUserState:
   """
      State a guest user has been changed to.
    
      "Unknown" = 0:
        Unknown state. Not being used.
      
      "LoggedIn" = 1:A guest user has been successfully logged into
        the guest OS.
        
        .. note:: This property is not implemented yet!
      "LoggedOut" = 2:A guest user has been successfully logged out
        of the guest OS.
        
        .. note:: This property is not implemented yet!
      "Locked" = 3:A guest user has locked its account. This might
        include running a password-protected screensaver
        in the guest.
        
        .. note:: This property is not implemented yet!
      "Unlocked" = 4:A guest user has unlocked its account.
        
        .. note:: This property is not implemented yet!
      "Disabled" = 5:A guest user has been disabled by the guest OS.
        
        .. note:: This property is not implemented yet!
      "Idle" = 6:
        A guest user currently is not using the guest OS.
        
        .. note:: Currently only available for Windows guests since
          Windows 2000 SP2.
        .. note:: On Windows guests this function currently only supports
          reporting contiguous idle times up to 49.7 days per user.
        The event will be triggered if a guest user is not active for
        at least 5 seconds. This threshold can be adjusted by either altering
        VBoxService's command line in the guest to
        --vminfo-user-idle-threshold <ms>
        , or by setting the per-VM guest property
        /VirtualBox/GuestAdd/VBoxService/--vminfo-user-idle-threshold <ms>
        with the RDONLYGUEST flag on the host. In both cases VBoxService needs
        to be restarted in order to get the changes applied.
      
      "InUse" = 7:A guest user continued using the guest OS after
        being idle.
      "Created" = 8:A guest user has been successfully created.
        
        .. note:: This property is not implemented yet!
      "Deleted" = 9:A guest user has been successfully deleted.
        
        .. note:: This property is not implemented yet!
      "SessionChanged" = 10:To guest OS has changed the session of a user.
        
        .. note:: This property is not implemented yet!
      "CredentialsChanged" = 11:To guest OS has changed the authentication
        credentials of a user. This might include changed passwords
        and authentication types.
        
        .. note:: This property is not implemented yet!
      "RoleChanged" = 12:To guest OS has changed the role of a user permanently,
        e.g. granting / denying administrative rights.
        
        .. note:: This property is not implemented yet!
      "GroupAdded" = 13:To guest OS has added a user to a specific
        user group.
        
        .. note:: This property is not implemented yet!
      "GroupRemoved" = 14:To guest OS has removed a user from a specific
        user group.
        
        .. note:: This property is not implemented yet!
      "Elevated" = 15:To guest OS temporarily has elevated a user
        to perform a certain task.
        
        .. note:: This property is not implemented yet!
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = GuestUserState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,GuestUserState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,GuestUserState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return GuestUserState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Unknown',1:'LoggedIn',2:'LoggedOut',3:'Locked',4:'Unlocked',5:'Disabled',6:'Idle',7:'InUse',8:'Created',9:'Deleted',10:'SessionChanged',11:'CredentialsChanged',12:'RoleChanged',13:'GroupAdded',14:'GroupRemoved',15:'Elevated'}
   _ValueMap = {'Unknown':0,'LoggedIn':1,'LoggedOut':2,'Locked':3,'Unlocked':4,'Disabled':5,'Idle':6,'InUse':7,'Created':8,'Deleted':9,'SessionChanged':10,'CredentialsChanged':11,'RoleChanged':12,'GroupAdded':13,'GroupRemoved':14,'Elevated':15}

   Unknown = 0
   LoggedIn = 1
   LoggedOut = 2
   Locked = 3
   Unlocked = 4
   Disabled = 5
   Idle = 6
   InUse = 7
   Created = 8
   Deleted = 9
   SessionChanged = 10
   CredentialsChanged = 11
   RoleChanged = 12
   GroupAdded = 13
   GroupRemoved = 14
   Elevated = 15

class FileSeekOrigin:
   """
      What a file seek (IFile::seek) is relative to.
    
      "Begin" = 0:
        Seek from the beginning of the file.
      
      "Current" = 1:
        Seek from the current file position.
      
      "End" = 2:Seek relative to the end of the file.  To seek to the position two
        bytes from the end of the file, specify -2 as the seek offset.
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FileSeekOrigin._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FileSeekOrigin):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FileSeekOrigin):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FileSeekOrigin._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Begin',1:'Current',2:'End'}
   _ValueMap = {'Begin':0,'Current':1,'End':2}

   Begin = 0
   Current = 1
   End = 2

class ProcessInputFlag:
   """
      Guest process input flags.
    
      "None" = 0:
        No flag set.
      
      "EndOfFile" = 1:
        End of file (input) reached.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ProcessInputFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessInputFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessInputFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessInputFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'EndOfFile'}
   _ValueMap = {'None':0,'EndOfFile':1}

   _None = 0
   EndOfFile = 1

class ProcessOutputFlag:
   """
      Guest process output flags for specifying which
      type of output to retrieve.
    
      "None" = 0:
        No flags set. Get output from stdout.
      
      "StdErr" = 1:
        Get output from stderr.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ProcessOutputFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessOutputFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessOutputFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessOutputFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'StdErr'}
   _ValueMap = {'None':0,'StdErr':1}

   _None = 0
   StdErr = 1

class ProcessWaitForFlag:
   """
      Process waiting flags.
    
      "None" = 0:
        No waiting flags specified. Do not use this.
      
      "Start" = 1:
        Wait for the process being started.
      
      "Terminate" = 2:
        Wait for the process being terminated.
      
      "StdIn" = 4:
        Wait for stdin becoming available.
      
      "StdOut" = 8:
        Wait for data becoming available on stdout.
      
      "StdErr" = 16:
        Wait for data becoming available on stderr.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ProcessWaitForFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessWaitForFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessWaitForFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessWaitForFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'Start',2:'Terminate',4:'StdIn',8:'StdOut',16:'StdErr'}
   _ValueMap = {'None':0,'Start':1,'Terminate':2,'StdIn':4,'StdOut':8,'StdErr':16}

   _None = 0
   Start = 1
   Terminate = 2
   StdIn = 4
   StdOut = 8
   StdErr = 16

class ProcessWaitResult:
   """
      Process waiting results. Depending on the process waiting flags (for
      more information see ::ProcessWaitForFlag) the waiting result
      can vary based on the processes' current status.

      To wait for a guest process to terminate after it has been
      created by IGuestSession::processCreate or IGuestSession::processCreateEx
      one would specify ProcessWaitFor_Terminate.

      If a guest process has been started with ProcessCreateFlag_WaitForStdOut
      a client can wait with ProcessWaitResult_StdOut for new data to arrive on
      stdout; same applies for ProcessCreateFlag_WaitForStdErr and
      ProcessWaitResult_StdErr.
    
      "None" = 0:
        No result was returned. Not being used.
      
      "Start" = 1:
        The process has been started.
      
      "Terminate" = 2:
        The process has been terminated.
      
      "Status" = 3:
        The process has changed its status. The status then can
        be retrieved via IProcess::status.
      
      "Error" = 4:
        Error while executing the process.
      
      "Timeout" = 5:
        The waiting operation timed out. Also use if the guest process has
        timed out in the guest side (kill attempted).
      
      "StdIn" = 6:
        The process signalled that stdin became available for writing.
      
      "StdOut" = 7:
        Data on stdout became available for reading.
      
      "StdErr" = 8:
        Data on stderr became available for reading.
      
      "WaitFlagNotSupported" = 9:
        A waiting flag specified in the IProcess::waitFor call
        is not supported by the guest.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ProcessWaitResult._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessWaitResult):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessWaitResult):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessWaitResult._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'Start',2:'Terminate',3:'Status',4:'Error',5:'Timeout',6:'StdIn',7:'StdOut',8:'StdErr',9:'WaitFlagNotSupported'}
   _ValueMap = {'None':0,'Start':1,'Terminate':2,'Status':3,'Error':4,'Timeout':5,'StdIn':6,'StdOut':7,'StdErr':8,'WaitFlagNotSupported':9}

   _None = 0
   Start = 1
   Terminate = 2
   Status = 3
   Error = 4
   Timeout = 5
   StdIn = 6
   StdOut = 7
   StdErr = 8
   WaitFlagNotSupported = 9

class FileCopyFlag:
   """
      File copying flags.
      
        .. note:: Not flags are implemented yet.
      "None" = 0:
        No flag set.
      
      "NoReplace" = 1:
        Do not replace the destination file if it exists.
        
        .. note:: This flag is not implemented yet.
      "FollowLinks" = 2:
        Follow symbolic links.
        
        .. note:: This flag is not implemented yet.
      "Update" = 4:
        Only copy when the source file is newer than the destination file
        or when the destination file is missing.
        
        .. note:: This flag is not implemented yet.
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FileCopyFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FileCopyFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FileCopyFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FileCopyFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'NoReplace',2:'FollowLinks',4:'Update'}
   _ValueMap = {'None':0,'NoReplace':1,'FollowLinks':2,'Update':4}

   _None = 0
   NoReplace = 1
   FollowLinks = 2
   Update = 4

class FsObjMoveFlag:
   """
      File moving flags.
    
      "None" = 0:
        No flag set.
      
      "Replace" = 1:
        Replace the destination file, symlink, etc if it exists, however this
        does not allow replacing any directories.
      
      "FollowLinks" = 2:
        Follow symbolic links in the final components or not (only applied to
        the given source and target paths, not to anything else).
      
      "AllowDirectoryMoves" = 4:
        Allow moving directories accross file system boundraries. Because it
        is could be a big undertaking, we require extra assurance that we
        should do it when requested.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FsObjMoveFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FsObjMoveFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FsObjMoveFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FsObjMoveFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'Replace',2:'FollowLinks',4:'AllowDirectoryMoves'}
   _ValueMap = {'None':0,'Replace':1,'FollowLinks':2,'AllowDirectoryMoves':4}

   _None = 0
   Replace = 1
   FollowLinks = 2
   AllowDirectoryMoves = 4

class DirectoryCreateFlag:
   """
      Directory creation flags.
    
      "None" = 0:
        No flag set.
      
      "Parents" = 1:
        No error if existing, make parent directories as needed.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DirectoryCreateFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DirectoryCreateFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DirectoryCreateFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DirectoryCreateFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'Parents'}
   _ValueMap = {'None':0,'Parents':1}

   _None = 0
   Parents = 1

class DirectoryCopyFlag:
   """
      Directory copying flags.
      
        .. note:: Not flags are implemented yet.
      "None" = 0:
        No flag set.
      
      "CopyIntoExisting" = 1:
        Allow copying into an existing destination directory.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DirectoryCopyFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DirectoryCopyFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DirectoryCopyFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DirectoryCopyFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'CopyIntoExisting'}
   _ValueMap = {'None':0,'CopyIntoExisting':1}

   _None = 0
   CopyIntoExisting = 1

class DirectoryRemoveRecFlag:
   """
      Directory recursive removement flags.
      
        .. note:: 
        WARNING!! THE FLAGS ARE CURRENTLY IGNORED. THE METHOD APPLIES
                  ::DirectoryRemoveRecFlag_ContentAndDir REGARDLESS
                  OF THE INPUT.
      
      "None" = 0:
        No flag set.
      
      "ContentAndDir" = 1:
        Delete the content of the directory and the directory itself.
      
      "ContentOnly" = 2:
        Only delete the content of the directory, omit the directory it self.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DirectoryRemoveRecFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DirectoryRemoveRecFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DirectoryRemoveRecFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DirectoryRemoveRecFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'ContentAndDir',2:'ContentOnly'}
   _ValueMap = {'None':0,'ContentAndDir':1,'ContentOnly':2}

   _None = 0
   ContentAndDir = 1
   ContentOnly = 2

class FsObjRenameFlag:
   """
      Flags for use when renaming file system objects (files, directories,
      symlink, etc), see IGuestSession::fsObjRename.
    
      "NoReplace" = 0:
        Do not replace any destination object.
      
      "Replace" = 1:This will attempt to replace any destination object other except
        directories. (The default is to fail if the destination exists.)
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FsObjRenameFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FsObjRenameFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FsObjRenameFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FsObjRenameFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'NoReplace',1:'Replace'}
   _ValueMap = {'NoReplace':0,'Replace':1}

   NoReplace = 0
   Replace = 1

class ProcessCreateFlag:
   """
      Guest process execution flags.
      
        .. note:: The values are passed to the guest additions, so its not possible
            to change (move) or reuse values.here. See EXECUTEPROCESSFLAG_XXX
            in GuestControlSvc.h.
      "None" = 0:
        No flag set.
      
      "WaitForProcessStartOnly" = 1:Only use the specified timeout value to wait for starting the guest process - the guest
        process itself then uses an infinite timeout.
      "IgnoreOrphanedProcesses" = 2:
        Do not report an error when executed processes are still alive when VBoxService or the guest OS is shutting down.
      
      "Hidden" = 4:
        Do not show the started process according to the guest OS guidelines.
      
      "Profile" = 8:
        Utilize the user's profile data when exeuting a process. Only available for Windows guests at the moment.
      
      "WaitForStdOut" = 16:
        The guest process waits until all data from stdout is read out.
      
      "WaitForStdErr" = 32:
        The guest process waits until all data from stderr is read out.
      
      "ExpandArguments" = 64:Expands environment variables in process arguments.
        
        .. note:: 
          This is not yet implemented and is currently silently ignored.
          We will document the protocolVersion number for this feature once it
          appears, so don't use it till then.
        
      "UnquotedArguments" = 128:Work around for Windows and OS/2 applications not following normal
        argument quoting and escaping rules. The arguments are passed to the
        application without any extra quoting, just a single space between each.
        
        .. note:: Present since VirtualBox 4.3.28 and 5.0 beta 3.
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ProcessCreateFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessCreateFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessCreateFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessCreateFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'WaitForProcessStartOnly',2:'IgnoreOrphanedProcesses',4:'Hidden',8:'Profile',16:'WaitForStdOut',32:'WaitForStdErr',64:'ExpandArguments',128:'UnquotedArguments'}
   _ValueMap = {'None':0,'WaitForProcessStartOnly':1,'IgnoreOrphanedProcesses':2,'Hidden':4,'Profile':8,'WaitForStdOut':16,'WaitForStdErr':32,'ExpandArguments':64,'UnquotedArguments':128}

   _None = 0
   WaitForProcessStartOnly = 1
   IgnoreOrphanedProcesses = 2
   Hidden = 4
   Profile = 8
   WaitForStdOut = 16
   WaitForStdErr = 32
   ExpandArguments = 64
   UnquotedArguments = 128

class ProcessPriority:
   """
      Process priorities.
    
      "Invalid" = 0:
        Invalid priority, do not use.
      
      "Default" = 1:
        Default process priority determined by the OS.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ProcessPriority._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessPriority):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessPriority):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessPriority._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Invalid',1:'Default'}
   _ValueMap = {'Invalid':0,'Default':1}

   Invalid = 0
   Default = 1

class SymlinkType:
   """
      Symbolic link types.  This is significant when creating links on the
      Windows platform, ignored elsewhere.
    
      "Unknown" = 0:
        It is not known what is being targeted.
      
      "Directory" = 1:
        The link targets a directory.
      
      "File" = 2:
        The link targets a file (or whatever else except directories).
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = SymlinkType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,SymlinkType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,SymlinkType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return SymlinkType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Unknown',1:'Directory',2:'File'}
   _ValueMap = {'Unknown':0,'Directory':1,'File':2}

   Unknown = 0
   Directory = 1
   File = 2

class SymlinkReadFlag:
   """
      Symbolic link reading flags.
    
      "None" = 0:
        No flags set.
      
      "NoSymlinks" = 1:
        Don't allow symbolic links as part of the path.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = SymlinkReadFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,SymlinkReadFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,SymlinkReadFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return SymlinkReadFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'NoSymlinks'}
   _ValueMap = {'None':0,'NoSymlinks':1}

   _None = 0
   NoSymlinks = 1

class ProcessStatus:
   """
      Process execution statuses.
    
      "Undefined" = 0:
        Process is in an undefined state.
      
      "Starting" = 10:
        Process is being started.
      
      "Started" = 100:
        Process has been started.
      
      "Paused" = 110:
        Process has been paused.
      
      "Terminating" = 480:
        Process is being terminated.
      
      "TerminatedNormally" = 500:
        Process terminated normally.
      
      "TerminatedSignal" = 510:
        Process terminated via signal.
      
      "TerminatedAbnormally" = 511:
        Process terminated abnormally.
      
      "TimedOutKilled" = 512:
        Process timed out and was killed.
      
      "TimedOutAbnormally" = 513:
        Process timed out and was not killed successfully.
      
      "Down" = 600:
        Service/OS is stopping, process was killed.
      
      "Error" = 800:
        Something went wrong.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ProcessStatus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessStatus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessStatus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessStatus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Undefined',10:'Starting',100:'Started',110:'Paused',480:'Terminating',500:'TerminatedNormally',510:'TerminatedSignal',511:'TerminatedAbnormally',512:'TimedOutKilled',513:'TimedOutAbnormally',600:'Down',800:'Error'}
   _ValueMap = {'Undefined':0,'Starting':10,'Started':100,'Paused':110,'Terminating':480,'TerminatedNormally':500,'TerminatedSignal':510,'TerminatedAbnormally':511,'TimedOutKilled':512,'TimedOutAbnormally':513,'Down':600,'Error':800}

   Undefined = 0
   Starting = 10
   Started = 100
   Paused = 110
   Terminating = 480
   TerminatedNormally = 500
   TerminatedSignal = 510
   TerminatedAbnormally = 511
   TimedOutKilled = 512
   TimedOutAbnormally = 513
   Down = 600
   Error = 800

class ProcessInputStatus:
   """
      Process input statuses.
    
      "Undefined" = 0:
        Undefined state.
      
      "Broken" = 1:
        Input pipe is broken.
      
      "Available" = 10:
        Input pipe became available for writing.
      
      "Written" = 50:
        Data has been successfully written.
      
      "Overflow" = 100:
        Too much input data supplied, data overflow.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ProcessInputStatus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessInputStatus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessInputStatus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessInputStatus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Undefined',1:'Broken',10:'Available',50:'Written',100:'Overflow'}
   _ValueMap = {'Undefined':0,'Broken':1,'Available':10,'Written':50,'Overflow':100}

   Undefined = 0
   Broken = 1
   Available = 10
   Written = 50
   Overflow = 100

class PathStyle:
   """
      The path style of a system.
      (Values matches the RTPATH_STR_F_STYLE_XXX defines in iprt/path.h!)
    
      "DOS" = 1:DOS-style paths with forward and backward slashes, drive
      letters and UNC.  Known from DOS, OS/2 and Windows.
      "UNIX" = 2:
        UNIX-style paths with forward slashes only.
      
      "Unknown" = 8:
        The path style is not known, most likely because the guest additions
        aren't active yet.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = PathStyle._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,PathStyle):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,PathStyle):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return PathStyle._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'DOS',2:'UNIX',8:'Unknown'}
   _ValueMap = {'DOS':1,'UNIX':2,'Unknown':8}

   DOS = 1
   UNIX = 2
   Unknown = 8

class FileAccessMode:
   """
      File open access mode for use with IGuestSession::fileOpen
      and IGuestSession::fileOpenEx.
    
      "ReadOnly" = 1:
        Open the file only with read access.
      
      "WriteOnly" = 2:
        Open the file only with write access.
      
      "ReadWrite" = 3:
        Open the file with both read and write access.
      
      "AppendOnly" = 4:Open the file for appending only, no read or seek access.
        
        .. note:: Not yet implemented.
      "AppendRead" = 5:Open the file for appending and read.  Writes always goes to the
        end of the file while reads are done at the current or specified file
        position.
        
        .. note:: Not yet implemented.
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FileAccessMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FileAccessMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FileAccessMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FileAccessMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'ReadOnly',2:'WriteOnly',3:'ReadWrite',4:'AppendOnly',5:'AppendRead'}
   _ValueMap = {'ReadOnly':1,'WriteOnly':2,'ReadWrite':3,'AppendOnly':4,'AppendRead':5}

   ReadOnly = 1
   WriteOnly = 2
   ReadWrite = 3
   AppendOnly = 4
   AppendRead = 5

class FileOpenAction:
   """
      What action IGuestSession::fileOpen and IGuestSession::fileOpenEx
      should take whether the file being opened exists or not.
    
      "OpenExisting" = 1:
        Opens an existing file, fails if no file exists. (Was "oe".)
      
      "OpenOrCreate" = 2:
        Opens an existing file, creates a new one if no file exists. (Was "oc".)
      
      "CreateNew" = 3:
        Creates a new file is no file exists, fails if there is a file there already. (Was "ce".)
      
      "CreateOrReplace" = 4:
        Creates a new file, replace any existing file. (Was "ca".)
        
        .. note:: 
          Currently undefined whether we will inherit mode and ACLs from the
          existing file or replace them.
        
      "OpenExistingTruncated" = 5:
        Opens and truncate an existing file, fails if no file exists. (Was "ot".)
      
      "AppendOrCreate" = 99:Opens an existing file and places the file pointer at the end of
        the file, creates the file if it does not exist.  This action implies
        write access. (Was "oa".)
        
        .. note:: 
          Deprecated. Only here for historical reasons. Do not use!
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FileOpenAction._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FileOpenAction):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FileOpenAction):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FileOpenAction._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'OpenExisting',2:'OpenOrCreate',3:'CreateNew',4:'CreateOrReplace',5:'OpenExistingTruncated',99:'AppendOrCreate'}
   _ValueMap = {'OpenExisting':1,'OpenOrCreate':2,'CreateNew':3,'CreateOrReplace':4,'OpenExistingTruncated':5,'AppendOrCreate':99}

   OpenExisting = 1
   OpenOrCreate = 2
   CreateNew = 3
   CreateOrReplace = 4
   OpenExistingTruncated = 5
   AppendOrCreate = 99

class FileSharingMode:
   """
      File sharing mode for IGuestSession::fileOpenEx.
    
      "Read" = 1:
        Only share read access to the file.
      
      "Write" = 2:
        Only share write access to the file.
      
      "ReadWrite" = 3:
        Share both read and write access to the file, but deny deletion.
      
      "Delete" = 4:
        Only share delete access, denying read and write.
      
      "ReadDelete" = 5:
        Share read and delete access to the file, denying writing.
      
      "WriteDelete" = 6:
        Share write and delete access to the file, denying reading.
      
      "All" = 7:
        Share all access, i.e. read, write and delete, to the file.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FileSharingMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FileSharingMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FileSharingMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FileSharingMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'Read',2:'Write',3:'ReadWrite',4:'Delete',5:'ReadDelete',6:'WriteDelete',7:'All'}
   _ValueMap = {'Read':1,'Write':2,'ReadWrite':3,'Delete':4,'ReadDelete':5,'WriteDelete':6,'All':7}

   Read = 1
   Write = 2
   ReadWrite = 3
   Delete = 4
   ReadDelete = 5
   WriteDelete = 6
   All = 7

class FileOpenExFlag:
   """
      Open flags for IGuestSession::fileOpenEx.
    
      "None" = 0:
        No flag set.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FileOpenExFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FileOpenExFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FileOpenExFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FileOpenExFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None'}
   _ValueMap = {'None':0}

   _None = 0

class FileStatus:
   """
      File statuses.
    
      "Undefined" = 0:
        File is in an undefined state.
      
      "Opening" = 10:
        Guest file is opening.
      
      "Open" = 100:
        Guest file has been successfully opened.
      
      "Closing" = 150:
        Guest file closing.
      
      "Closed" = 200:
        Guest file has been closed.
      
      "Down" = 600:
        Service/OS is stopping, guest file was closed.
      
      "Error" = 800:
        Something went wrong.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FileStatus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FileStatus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FileStatus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FileStatus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Undefined',10:'Opening',100:'Open',150:'Closing',200:'Closed',600:'Down',800:'Error'}
   _ValueMap = {'Undefined':0,'Opening':10,'Open':100,'Closing':150,'Closed':200,'Down':600,'Error':800}

   Undefined = 0
   Opening = 10
   Open = 100
   Closing = 150
   Closed = 200
   Down = 600
   Error = 800

class FsObjType:
   """
      File system object (file) types.
    
      "Unknown" = 1:Used either if the object has type that is not in this enum, or
        if the type has not yet been determined or set.
      "Fifo" = 2:
        FIFO or named pipe, depending on the platform/terminology.
      
      "DevChar" = 3:
        Character device.
      
      "Directory" = 4:
        Directory.
      
      "DevBlock" = 5:
        Block device.
      
      "File" = 6:
        Regular file.
      
      "Symlink" = 7:
        Symbolic link.
      
      "Socket" = 8:
        Socket.
      
      "WhiteOut" = 9:A white-out file.  Found in union mounts where it is used for
        hiding files after deletion, I think. 
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FsObjType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FsObjType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FsObjType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FsObjType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'Unknown',2:'Fifo',3:'DevChar',4:'Directory',5:'DevBlock',6:'File',7:'Symlink',8:'Socket',9:'WhiteOut'}
   _ValueMap = {'Unknown':1,'Fifo':2,'DevChar':3,'Directory':4,'DevBlock':5,'File':6,'Symlink':7,'Socket':8,'WhiteOut':9}

   Unknown = 1
   Fifo = 2
   DevChar = 3
   Directory = 4
   DevBlock = 5
   File = 6
   Symlink = 7
   Socket = 8
   WhiteOut = 9

class DnDAction:
   """
      Possible actions of a drag'n drop operation.
    
      "Ignore" = 0:
        Do nothing.
      
      "Copy" = 1:
        Copy the item to the target.
      
      "Move" = 2:
        Move the item to the target.
      
      "Link" = 3:
        Link the item from within the target.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DnDAction._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DnDAction):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DnDAction):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DnDAction._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Ignore',1:'Copy',2:'Move',3:'Link'}
   _ValueMap = {'Ignore':0,'Copy':1,'Move':2,'Link':3}

   Ignore = 0
   Copy = 1
   Move = 2
   Link = 3

class DirectoryOpenFlag:
   """
      Directory open flags.
    
      "None" = 0:
        No flag set.
      
      "NoSymlinks" = 1:
        Don't allow symbolic links as part of the path.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DirectoryOpenFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DirectoryOpenFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DirectoryOpenFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DirectoryOpenFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'None',1:'NoSymlinks'}
   _ValueMap = {'None':0,'NoSymlinks':1}

   _None = 0
   NoSymlinks = 1

class MediumState:
   """
      Virtual medium state.
      
        .. sealso:: ::IMedium
      "NotCreated" = 0:
        Associated medium storage does not exist (either was not created yet or
        was deleted).
      
      "Created" = 1:
        Associated storage exists and accessible; this gets set if the
        accessibility check performed by IMedium::refreshState
        was successful.
      
      "LockedRead" = 2:
        Medium is locked for reading (see IMedium::lockRead),
        no data modification is possible.
      
      "LockedWrite" = 3:
        Medium is locked for writing (see IMedium::lockWrite),
        no concurrent data reading or modification is possible.
      
      "Inaccessible" = 4:
        Medium accessibility check (see IMedium::refreshState) has
        not yet been performed, or else, associated medium storage is not
        accessible. In the first case, IMedium::lastAccessError
        is empty, in the second case, it describes the error that occurred.
      
      "Creating" = 5:
        Associated medium storage is being created.
      
      "Deleting" = 6:
        Associated medium storage is being deleted.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = MediumState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MediumState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MediumState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return MediumState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'NotCreated',1:'Created',2:'LockedRead',3:'LockedWrite',4:'Inaccessible',5:'Creating',6:'Deleting'}
   _ValueMap = {'NotCreated':0,'Created':1,'LockedRead':2,'LockedWrite':3,'Inaccessible':4,'Creating':5,'Deleting':6}

   NotCreated = 0
   Created = 1
   LockedRead = 2
   LockedWrite = 3
   Inaccessible = 4
   Creating = 5
   Deleting = 6

class MediumType:
   """
      Virtual medium type. For each ::IMedium, this defines how the medium is
      attached to a virtual machine (see ::IMediumAttachment) and what happens
      when a snapshot (see ::ISnapshot) is taken of a virtual machine which has
      the medium attached. At the moment DVD and floppy media are always of type "writethrough".
    
      "Normal" = 0:
        Normal medium (attached directly or indirectly, preserved
        when taking snapshots).
      
      "Immutable" = 1:
        Immutable medium (attached indirectly, changes are wiped out
        the next time the virtual machine is started).
      
      "Writethrough" = 2:
        Write through medium (attached directly, ignored when
        taking snapshots).
      
      "Shareable" = 3:
        Allow using this medium concurrently by several machines.
        
        .. note:: Present since VirtualBox 3.2.0, and accepted since 3.2.8.
      "Readonly" = 4:
        A readonly medium, which can of course be used by several machines.
        
        .. note:: Present and accepted since VirtualBox 4.0.
      "MultiAttach" = 5:
        A medium which is indirectly attached, so that one base medium can
        be used for several VMs which have their own differencing medium to
        store their modifications. In some sense a variant of Immutable
        with unset AutoReset flag in each differencing medium.
        
        .. note:: Present and accepted since VirtualBox 4.0.
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = MediumType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MediumType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MediumType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return MediumType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Normal',1:'Immutable',2:'Writethrough',3:'Shareable',4:'Readonly',5:'MultiAttach'}
   _ValueMap = {'Normal':0,'Immutable':1,'Writethrough':2,'Shareable':3,'Readonly':4,'MultiAttach':5}

   Normal = 0
   Immutable = 1
   Writethrough = 2
   Shareable = 3
   Readonly = 4
   MultiAttach = 5

class MediumVariant:
   """
      Virtual medium image variant. More than one flag may be set.
      
        .. sealso:: ::IMedium
      "Standard" = 0:
        No particular variant requested, results in using the backend default.
      
      "VmdkSplit2G" = 0x01:
        VMDK image split in chunks of less than 2GByte.
      
      "VmdkRawDisk" = 0x02:
        VMDK image representing a raw disk.
      
      "VmdkStreamOptimized" = 0x04:
        VMDK streamOptimized image. Special import/export format which is
        read-only/append-only.
      
      "VmdkESX" = 0x08:
        VMDK format variant used on ESX products.
      
      "VdiZeroExpand" = 0x100:
        Fill new blocks with zeroes while expanding image file.
      
      "Fixed" = 0x10000:
        Fixed image. Only allowed for base images.
      
      "Diff" = 0x20000:
        Differencing image. Only allowed for child images.
      
      "Formatted" = 0x20000000:
        Special flag which requests formatting the disk image. Right now
        supported for floppy images only.
      
      "NoCreateDir" = 0x40000000:
        Special flag which suppresses automatic creation of the subdirectory.
        Only used when passing the medium variant as an input parameter.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = MediumVariant._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MediumVariant):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MediumVariant):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return MediumVariant._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Standard',0x01:'VmdkSplit2G',0x02:'VmdkRawDisk',0x04:'VmdkStreamOptimized',0x08:'VmdkESX',0x100:'VdiZeroExpand',0x10000:'Fixed',0x20000:'Diff',0x20000000:'Formatted',0x40000000:'NoCreateDir'}
   _ValueMap = {'Standard':0,'VmdkSplit2G':0x01,'VmdkRawDisk':0x02,'VmdkStreamOptimized':0x04,'VmdkESX':0x08,'VdiZeroExpand':0x100,'Fixed':0x10000,'Diff':0x20000,'Formatted':0x20000000,'NoCreateDir':0x40000000}

   Standard = 0
   VmdkSplit2G = 0x01
   VmdkRawDisk = 0x02
   VmdkStreamOptimized = 0x04
   VmdkESX = 0x08
   VdiZeroExpand = 0x100
   Fixed = 0x10000
   Diff = 0x20000
   Formatted = 0x20000000
   NoCreateDir = 0x40000000

class DataType:
   """
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DataType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DataType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DataType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DataType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Int32',1:'Int8',2:'String'}
   _ValueMap = {'Int32':0,'Int8':1,'String':2}

   Int32 = 0
   Int8 = 1
   String = 2

class DataFlags:
   """
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = DataFlags._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DataFlags):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DataFlags):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return DataFlags._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0x00:'None',0x01:'Mandatory',0x02:'Expert',0x04:'Array',0x07:'FlagMask'}
   _ValueMap = {'None':0x00,'Mandatory':0x01,'Expert':0x02,'Array':0x04,'FlagMask':0x07}

   _None = 0x00
   Mandatory = 0x01
   Expert = 0x02
   Array = 0x04
   FlagMask = 0x07

class MediumFormatCapabilities:
   """
      Medium format capability flags.
    
      "Uuid" = 0x01:
        Supports UUIDs as expected by VirtualBox code.
      
      "CreateFixed" = 0x02:
        Supports creating fixed size images, allocating all space instantly.
      
      "CreateDynamic" = 0x04:
        Supports creating dynamically growing images, allocating space on
        demand.
      
      "CreateSplit2G" = 0x08:
        Supports creating images split in chunks of a bit less than 2 GBytes.
      
      "Differencing" = 0x10:
        Supports being used as a format for differencing media (see IMedium::createDiffStorage).
      
      "Asynchronous" = 0x20:
        Supports asynchronous I/O operations for at least some configurations.
      
      "File" = 0x40:
        The format backend operates on files (the IMedium::location
        attribute of the medium specifies a file used to store medium
        data; for a list of supported file extensions see
        IMediumFormat::describeFileExtensions).
      
      "Properties" = 0x80:
        The format backend uses the property interface to configure the storage
        location and properties (the IMediumFormat::describeProperties
        method is used to get access to properties supported by the given medium format).
      
      "TcpNetworking" = 0x100:
        The format backend uses the TCP networking interface for network access.
      
      "VFS" = 0x200:
        The format backend supports virtual filesystem functionality.
      
      "Discard" = 0x400:
        The format backend supports discarding blocks.
      
      "Preferred" = 0x800:
        Indicates that this is a frequently used format backend.
      
      "CapabilityMask" = 0xFFF:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = MediumFormatCapabilities._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MediumFormatCapabilities):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MediumFormatCapabilities):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return MediumFormatCapabilities._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0x01:'Uuid',0x02:'CreateFixed',0x04:'CreateDynamic',0x08:'CreateSplit2G',0x10:'Differencing',0x20:'Asynchronous',0x40:'File',0x80:'Properties',0x100:'TcpNetworking',0x200:'VFS',0x400:'Discard',0x800:'Preferred',0xFFF:'CapabilityMask'}
   _ValueMap = {'Uuid':0x01,'CreateFixed':0x02,'CreateDynamic':0x04,'CreateSplit2G':0x08,'Differencing':0x10,'Asynchronous':0x20,'File':0x40,'Properties':0x80,'TcpNetworking':0x100,'VFS':0x200,'Discard':0x400,'Preferred':0x800,'CapabilityMask':0xFFF}

   Uuid = 0x01
   CreateFixed = 0x02
   CreateDynamic = 0x04
   CreateSplit2G = 0x08
   Differencing = 0x10
   Asynchronous = 0x20
   File = 0x40
   Properties = 0x80
   TcpNetworking = 0x100
   VFS = 0x200
   Discard = 0x400
   Preferred = 0x800
   CapabilityMask = 0xFFF

class PartitionTableType:
   """
      Partition table types.
    
      "MBR" = 1:
        
      "GPT" = 2:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = PartitionTableType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,PartitionTableType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,PartitionTableType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return PartitionTableType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'MBR',2:'GPT'}
   _ValueMap = {'MBR':1,'GPT':2}

   MBR = 1
   GPT = 2

class KeyboardLED:
   """
      Keyboard LED indicators.
    
      "NumLock" = 0x01:
        
      "CapsLock" = 0x02:
        
      "ScrollLock" = 0x04:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = KeyboardLED._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,KeyboardLED):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,KeyboardLED):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return KeyboardLED._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0x01:'NumLock',0x02:'CapsLock',0x04:'ScrollLock'}
   _ValueMap = {'NumLock':0x01,'CapsLock':0x02,'ScrollLock':0x04}

   NumLock = 0x01
   CapsLock = 0x02
   ScrollLock = 0x04

class MouseButtonState:
   """
      Mouse button state.
    
      "LeftButton" = 0x01:
        
      "RightButton" = 0x02:
        
      "MiddleButton" = 0x04:
        
      "WheelUp" = 0x08:
        
      "WheelDown" = 0x10:
        
      "XButton1" = 0x20:
        
      "XButton2" = 0x40:
        
      "MouseStateMask" = 0x7F:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = MouseButtonState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MouseButtonState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MouseButtonState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return MouseButtonState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0x01:'LeftButton',0x02:'RightButton',0x04:'MiddleButton',0x08:'WheelUp',0x10:'WheelDown',0x20:'XButton1',0x40:'XButton2',0x7F:'MouseStateMask'}
   _ValueMap = {'LeftButton':0x01,'RightButton':0x02,'MiddleButton':0x04,'WheelUp':0x08,'WheelDown':0x10,'XButton1':0x20,'XButton2':0x40,'MouseStateMask':0x7F}

   LeftButton = 0x01
   RightButton = 0x02
   MiddleButton = 0x04
   WheelUp = 0x08
   WheelDown = 0x10
   XButton1 = 0x20
   XButton2 = 0x40
   MouseStateMask = 0x7F

class TouchContactState:
   """
      Touch event contact state.
    
      "None" = 0x00:
        The touch has finished.
      
      "InContact" = 0x01:
        Whether the touch is really touching the device.
      
      "InRange" = 0x02:
        Whether the touch is close enough to the device to be detected.
      
      "ContactStateMask" = 0x03:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = TouchContactState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,TouchContactState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,TouchContactState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return TouchContactState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0x00:'None',0x01:'InContact',0x02:'InRange',0x03:'ContactStateMask'}
   _ValueMap = {'None':0x00,'InContact':0x01,'InRange':0x02,'ContactStateMask':0x03}

   _None = 0x00
   InContact = 0x01
   InRange = 0x02
   ContactStateMask = 0x03

class FramebufferCapabilities:
   """
      Framebuffer capability flags.
    
      "UpdateImage" = 0x01:
        Requires NotifyUpdateImage. NotifyUpdate must not be called.
      
      "VHWA" = 0x02:
        Supports VHWA interface. If set, then
        IFramebuffer::processVHWACommand can be called. 
      "VisibleRegion" = 0x04:
        Supports visible region. If set, then
        IFramebuffer::setVisibleRegion can be called. 
      "RenderCursor" = 0x08:
        This framebuffer implementation can render a pointer cursor itself.  Unless the
        MoveCursor capability is also set the cursor will always be rendered at the
        location of (and usually using) the host pointer.
      
      "MoveCursor" = 0x10:
        Supports rendering a pointer cursor anywhere within the guest screen.  Implies
        RenderCursor.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FramebufferCapabilities._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FramebufferCapabilities):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FramebufferCapabilities):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FramebufferCapabilities._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0x01:'UpdateImage',0x02:'VHWA',0x04:'VisibleRegion',0x08:'RenderCursor',0x10:'MoveCursor'}
   _ValueMap = {'UpdateImage':0x01,'VHWA':0x02,'VisibleRegion':0x04,'RenderCursor':0x08,'MoveCursor':0x10}

   UpdateImage = 0x01
   VHWA = 0x02
   VisibleRegion = 0x04
   RenderCursor = 0x08
   MoveCursor = 0x10

class GuestMonitorStatus:
   """
      The current status of the guest display.
    
      "Disabled" = 0:
        The guest monitor is disabled in the guest.
      
      "Enabled" = 1:
        The guest monitor is enabled in the guest.
      
      "Blank" = 2:
        The guest monitor is enabled in the guest but should display nothing.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = GuestMonitorStatus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,GuestMonitorStatus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,GuestMonitorStatus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return GuestMonitorStatus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Disabled',1:'Enabled',2:'Blank'}
   _ValueMap = {'Disabled':0,'Enabled':1,'Blank':2}

   Disabled = 0
   Enabled = 1
   Blank = 2

class ScreenLayoutMode:
   """
      How IDisplay::setScreenLayout method should work.
    
      "Apply" = 0:
        If the guest is already at desired mode then the API might avoid setting the mode.
      
      "Reset" = 1:
        Always set the new mode even if the guest is already at desired mode.
      
      "Attach" = 2:
        Attach new screens and always set the new mode for existing screens.
      
      "Silent" = 3:
        Do not notify the guest of the change.  Normally this is wished, but it
        might not be when re-setting monitor information from the last session
        (no hotplug happened, as it is still the same virtual monitor).
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ScreenLayoutMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ScreenLayoutMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ScreenLayoutMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ScreenLayoutMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Apply',1:'Reset',2:'Attach',3:'Silent'}
   _ValueMap = {'Apply':0,'Reset':1,'Attach':2,'Silent':3}

   Apply = 0
   Reset = 1
   Attach = 2
   Silent = 3

class NetworkAttachmentType:
   """
      Network attachment type.
    
      "Null" = 0:
        Null value, also means "not attached".
      
      "NAT" = 1:
        
      "Bridged" = 2:
        
      "Internal" = 3:
        
      "HostOnly" = 4:
        
      "Generic" = 5:
        
      "NATNetwork" = 6:
        
      "Cloud" = 7:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = NetworkAttachmentType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,NetworkAttachmentType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,NetworkAttachmentType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return NetworkAttachmentType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'NAT',2:'Bridged',3:'Internal',4:'HostOnly',5:'Generic',6:'NATNetwork',7:'Cloud'}
   _ValueMap = {'Null':0,'NAT':1,'Bridged':2,'Internal':3,'HostOnly':4,'Generic':5,'NATNetwork':6,'Cloud':7}

   Null = 0
   NAT = 1
   Bridged = 2
   Internal = 3
   HostOnly = 4
   Generic = 5
   NATNetwork = 6
   Cloud = 7

class NetworkAdapterType:
   """
      Network adapter type.
    
      "Null" = 0:
        Null value (never used by the API).
      
      "Am79C970A" = 1:
        AMD PCNet-PCI II network card (Am79C970A).
      
      "Am79C973" = 2:
        AMD PCNet-FAST III network card (Am79C973).
      
      "I82540EM" = 3:
        Intel PRO/1000 MT Desktop network card (82540EM).
      
      "I82543GC" = 4:
        Intel PRO/1000 T Server network card (82543GC).
      
      "I82545EM" = 5:
        Intel PRO/1000 MT Server network card (82545EM).
      
      "Virtio" = 6:
        Virtio network device.
      
      "Am79C960" = 7:
        AMD PCnet-ISA/NE2100 network card (Am79C960).
      
      "Virtio_1_0" = 8:
        Virtio 1.0 network device.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = NetworkAdapterType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,NetworkAdapterType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,NetworkAdapterType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return NetworkAdapterType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'Am79C970A',2:'Am79C973',3:'I82540EM',4:'I82543GC',5:'I82545EM',6:'Virtio',7:'Am79C960',8:'Virtio_1_0'}
   _ValueMap = {'Null':0,'Am79C970A':1,'Am79C973':2,'I82540EM':3,'I82543GC':4,'I82545EM':5,'Virtio':6,'Am79C960':7,'Virtio_1_0':8}

   Null = 0
   Am79C970A = 1
   Am79C973 = 2
   I82540EM = 3
   I82543GC = 4
   I82545EM = 5
   Virtio = 6
   Am79C960 = 7
   Virtio_1_0 = 8

class NetworkAdapterPromiscModePolicy:
   """
      The promiscuous mode policy of an interface.
    
      "Deny" = 1:
        Deny promiscuous mode requests.
      
      "AllowNetwork" = 2:
        Allow promiscuous mode, but restrict the scope it to the internal
        network so that it only applies to other VMs.
      
      "AllowAll" = 3:
        Allow promiscuous mode, include unrelated traffic going over the wire
        and internally on the host.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = NetworkAdapterPromiscModePolicy._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,NetworkAdapterPromiscModePolicy):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,NetworkAdapterPromiscModePolicy):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return NetworkAdapterPromiscModePolicy._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {1:'Deny',2:'AllowNetwork',3:'AllowAll'}
   _ValueMap = {'Deny':1,'AllowNetwork':2,'AllowAll':3}

   Deny = 1
   AllowNetwork = 2
   AllowAll = 3

class PortMode:
   """
      The PortMode enumeration represents possible communication modes for
      the virtual serial port device.
    
      "Disconnected" = 0:
        Virtual device is not attached to any real host device.
      
      "HostPipe" = 1:
        Virtual device is attached to a host pipe.
      
      "HostDevice" = 2:
        Virtual device is attached to a host device.
      
      "RawFile" = 3:
        Virtual device is attached to a raw file.
      
      "TCP" = 4:
        Virtual device is attached to a TCP socket.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = PortMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,PortMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,PortMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return PortMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Disconnected',1:'HostPipe',2:'HostDevice',3:'RawFile',4:'TCP'}
   _ValueMap = {'Disconnected':0,'HostPipe':1,'HostDevice':2,'RawFile':3,'TCP':4}

   Disconnected = 0
   HostPipe = 1
   HostDevice = 2
   RawFile = 3
   TCP = 4

class UartType:
   """
      The UART type represents the emulated UART chip for the serial port device.
    
      "U16450" = 0:
        The most basic emulated UART which doesn't support FIFO operation.
      
      "U16550A" = 1:
        The successor of the 16450 UART introducing a 16 byte FIFO to reduce
        operational overhead.
      
      "U16750" = 2:
        This UART developed by Texas Instruments introduced a 64 byte FIFO
        and hardware flow control.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = UartType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,UartType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,UartType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return UartType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'U16450',1:'U16550A',2:'U16750'}
   _ValueMap = {'U16450':0,'U16550A':1,'U16750':2}

   U16450 = 0
   U16550A = 1
   U16750 = 2

class VMExecutionEngine:
   """
      The main execution engine of a VM.
    
      "NotSet" = 0:
        Has not yet been set (try again later).
      
      "RawMode" = 1:
        Raw-mode.
      
      "HwVirt" = 2:
        Hardware assisted virtualization thru HM.
      
      "NativeApi" = 3:
        Hardware assisted virtualization thru native API (NEM).
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = VMExecutionEngine._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VMExecutionEngine):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VMExecutionEngine):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return VMExecutionEngine._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'NotSet',1:'RawMode',2:'HwVirt',3:'NativeApi'}
   _ValueMap = {'NotSet':0,'RawMode':1,'HwVirt':2,'NativeApi':3}

   NotSet = 0
   RawMode = 1
   HwVirt = 2
   NativeApi = 3

class USBControllerType:
   """
      The USB controller type. IUSBController::type.
    
      "Null" = 0:
        @c null value. Never used by the API.
      
      "OHCI" = 1:
        
      "EHCI" = 2:
        
      "XHCI" = 3:
        
      "Last" = 4:
        Last element (invalid). Used for parameter checks.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = USBControllerType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,USBControllerType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,USBControllerType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return USBControllerType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'OHCI',2:'EHCI',3:'XHCI',4:'Last'}
   _ValueMap = {'Null':0,'OHCI':1,'EHCI':2,'XHCI':3,'Last':4}

   Null = 0
   OHCI = 1
   EHCI = 2
   XHCI = 3
   Last = 4

class USBConnectionSpeed:
   """
      USB device/port speed state. This enumeration represents speeds at
      which a USB device can communicate with the host.

      The speed is a function of both the device itself and the port which
      it is attached to, including hubs and cables in the path.

      
        .. note:: 
        Due to differences in USB stack implementations on various hosts,
        the reported speed may not exactly match the actual speed.
      
        .. sealso:: ::IHostUSBDevice
      "Null" = 0:
        @c null value. Never returned by the API.
      
      "Low" = 1:
        Low speed, 1.5 Mbps.
      
      "Full" = 2:
        Full speed, 12 Mbps.
      
      "High" = 3:
        High speed, 480 Mbps.
      
      "Super" = 4:
        SuperSpeed, 5 Gbps.
      
      "SuperPlus" = 5:
        SuperSpeedPlus, 10 Gbps.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = USBConnectionSpeed._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,USBConnectionSpeed):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,USBConnectionSpeed):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return USBConnectionSpeed._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'Low',2:'Full',3:'High',4:'Super',5:'SuperPlus'}
   _ValueMap = {'Null':0,'Low':1,'Full':2,'High':3,'Super':4,'SuperPlus':5}

   Null = 0
   Low = 1
   Full = 2
   High = 3
   Super = 4
   SuperPlus = 5

class USBDeviceState:
   """
      USB device state. This enumeration represents all possible states
      of the USB device physically attached to the host computer regarding
      its state on the host computer and availability to guest computers
      (all currently running virtual machines).

      Once a supported USB device is attached to the host, global USB
      filters (IHost::USBDeviceFilters) are activated. They can
      either ignore the device, or put it to USBDeviceState_Held state, or do
      nothing. Unless the device is ignored by global filters, filters of all
      currently running guests (IUSBDeviceFilters::deviceFilters) are
      activated that can put it to USBDeviceState_Captured state.

      If the device was ignored by global filters, or didn't match
      any filters at all (including guest ones), it is handled by the host
      in a normal way. In this case, the device state is determined by
      the host and can be one of USBDeviceState_Unavailable, USBDeviceState_Busy
      or USBDeviceState_Available, depending on the current device usage.

      Besides auto-capturing based on filters, the device can be manually
      captured by guests (IConsole::attachUSBDevice) if its
      state is USBDeviceState_Busy, USBDeviceState_Available or
      USBDeviceState_Held.

      
        .. note:: 
        Due to differences in USB stack implementations in Linux and Win32,
        states USBDeviceState_Busy and USBDeviceState_Unavailable are applicable
        only to the Linux version of the product. This also means that (IConsole::attachUSBDevice) can only succeed on Win32 if the
        device state is USBDeviceState_Held.
      
        .. sealso:: ::IHostUSBDevice, ::IHostUSBDeviceFilter
      "NotSupported" = 0:
        Not supported by the VirtualBox server, not available to guests.
      
      "Unavailable" = 1:
        Being used by the host computer exclusively,
        not available to guests.
      
      "Busy" = 2:
        Being used by the host computer, potentially available to guests.
      
      "Available" = 3:
        Not used by the host computer, available to guests (the host computer
        can also start using the device at any time).
      
      "Held" = 4:
        Held by the VirtualBox server (ignored by the host computer),
        available to guests.
      
      "Captured" = 5:
        Captured by one of the guest computers, not available
        to anybody else.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = USBDeviceState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,USBDeviceState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,USBDeviceState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return USBDeviceState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'NotSupported',1:'Unavailable',2:'Busy',3:'Available',4:'Held',5:'Captured'}
   _ValueMap = {'NotSupported':0,'Unavailable':1,'Busy':2,'Available':3,'Held':4,'Captured':5}

   NotSupported = 0
   Unavailable = 1
   Busy = 2
   Available = 3
   Held = 4
   Captured = 5

class USBDeviceFilterAction:
   """
      Actions for host USB device filters.
      
        .. sealso:: ::IHostUSBDeviceFilter, ::USBDeviceState
      "Null" = 0:
        Null value (never used by the API).
      
      "Ignore" = 1:
        Ignore the matched USB device.
      
      "Hold" = 2:
        Hold the matched USB device.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = USBDeviceFilterAction._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,USBDeviceFilterAction):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,USBDeviceFilterAction):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return USBDeviceFilterAction._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'Ignore',2:'Hold'}
   _ValueMap = {'Null':0,'Ignore':1,'Hold':2}

   Null = 0
   Ignore = 1
   Hold = 2

class AudioDriverType:
   """
      Host audio driver type.
    
      "Null" = 0:
        Null value, also means "dummy audio driver".
      
      "WinMM" = 1:
        Windows multimedia (Windows hosts only, not supported at the moment).
      
      "OSS" = 2:
        Open Sound System (Linux / Unix hosts only).
      
      "ALSA" = 3:
        Advanced Linux Sound Architecture (Linux hosts only).
      
      "DirectSound" = 4:
        DirectSound (Windows hosts only).
      
      "CoreAudio" = 5:
        CoreAudio (Mac hosts only).
      
      "MMPM" = 6:
        Reserved for historical reasons.
      
      "Pulse" = 7:
        PulseAudio (Linux hosts only).
      
      "SolAudio" = 8:
        Solaris audio (Solaris hosts only, not supported at the moment).
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AudioDriverType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AudioDriverType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AudioDriverType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AudioDriverType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'WinMM',2:'OSS',3:'ALSA',4:'DirectSound',5:'CoreAudio',6:'MMPM',7:'Pulse',8:'SolAudio'}
   _ValueMap = {'Null':0,'WinMM':1,'OSS':2,'ALSA':3,'DirectSound':4,'CoreAudio':5,'MMPM':6,'Pulse':7,'SolAudio':8}

   Null = 0
   WinMM = 1
   OSS = 2
   ALSA = 3
   DirectSound = 4
   CoreAudio = 5
   MMPM = 6
   Pulse = 7
   SolAudio = 8

class AudioControllerType:
   """
      Virtual audio controller type.
    
      "AC97" = 0:
        
      "SB16" = 1:
        
      "HDA" = 2:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AudioControllerType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AudioControllerType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AudioControllerType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AudioControllerType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'AC97',1:'SB16',2:'HDA'}
   _ValueMap = {'AC97':0,'SB16':1,'HDA':2}

   AC97 = 0
   SB16 = 1
   HDA = 2

class AudioCodecType:
   """
      The exact variant of audio codec hardware presented
      to the guest; see IAudioAdapter::audioCodec.
    
      "Null" = 0:
        @c null value. Never used by the API.
      
      "SB16" = 1:
        SB16; this is the only option for the SB16 device.
      
      "STAC9700" = 2:
        A STAC9700 AC'97 codec.
      
      "AD1980" = 3:
        An AD1980 AC'97 codec. Recommended for Linux guests.
      
      "STAC9221" = 4:
        A STAC9221 HDA codec.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AudioCodecType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AudioCodecType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AudioCodecType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AudioCodecType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'SB16',2:'STAC9700',3:'AD1980',4:'STAC9221'}
   _ValueMap = {'Null':0,'SB16':1,'STAC9700':2,'AD1980':3,'STAC9221':4}

   Null = 0
   SB16 = 1
   STAC9700 = 2
   AD1980 = 3
   STAC9221 = 4

class AuthType:
   """
      VirtualBox authentication type.
    
      "Null" = 0:
        Null value, also means "no authentication".
      
      "External" = 1:
        
      "Guest" = 2:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = AuthType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AuthType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AuthType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return AuthType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'External',2:'Guest'}
   _ValueMap = {'Null':0,'External':1,'Guest':2}

   Null = 0
   External = 1
   Guest = 2

class Reason:
   """
      Internal event reason type.
    
      "Unspecified" = 0:
        Null value, means "no known reason".
      
      "HostSuspend" = 1:
        Host is being suspended (power management event).
      
      "HostResume" = 2:
        Host is being resumed (power management event).
      
      "HostBatteryLow" = 3:
        Host is running low on battery (power management event).
      
      "Snapshot" = 4:
        A snapshot of the VM is being taken.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = Reason._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,Reason):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,Reason):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return Reason._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Unspecified',1:'HostSuspend',2:'HostResume',3:'HostBatteryLow',4:'Snapshot'}
   _ValueMap = {'Unspecified':0,'HostSuspend':1,'HostResume':2,'HostBatteryLow':3,'Snapshot':4}

   Unspecified = 0
   HostSuspend = 1
   HostResume = 2
   HostBatteryLow = 3
   Snapshot = 4

class StorageBus:
   """
      The bus type of the storage controller (IDE, SATA, SCSI, SAS or Floppy);
      see IStorageController::bus.
    
      "Null" = 0:
        @c null value. Never used by the API.
      
      "IDE" = 1:
        
      "SATA" = 2:
        
      "SCSI" = 3:
        
      "Floppy" = 4:
        
      "SAS" = 5:
        
      "USB" = 6:
        
      "PCIe" = 7:
        
      "VirtioSCSI" = 8:
        
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = StorageBus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,StorageBus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,StorageBus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return StorageBus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'IDE',2:'SATA',3:'SCSI',4:'Floppy',5:'SAS',6:'USB',7:'PCIe',8:'VirtioSCSI'}
   _ValueMap = {'Null':0,'IDE':1,'SATA':2,'SCSI':3,'Floppy':4,'SAS':5,'USB':6,'PCIe':7,'VirtioSCSI':8}

   Null = 0
   IDE = 1
   SATA = 2
   SCSI = 3
   Floppy = 4
   SAS = 5
   USB = 6
   PCIe = 7
   VirtioSCSI = 8

class StorageControllerType:
   """
      The exact variant of storage controller hardware presented
      to the guest; see IStorageController::controllerType.
    
      "Null" = 0:
        @c null value. Never used by the API.
      
      "LsiLogic" = 1:
        A SCSI controller of the LsiLogic variant.
      
      "BusLogic" = 2:
        A SCSI controller of the BusLogic variant.
      
      "IntelAhci" = 3:
        An Intel AHCI SATA controller; this is the only variant for SATA.
      
      "PIIX3" = 4:
        An IDE controller of the PIIX3 variant.
      
      "PIIX4" = 5:
        An IDE controller of the PIIX4 variant.
      
      "ICH6" = 6:
        An IDE controller of the ICH6 variant.
      
      "I82078" = 7:
        A floppy disk controller; this is the only variant for floppy drives.
      
      "LsiLogicSas" = 8:
        A variant of the LsiLogic controller using SAS.
      
      "USB" = 9:
        Special USB based storage controller.
      
      "NVMe" = 10:
        An NVMe storage controller.
      
      "VirtioSCSI" = 11:
        Virtio SCSI storage controller.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = StorageControllerType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,StorageControllerType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,StorageControllerType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return StorageControllerType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'LsiLogic',2:'BusLogic',3:'IntelAhci',4:'PIIX3',5:'PIIX4',6:'ICH6',7:'I82078',8:'LsiLogicSas',9:'USB',10:'NVMe',11:'VirtioSCSI'}
   _ValueMap = {'Null':0,'LsiLogic':1,'BusLogic':2,'IntelAhci':3,'PIIX3':4,'PIIX4':5,'ICH6':6,'I82078':7,'LsiLogicSas':8,'USB':9,'NVMe':10,'VirtioSCSI':11}

   Null = 0
   LsiLogic = 1
   BusLogic = 2
   IntelAhci = 3
   PIIX3 = 4
   PIIX4 = 5
   ICH6 = 6
   I82078 = 7
   LsiLogicSas = 8
   USB = 9
   NVMe = 10
   VirtioSCSI = 11

class ChipsetType:
   """
      Type of emulated chipset (mostly southbridge).
    
      "Null" = 0:
        @c null value. Never used by the API.
      
      "PIIX3" = 1:
        A PIIX3 (PCI IDE ISA Xcelerator) chipset.
      
      "ICH9" = 2:
        A ICH9 (I/O Controller Hub) chipset.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = ChipsetType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ChipsetType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ChipsetType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return ChipsetType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'PIIX3',2:'ICH9'}
   _ValueMap = {'Null':0,'PIIX3':1,'ICH9':2}

   Null = 0
   PIIX3 = 1
   ICH9 = 2

class NATAliasMode:
   """
      "AliasLog" = 0x1:
        
      
      "AliasProxyOnly" = 0x02:
        
      
      "AliasUseSamePorts" = 0x04:
        
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = NATAliasMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,NATAliasMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,NATAliasMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return NATAliasMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0x1:'AliasLog',0x02:'AliasProxyOnly',0x04:'AliasUseSamePorts'}
   _ValueMap = {'AliasLog':0x1,'AliasProxyOnly':0x02,'AliasUseSamePorts':0x04}

   AliasLog = 0x1
   AliasProxyOnly = 0x02
   AliasUseSamePorts = 0x04

class NATProtocol:
   """Protocol definitions used with NAT port-forwarding rules.
      "UDP" = 0:
        Port-forwarding uses UDP protocol.
      
      "TCP" = 1:
        Port-forwarding uses TCP protocol.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = NATProtocol._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,NATProtocol):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,NATProtocol):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return NATProtocol._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'UDP',1:'TCP'}
   _ValueMap = {'UDP':0,'TCP':1}

   UDP = 0
   TCP = 1

class BandwidthGroupType:
   """
      Type of a bandwidth control group.
    
      "Null" = 0:
        Null type, must be first.
      
      "Disk" = 1:
        The bandwidth group controls disk I/O.
      
      "Network" = 2:
        The bandwidth group controls network I/O.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = BandwidthGroupType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,BandwidthGroupType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,BandwidthGroupType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return BandwidthGroupType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Null',1:'Disk',2:'Network'}
   _ValueMap = {'Null':0,'Disk':1,'Network':2}

   Null = 0
   Disk = 1
   Network = 2

class VBoxEventType:
   """
      Type of an event.
      See ::IEvent for an introduction to VirtualBox event handling.
    
      "Invalid" = 0:
        Invalid event, must be first.
      
      "Any" = 1:
        Wildcard for all events.
        Events of this type are never delivered, and only used in
        IEventSource::registerListener call to simplify registration.
      
      "Vetoable" = 2:
        Wildcard for all vetoable events. Events of this type are never delivered, and only
        used in IEventSource::registerListener call to simplify registration.
      
      "MachineEvent" = 3:
        Wildcard for all machine events. Events of this type are never delivered, and only used in
        IEventSource::registerListener call to simplify registration.
      
      "SnapshotEvent" = 4:
        Wildcard for all snapshot events. Events of this type are never delivered, and only used in
        IEventSource::registerListener call to simplify registration.
      
      "InputEvent" = 5:
        Wildcard for all input device (keyboard, mouse) events.
        Events of this type are never delivered, and only used in
        IEventSource::registerListener call to simplify registration.
      
      "LastWildcard" = 31:
        Last wildcard.
      
      "OnMachineStateChanged" = 32:
        See ::IMachineStateChangedEvent.
      
      "OnMachineDataChanged" = 33:
        See ::IMachineDataChangedEvent.
      
      "OnExtraDataChanged" = 34:
        See ::IExtraDataChangedEvent.
      
      "OnExtraDataCanChange" = 35:
        See ::IExtraDataCanChangeEvent.
      
      "OnMediumRegistered" = 36:
        See ::IMediumRegisteredEvent.
      
      "OnMachineRegistered" = 37:
        See ::IMachineRegisteredEvent.
      
      "OnSessionStateChanged" = 38:
        See ::ISessionStateChangedEvent.
      
      "OnSnapshotTaken" = 39:
        See ::ISnapshotTakenEvent.
      
      "OnSnapshotDeleted" = 40:
        See ::ISnapshotDeletedEvent.
      
      "OnSnapshotChanged" = 41:
        See ::ISnapshotChangedEvent.
      
      "OnGuestPropertyChanged" = 42:
        See ::IGuestPropertyChangedEvent.
      
      "OnMousePointerShapeChanged" = 43:
        See ::IMousePointerShapeChangedEvent.
      
      "OnMouseCapabilityChanged" = 44:
        See ::IMouseCapabilityChangedEvent.
      
      "OnKeyboardLedsChanged" = 45:
        See ::IKeyboardLedsChangedEvent.
      
      "OnStateChanged" = 46:
        See ::IStateChangedEvent.
      
      "OnAdditionsStateChanged" = 47:
        See ::IAdditionsStateChangedEvent.
      
      "OnNetworkAdapterChanged" = 48:
        See ::INetworkAdapterChangedEvent.
      
      "OnSerialPortChanged" = 49:
        See ::ISerialPortChangedEvent.
      
      "OnParallelPortChanged" = 50:
        See ::IParallelPortChangedEvent.
      
      "OnStorageControllerChanged" = 51:
        See ::IStorageControllerChangedEvent.
      
      "OnMediumChanged" = 52:
        See ::IMediumChangedEvent.
      
      "OnVRDEServerChanged" = 53:
        See ::IVRDEServerChangedEvent.
      
      "OnUSBControllerChanged" = 54:
        See ::IUSBControllerChangedEvent.
      
      "OnUSBDeviceStateChanged" = 55:
        See ::IUSBDeviceStateChangedEvent.
      
      "OnSharedFolderChanged" = 56:
        See ::ISharedFolderChangedEvent.
      
      "OnRuntimeError" = 57:
        See ::IRuntimeErrorEvent.
      
      "OnCanShowWindow" = 58:
        See ::ICanShowWindowEvent.
      
      "OnShowWindow" = 59:
        See ::IShowWindowEvent.
      
      "OnCPUChanged" = 60:
        See ::ICPUChangedEvent.
      
      "OnVRDEServerInfoChanged" = 61:
        See ::IVRDEServerInfoChangedEvent.
      
      "OnEventSourceChanged" = 62:
        See ::IEventSourceChangedEvent.
      
      "OnCPUExecutionCapChanged" = 63:
        See ::ICPUExecutionCapChangedEvent.
      
      "OnGuestKeyboard" = 64:
        See ::IGuestKeyboardEvent.
      
      "OnGuestMouse" = 65:
        See ::IGuestMouseEvent.
      
      "OnNATRedirect" = 66:
        See ::INATRedirectEvent.
      
      "OnHostPCIDevicePlug" = 67:
        See ::IHostPCIDevicePlugEvent.
      
      "OnVBoxSVCAvailabilityChanged" = 68:
        See ::IVBoxSVCAvailabilityChangedEvent.
      
      "OnBandwidthGroupChanged" = 69:
        See ::IBandwidthGroupChangedEvent.
      
      "OnGuestMonitorChanged" = 70:
        See ::IGuestMonitorChangedEvent.
      
      "OnStorageDeviceChanged" = 71:
        See ::IStorageDeviceChangedEvent.
      
      "OnClipboardModeChanged" = 72:
        See ::IClipboardModeChangedEvent.
      
      "OnDnDModeChanged" = 73:
        See ::IDnDModeChangedEvent.
      
      "OnNATNetworkChanged" = 74:
        See ::INATNetworkChangedEvent.
      
      "OnNATNetworkStartStop" = 75:
        See ::INATNetworkStartStopEvent.
      
      "OnNATNetworkAlter" = 76:
        See ::INATNetworkAlterEvent.
      
      "OnNATNetworkCreationDeletion" = 77:
        See ::INATNetworkCreationDeletionEvent.
      
      "OnNATNetworkSetting" = 78:
        See ::INATNetworkSettingEvent.
      
      "OnNATNetworkPortForward" = 79:
        See ::INATNetworkPortForwardEvent.
      
      "OnGuestSessionStateChanged" = 80:
        See ::IGuestSessionStateChangedEvent.
      
      "OnGuestSessionRegistered" = 81:
        See ::IGuestSessionRegisteredEvent.
      
      "OnGuestProcessRegistered" = 82:
        See ::IGuestProcessRegisteredEvent.
      
      "OnGuestProcessStateChanged" = 83:
        See ::IGuestProcessStateChangedEvent.
      
      "OnGuestProcessInputNotify" = 84:
        See ::IGuestProcessInputNotifyEvent.
      
      "OnGuestProcessOutput" = 85:
        See ::IGuestProcessOutputEvent.
      
      "OnGuestFileRegistered" = 86:
        See ::IGuestFileRegisteredEvent.
      
      "OnGuestFileStateChanged" = 87:
        See ::IGuestFileStateChangedEvent.
      
      "OnGuestFileOffsetChanged" = 88:
        See ::IGuestFileOffsetChangedEvent.
      
      "OnGuestFileRead" = 89:
        See ::IGuestFileReadEvent.

        
      "OnGuestFileWrite" = 90:
        See ::IGuestFileWriteEvent.

        
      "OnRecordingChanged" = 91:
        See ::IRecordingChangedEvent.
      
      "OnGuestUserStateChanged" = 92:
        See ::IGuestUserStateChangedEvent.
      
      "OnGuestMultiTouch" = 93:
        See ::IGuestMouseEvent.
      
      "OnHostNameResolutionConfigurationChange" = 94:
        See ::IHostNameResolutionConfigurationChangeEvent.
      
      "OnSnapshotRestored" = 95:
        See ::ISnapshotRestoredEvent.
      
      "OnMediumConfigChanged" = 96:
        See ::IMediumConfigChangedEvent.
      
      "OnAudioAdapterChanged" = 97:
        See ::IAudioAdapterChangedEvent.
      
      "OnProgressPercentageChanged" = 98:
        See ::IProgressPercentageChangedEvent.
      
      "OnProgressTaskCompleted" = 99:
        See ::IProgressTaskCompletedEvent.
      
      "OnCursorPositionChanged" = 100:
        See ::ICursorPositionChangedEvent.
      
      "OnGuestAdditionsStatusChanged" = 101:
        See ::IGuestAdditionsStatusChangedEvent.
      
      "OnGuestMonitorInfoChanged" = 102:
        See ::IGuestMonitorInfoChangedEvent.
      
      "OnGuestFileSizeChanged" = 103:
        See ::IGuestFileSizeChangedEvent.
      
      "OnClipboardFileTransferModeChanged" = 104:
        See ::IClipboardFileTransferModeChangedEvent.
      
      "Last" = 105:
        Must be last event, used for iterations and structures relying on numerical event values.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = VBoxEventType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VBoxEventType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VBoxEventType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return VBoxEventType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Invalid',1:'Any',2:'Vetoable',3:'MachineEvent',4:'SnapshotEvent',5:'InputEvent',31:'LastWildcard',32:'OnMachineStateChanged',33:'OnMachineDataChanged',34:'OnExtraDataChanged',35:'OnExtraDataCanChange',36:'OnMediumRegistered',37:'OnMachineRegistered',38:'OnSessionStateChanged',39:'OnSnapshotTaken',40:'OnSnapshotDeleted',41:'OnSnapshotChanged',42:'OnGuestPropertyChanged',43:'OnMousePointerShapeChanged',44:'OnMouseCapabilityChanged',45:'OnKeyboardLedsChanged',46:'OnStateChanged',47:'OnAdditionsStateChanged',48:'OnNetworkAdapterChanged',49:'OnSerialPortChanged',50:'OnParallelPortChanged',51:'OnStorageControllerChanged',52:'OnMediumChanged',53:'OnVRDEServerChanged',54:'OnUSBControllerChanged',55:'OnUSBDeviceStateChanged',56:'OnSharedFolderChanged',57:'OnRuntimeError',58:'OnCanShowWindow',59:'OnShowWindow',60:'OnCPUChanged',61:'OnVRDEServerInfoChanged',62:'OnEventSourceChanged',63:'OnCPUExecutionCapChanged',64:'OnGuestKeyboard',65:'OnGuestMouse',66:'OnNATRedirect',67:'OnHostPCIDevicePlug',68:'OnVBoxSVCAvailabilityChanged',69:'OnBandwidthGroupChanged',70:'OnGuestMonitorChanged',71:'OnStorageDeviceChanged',72:'OnClipboardModeChanged',73:'OnDnDModeChanged',74:'OnNATNetworkChanged',75:'OnNATNetworkStartStop',76:'OnNATNetworkAlter',77:'OnNATNetworkCreationDeletion',78:'OnNATNetworkSetting',79:'OnNATNetworkPortForward',80:'OnGuestSessionStateChanged',81:'OnGuestSessionRegistered',82:'OnGuestProcessRegistered',83:'OnGuestProcessStateChanged',84:'OnGuestProcessInputNotify',85:'OnGuestProcessOutput',86:'OnGuestFileRegistered',87:'OnGuestFileStateChanged',88:'OnGuestFileOffsetChanged',89:'OnGuestFileRead',90:'OnGuestFileWrite',91:'OnRecordingChanged',92:'OnGuestUserStateChanged',93:'OnGuestMultiTouch',94:'OnHostNameResolutionConfigurationChange',95:'OnSnapshotRestored',96:'OnMediumConfigChanged',97:'OnAudioAdapterChanged',98:'OnProgressPercentageChanged',99:'OnProgressTaskCompleted',100:'OnCursorPositionChanged',101:'OnGuestAdditionsStatusChanged',102:'OnGuestMonitorInfoChanged',103:'OnGuestFileSizeChanged',104:'OnClipboardFileTransferModeChanged',105:'Last'}
   _ValueMap = {'Invalid':0,'Any':1,'Vetoable':2,'MachineEvent':3,'SnapshotEvent':4,'InputEvent':5,'LastWildcard':31,'OnMachineStateChanged':32,'OnMachineDataChanged':33,'OnExtraDataChanged':34,'OnExtraDataCanChange':35,'OnMediumRegistered':36,'OnMachineRegistered':37,'OnSessionStateChanged':38,'OnSnapshotTaken':39,'OnSnapshotDeleted':40,'OnSnapshotChanged':41,'OnGuestPropertyChanged':42,'OnMousePointerShapeChanged':43,'OnMouseCapabilityChanged':44,'OnKeyboardLedsChanged':45,'OnStateChanged':46,'OnAdditionsStateChanged':47,'OnNetworkAdapterChanged':48,'OnSerialPortChanged':49,'OnParallelPortChanged':50,'OnStorageControllerChanged':51,'OnMediumChanged':52,'OnVRDEServerChanged':53,'OnUSBControllerChanged':54,'OnUSBDeviceStateChanged':55,'OnSharedFolderChanged':56,'OnRuntimeError':57,'OnCanShowWindow':58,'OnShowWindow':59,'OnCPUChanged':60,'OnVRDEServerInfoChanged':61,'OnEventSourceChanged':62,'OnCPUExecutionCapChanged':63,'OnGuestKeyboard':64,'OnGuestMouse':65,'OnNATRedirect':66,'OnHostPCIDevicePlug':67,'OnVBoxSVCAvailabilityChanged':68,'OnBandwidthGroupChanged':69,'OnGuestMonitorChanged':70,'OnStorageDeviceChanged':71,'OnClipboardModeChanged':72,'OnDnDModeChanged':73,'OnNATNetworkChanged':74,'OnNATNetworkStartStop':75,'OnNATNetworkAlter':76,'OnNATNetworkCreationDeletion':77,'OnNATNetworkSetting':78,'OnNATNetworkPortForward':79,'OnGuestSessionStateChanged':80,'OnGuestSessionRegistered':81,'OnGuestProcessRegistered':82,'OnGuestProcessStateChanged':83,'OnGuestProcessInputNotify':84,'OnGuestProcessOutput':85,'OnGuestFileRegistered':86,'OnGuestFileStateChanged':87,'OnGuestFileOffsetChanged':88,'OnGuestFileRead':89,'OnGuestFileWrite':90,'OnRecordingChanged':91,'OnGuestUserStateChanged':92,'OnGuestMultiTouch':93,'OnHostNameResolutionConfigurationChange':94,'OnSnapshotRestored':95,'OnMediumConfigChanged':96,'OnAudioAdapterChanged':97,'OnProgressPercentageChanged':98,'OnProgressTaskCompleted':99,'OnCursorPositionChanged':100,'OnGuestAdditionsStatusChanged':101,'OnGuestMonitorInfoChanged':102,'OnGuestFileSizeChanged':103,'OnClipboardFileTransferModeChanged':104,'Last':105}

   Invalid = 0
   Any = 1
   Vetoable = 2
   MachineEvent = 3
   SnapshotEvent = 4
   InputEvent = 5
   LastWildcard = 31
   OnMachineStateChanged = 32
   OnMachineDataChanged = 33
   OnExtraDataChanged = 34
   OnExtraDataCanChange = 35
   OnMediumRegistered = 36
   OnMachineRegistered = 37
   OnSessionStateChanged = 38
   OnSnapshotTaken = 39
   OnSnapshotDeleted = 40
   OnSnapshotChanged = 41
   OnGuestPropertyChanged = 42
   OnMousePointerShapeChanged = 43
   OnMouseCapabilityChanged = 44
   OnKeyboardLedsChanged = 45
   OnStateChanged = 46
   OnAdditionsStateChanged = 47
   OnNetworkAdapterChanged = 48
   OnSerialPortChanged = 49
   OnParallelPortChanged = 50
   OnStorageControllerChanged = 51
   OnMediumChanged = 52
   OnVRDEServerChanged = 53
   OnUSBControllerChanged = 54
   OnUSBDeviceStateChanged = 55
   OnSharedFolderChanged = 56
   OnRuntimeError = 57
   OnCanShowWindow = 58
   OnShowWindow = 59
   OnCPUChanged = 60
   OnVRDEServerInfoChanged = 61
   OnEventSourceChanged = 62
   OnCPUExecutionCapChanged = 63
   OnGuestKeyboard = 64
   OnGuestMouse = 65
   OnNATRedirect = 66
   OnHostPCIDevicePlug = 67
   OnVBoxSVCAvailabilityChanged = 68
   OnBandwidthGroupChanged = 69
   OnGuestMonitorChanged = 70
   OnStorageDeviceChanged = 71
   OnClipboardModeChanged = 72
   OnDnDModeChanged = 73
   OnNATNetworkChanged = 74
   OnNATNetworkStartStop = 75
   OnNATNetworkAlter = 76
   OnNATNetworkCreationDeletion = 77
   OnNATNetworkSetting = 78
   OnNATNetworkPortForward = 79
   OnGuestSessionStateChanged = 80
   OnGuestSessionRegistered = 81
   OnGuestProcessRegistered = 82
   OnGuestProcessStateChanged = 83
   OnGuestProcessInputNotify = 84
   OnGuestProcessOutput = 85
   OnGuestFileRegistered = 86
   OnGuestFileStateChanged = 87
   OnGuestFileOffsetChanged = 88
   OnGuestFileRead = 89
   OnGuestFileWrite = 90
   OnRecordingChanged = 91
   OnGuestUserStateChanged = 92
   OnGuestMultiTouch = 93
   OnHostNameResolutionConfigurationChange = 94
   OnSnapshotRestored = 95
   OnMediumConfigChanged = 96
   OnAudioAdapterChanged = 97
   OnProgressPercentageChanged = 98
   OnProgressTaskCompleted = 99
   OnCursorPositionChanged = 100
   OnGuestAdditionsStatusChanged = 101
   OnGuestMonitorInfoChanged = 102
   OnGuestFileSizeChanged = 103
   OnClipboardFileTransferModeChanged = 104
   Last = 105

class GuestMouseEventMode:
   """
      The mode (relative, absolute, multi-touch) of a pointer event.

      @todo A clear pattern seems to be emerging that we should usually have
      multiple input devices active for different types of reporting, so we
      should really have different event types for relative (including wheel),
      absolute (not including wheel) and multi-touch events.
    
      "Relative" = 0:
        Relative event.
      
      "Absolute" = 1:
        Absolute event.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = GuestMouseEventMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,GuestMouseEventMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,GuestMouseEventMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return GuestMouseEventMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Relative',1:'Absolute'}
   _ValueMap = {'Relative':0,'Absolute':1}

   Relative = 0
   Absolute = 1

class GuestMonitorChangedEventType:
   """
      How the guest monitor has been changed.
    
      "Enabled" = 0:
        The guest monitor has been enabled by the guest.
      
      "Disabled" = 1:
        The guest monitor has been disabled by the guest.
      
      "NewOrigin" = 2:
        The guest monitor origin has changed in the guest.
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = GuestMonitorChangedEventType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,GuestMonitorChangedEventType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,GuestMonitorChangedEventType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return GuestMonitorChangedEventType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Enabled',1:'Disabled',2:'NewOrigin'}
   _ValueMap = {'Enabled':0,'Disabled':1,'NewOrigin':2}

   Enabled = 0
   Disabled = 1
   NewOrigin = 2

class FormValueType:
   """
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = FormValueType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FormValueType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FormValueType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return FormValueType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Boolean',1:'String',2:'Choice',3:'RangedInteger'}
   _ValueMap = {'Boolean':0,'String':1,'Choice':2,'RangedInteger':3}

   Boolean = 0
   String = 1
   Choice = 2
   RangedInteger = 3

class CloudMachineState:
   """Cloud instance execution state
      "Invalid" = 0:
        Invalid state
      
      "Provisioning" = 1:
        The machine is in the process of provisioning
      
      "Running" = 2:
        The machine runs
      
      "Starting" = 3:
        The machine is in the process of starting
      
      "Stopping" = 4:
        The machine is in the process of stopping
      
      "Stopped" = 5:
        The machine was stopped
      
      "CreatingImage" = 6:
        The machine is in the process of creating image
      
      "Terminating" = 7:
        The machine is in the process of terminating
      
      "Terminated" = 8:
        The machine was terminated
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = CloudMachineState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CloudMachineState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CloudMachineState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return CloudMachineState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Invalid',1:'Provisioning',2:'Running',3:'Starting',4:'Stopping',5:'Stopped',6:'CreatingImage',7:'Terminating',8:'Terminated'}
   _ValueMap = {'Invalid':0,'Provisioning':1,'Running':2,'Starting':3,'Stopping':4,'Stopped':5,'CreatingImage':6,'Terminating':7,'Terminated':8}

   Invalid = 0
   Provisioning = 1
   Running = 2
   Starting = 3
   Stopping = 4
   Stopped = 5
   CreatingImage = 6
   Terminating = 7
   Terminated = 8

class CloudImageState:
   """Cloud image state
      "Invalid" = 0:
        Invalid state
      
      "Provisioning" = 1:
        The image is in the process of provisioning
      
      "Importing" = 2:
        The image is in the process of importing
      
      "Available" = 3:
        The image is avalable
      
      "Exporting" = 4:
        The image is in the process of exporting
      
      "Disabled" = 5:
        The image is disabled
      
      "Deleted" = 6:
        The image was deleted
      
      
   """
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,str):
           self.handle = CloudImageState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CloudImageState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,str):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CloudImageState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,str):
         return str(self) != other
      return True

   def __str__(self):
        return CloudImageState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap = {0:'Invalid',1:'Provisioning',2:'Importing',3:'Available',4:'Exporting',5:'Disabled',6:'Deleted'}
   _ValueMap = {'Invalid':0,'Provisioning':1,'Importing':2,'Available':3,'Exporting':4,'Disabled':5,'Deleted':6}

   Invalid = 0
   Provisioning = 1
   Importing = 2
   Available = 3
   Exporting = 4
   Disabled = 5
   Deleted = 6


import base64

class IWebsessionManager2(IWebsessionManager, ObjectRefManager):
  def __init__(self, url, wsdl=""):
       """
       :param url:  URL to remote server (e.g. 'http://localhost:18083')
       :param wsdl: URL to wsdl file, either remote or local with file:///
       """

       if len(wsdl) == 0:
           self.wsdl = url + "/?wsdl"
       else:
           self.wsdl = wsdl
       self.url = url
       self.port = None
       self.handle = None
       self.mgr = self
       self.service = None
       self.client = zeep.Client(self.wsdl)
       ObjectRefManager.__init__(self, self.mgr)

  def getService(self):
      if self.service is None:
          self.service = self.client.create_service('{http://www.virtualbox.org/}vboxBinding', self.url)
      return self.service

  def decodebase64(self, str):
      return base64.b64decode(str)

  def encodebase64(self, str):
      return base64.b64encode(str)
